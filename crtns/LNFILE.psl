LNFILE(RecordLN ln, String vpar, Boolean vparNorm) // LN - Loan File Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 14:16 - joynerd
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (1027)           08/14/2007
	// Trigger Definition (152)                    08/23/2007
	// Journal File Definition (16)                07/17/2007
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = ln.getMode()                          // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar

	if %O = 0 do AUDIT^UCUTILN(ln,.vxins(),10,"|")
	if %O = 1 quit:'ln.isChanged()  do AUDIT^UCUTILN(ln,.vx(),10,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String CID = ln.cid

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("CID").exists() do vkchged quit                 // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("LN",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("ACN","CID = :ln.cid")             // No record exists
		if vpar["/TRIGBEF/" do VBD                            // Before delete triggers
		do vdelete(0)
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String CID

	type RecordLN ln = Db.getRecord("LN","CID=:CID")
	if (%ProcessMode = 2) do {
		do ln.setMode(2)

		do LNFILE(ln,vpar)
	}
	else  do VINDEX(ln)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordLN ln

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("ACN","CID = :ln.cid") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if vpar["/VALFK/" do CHKFKS                            // Check foreign keys
	if vpar["/VALRI/" do VFKEYS                            // Foreign key definition

	if vpar'["/NOUPDATE/" do {

		set ln.FMLD = %SystemDate
		type String n = -1
		type String x

		if %O = 0 for  set n = vobj(ln,n).order() quit:n.isNull()  do {
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^ACN(vobj(ln,-3),n)=vobj(ln,n)
			#ENDBYPASS
		}

		else  for  set n = vobj(ln,-100,n).order() quit:n.isNull()  do {
			quit:'$D(vobj(ln,n))
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^ACN(vobj(ln,-3),n)=vobj(ln,n)
			#ENDBYPASS
		}


		if vpar["/JOURNAL/" do VJOURNAL(.ln)                  // Create journal files
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.ln) // Update Index files

	quit

vload // Record Load - force loading of unloaded data

	type public RecordLN ln
	type String n = ""

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	for  set n=$order(^ACN(vobj(ln,-3),n)) quit:n=""  if '$D(vobj(ln,n)),$D(^ACN(vobj(ln,-3),n))#2 set vobj(ln,n)=^(n)
	#ENDBYPASS
	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordLN ln

	if 'vkeychg.get(),ln.isChanged() throw Class.new("Error","%PSL-E-DBFILER,Deleted object cannot be modified")

	if vpar["/CASDEL/" do VCASDEL                          // Cascade delete
	if vpar["/INDEX/" do VINDEX(.ln)                       // Delete index entries
	if vpar["/JOURNAL/" do VJOURNAL(.ln)                   // Create journal entries

	// Allow global reference - Delete record
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^ACN(vobj(ln,-3))
	#ENDBYPASS
	quit


vinit // Initialize default values

	type public RecordLN ln

	// Type local variables for access keys for defaults
	type public String CID

	if ln.actibpay.isNull() set ln.actibpay = 0            // actibpay
	if ln.addlchg.isNull() set ln.addlchg = 0              // addlchg
	if ln.adf.isNull() set ln.adf = 0                      // adf
	if ln.adjcol.isNull() set ln.adjcol = 0                // adjcol
	if ln.adjcrlmt.isNull() set ln.adjcrlmt = 0            // adjcrlmt
	if ln.affln.isNull() set ln.affln = 0                  // affln
	if ln.aflg.isNull() set ln.aflg = 0                    // aflg
	if ln.aipr.isNull() set ln.aipr = 0                    // aipr
	if ln.air.isNull() set ln.air = 0                      // air
	if ln.alprty.isNull() set ln.alprty = 0                // alprty
	if ln.anlsys.isNull() set ln.anlsys = 0                // anlsys
	if ln.aomcode.isNull() set ln.aomcode = 0              // aomcode
	if ln.aruf.isNull() set ln.aruf = 0                    // aruf
	if ln.assumf.isNull() set ln.assumf = 0                // assumf
	if ln.auo.isNull() set ln.auo = 0                      // auo
	if ln.avcrlmt.isNull() set ln.avcrlmt = 0              // avcrlmt
	if ln.bcapint.isNull() set ln.bcapint = 0              // bcapint
	if ln.bmet.isNull() set ln.bmet = 0                    // bmet
	if ln.bpocl.isNull() set ln.bpocl = 0                  // bpocl
	if ln.cbf.isNull() set ln.cbf = 0                      // cbf
	if ln.ccbind.isNull() set ln.ccbind = 0                // ccbind
	if ln.cdf.isNull() set ln.cdf = 0                      // cdf
	if ln.chkeuro.isNull() set ln.chkeuro = 0              // chkeuro
	if ln.chkiss.isNull() set ln.chkiss = 0                // chkiss
	if ln.cintbnp.isNull() set ln.cintbnp = 0              // cintbnp
	if ln.cmsflg.isNull() set ln.cmsflg = 0                // cmsflg
	if ln.cof.isNull() set ln.cof = 0                      // cof
	if ln.collimpr.isNull() set ln.collimpr = 0            // collimpr
	if ln.collque.isNull() set ln.collque = 0              // collque
	if ln.comm.isNull() set ln.comm = 0                    // comm
	if ln.concal.isNull() set ln.concal = 0                // concal
	if ln.cpf.isNull() set ln.cpf = 0                      // cpf
	if ln.custom1.isNull() set ln.custom1 = 0              // custom1
	if ln.custom2.isNull() set ln.custom2 = 0              // custom2
	if ln.custom3.isNull() set ln.custom3 = 0              // custom3
	if ln.dip.isNull() set ln.dip = 0                      // dip
	if ln.dirdef.isNull() set ln.dirdef = 0                // dirdef
	if ln.dl1.isNull() set ln.dl1 = 0                      // dl1
	if ln.dl2.isNull() set ln.dl2 = 0                      // dl2
	if ln.dl3.isNull() set ln.dl3 = 0                      // dl3
	if ln.dl4.isNull() set ln.dl4 = 0                      // dl4
	if ln.dl5.isNull() set ln.dl5 = 0                      // dl5
	if ln.dl6.isNull() set ln.dl6 = 0                      // dl6
	if ln.dl7.isNull() set ln.dl7 = 0                      // dl7
	if ln.dlcaf.isNull() set ln.dlcaf = 0                  // dlcaf
	if ln.dlrp.isNull() set ln.dlrp = 0                    // dlrp
	if ln.dmndln.isNull() set ln.dmndln = 0                // dmndln
	if ln.dp1.isNull() set ln.dp1 = 0                      // dp1
	if ln.dp2.isNull() set ln.dp2 = 0                      // dp2
	if ln.dp3.isNull() set ln.dp3 = 0                      // dp3
	if ln.dp4.isNull() set ln.dp4 = 0                      // dp4
	if ln.dp5.isNull() set ln.dp5 = 0                      // dp5
	if ln.dp6.isNull() set ln.dp6 = 0                      // dp6
	if ln.dp7.isNull() set ln.dp7 = 0                      // dp7
	if ln.drf.isNull() set ln.drf = 0                      // drf
	if ln.dschpr.isNull() set ln.dschpr = 0                // dschpr
	if ln.dxsi.isNull() set ln.dxsi = 0                    // dxsi
	if ln.dy1.isNull() set ln.dy1 = 0                      // dy1
	if ln.dy2.isNull() set ln.dy2 = 0                      // dy2
	if ln.dy3.isNull() set ln.dy3 = 0                      // dy3
	if ln.dy4.isNull() set ln.dy4 = 0                      // dy4
	if ln.dy5.isNull() set ln.dy5 = 0                      // dy5
	if ln.dy6.isNull() set ln.dy6 = 0                      // dy6
	if ln.dy7.isNull() set ln.dy7 = 0                      // dy7
	if ln.eacip.isNull() set ln.eacip = 0                  // eacip
	if ln.eftdd.isNull() set ln.eftdd = 0                  // eftdd
	if ln.eftdeb.isNull() set ln.eftdeb = 0                // eftdeb
	if ln.eftreq.isNull() set ln.eftreq = 0                // eftreq
	if ln.emplben.isNull() set ln.emplben = 0              // emplben
	if ln.entf.isNull() set ln.entf = 0                    // entf
	if ln.epa.isNull() set ln.epa = 0                      // epa
	if ln.flat.isNull() set ln.flat = 0                    // flat
	if ln.fpaf.isNull() set ln.fpaf = 0                    // fpaf
	if ln.fpind.isNull() set ln.fpind = 0                  // fpind
	if ln.fsovrdue.isNull() set ln.fsovrdue = 0            // fsovrdue
	if ln.genprjrep.isNull() set ln.genprjrep = 0          // genprjrep
	if ln.genprn.isNull() set ln.genprn = 0                // genprn
	if ln.highvol.isNull() set ln.highvol = 0              // highvol
	if ln.hip.isNull() set ln.hip = 0                      // hip
	if ln.icap.isNull() set ln.icap = 0                    // icap
	if ln.intcap.isNull() set ln.intcap = 0                // intcap
	if ln.ipd.isNull() set ln.ipd = 0                      // ipd
	if ln.iplcf.isNull() set ln.iplcf = 0                  // iplcf
	if ln.ircb.isNull() set ln.ircb = 0                    // ircb
	if ln.irp.isNull() set ln.irp = 0                      // irp
	if ln.lchgnoto.isNull() set ln.lchgnoto = 0            // lchgnoto
	if ln.lip.isNull() set ln.lip = 0                      // lip
	if ln.mdf.isNull() set ln.mdf = 0                      // mdf
	if ln.mscp.isNull() set ln.mscp = 0                    // mscp
	if ln.mt900.isNull() set ln.mt900 = 0                  // mt900
	if ln.mt910.isNull() set ln.mt910 = 0                  // mt910
	if ln.nai.isNull() set ln.nai = 0                      // nai
	if ln.negacrpo.isNull() set ln.negacrpo = 0            // negacrpo
	if ln.ocaf.isNull() set ln.ocaf = 0                    // ocaf
	type public String TJD
	if ln.odt.isNull() set ln.odt = TJD                    // odt
	if ln.ooc.isNull() set ln.ooc = 0                      // ooc
	if ln.osgncrdc.isNull() set ln.osgncrdc = 0            // osgncrdc
	if ln.paf.isNull() set ln.paf = 0                      // paf
	if ln.paoi.isNull() set ln.paoi = 0                    // paoi
	if ln.payeft.isNull() set ln.payeft = 0                // payeft
	if ln.pbi.isNull() set ln.pbi = 0                      // pbi
	if ln.peba.isNull() set ln.peba = 0                    // peba
	if ln.pflg.isNull() set ln.pflg = 0                    // pflg
	if ln.phld.isNull() set ln.phld = 0                    // phld
	if ln.piacm.isNull() set ln.piacm = 0                  // piacm
	if ln.pldf.isNull() set ln.pldf = 0                    // pldf
	if ln.ppflg.isNull() set ln.ppflg = 0                  // ppflg
	if ln.ptf.isNull() set ln.ptf = 0                      // ptf
	if ln.ptsp.isNull() set ln.ptsp = 0                    // ptsp
	if ln.raclc.isNull() set ln.raclc = 0                  // raclc
	if ln.raclf.isNull() set ln.raclf = 0                  // raclf
	if ln.rcbind.isNull() set ln.rcbind = 0                // rcbind
	if ln.reccd.isNull() set ln.reccd = 0                  // reccd
	if ln.refflg.isNull() set ln.refflg = 0                // refflg
	if ln.regcc.isNull() set ln.regcc = 0                  // regcc
	if ln.revf.isNull() set ln.revf = 0                    // revf
	if ln.rflg.isNull() set ln.rflg = 0                    // rflg
	if ln.rfmo.isNull() set ln.rfmo = 0                    // rfmo
	if ln.rnflg.isNull() set ln.rnflg = 0                  // rnflg
	if ln.rpidc.isNull() set ln.rpidc = 0                  // rpidc
	if ln.rpmo.isNull() set ln.rpmo = 0                    // rpmo
	if ln.secmtg.isNull() set ln.secmtg = 0                // secmtg
	if ln.segments.isNull() set ln.segments = 0            // segments
	if ln.sibf.isNull() set ln.sibf = 0                    // sibf
	if ln.smet.isNull() set ln.smet = 0                    // smet
	if ln.srcbind.isNull() set ln.srcbind = 0              // srcbind
	if ln.swpel.isNull() set ln.swpel = 0                  // swpel
	if ln.trunc.isNull() set ln.trunc = 0                  // trunc
	if ln.wdlmtp.isNull() set ln.wdlmtp = 0                // wdlmtp
	if ln.woff.isNull() set ln.woff = 0                    // woff
	if ln.wspousfl.isNull() set ln.wspousfl = 0            // wspousfl
	quit


vreqn // Validate required data items

	type public RecordLN ln

	if ln.acn.isNull() do vreqerr("ACN") quit
	if ln.acnrelc.isNull() do vreqerr("ACNRELC") quit
	if ln.actibpay.isNull() do vreqerr("ACTIBPAY") quit
	if ln.addlchg.isNull() do vreqerr("ADDLCHG") quit
	if ln.adf.isNull() do vreqerr("ADF") quit
	if ln.adjcol.isNull() do vreqerr("ADJCOL") quit
	if ln.adjcrlmt.isNull() do vreqerr("ADJCRLMT") quit
	if ln.affln.isNull() do vreqerr("AFFLN") quit
	if ln.aflg.isNull() do vreqerr("AFLG") quit
	if ln.aipr.isNull() do vreqerr("AIPR") quit
	if ln.air.isNull() do vreqerr("AIR") quit
	if ln.alprty.isNull() do vreqerr("ALPRTY") quit
	if ln.amtreq.isNull() do vreqerr("AMTREQ") quit
	if ln.anlsys.isNull() do vreqerr("ANLSYS") quit
	if ln.aruf.isNull() do vreqerr("ARUF") quit
	if ln.assumf.isNull() do vreqerr("ASSUMF") quit
	if ln.auo.isNull() do vreqerr("AUO") quit
	if ln.avcrlmt.isNull() do vreqerr("AVCRLMT") quit
	if ln.bcapint.isNull() do vreqerr("BCAPINT") quit
	if ln.bmet.isNull() do vreqerr("BMET") quit
	if ln.boo.isNull() do vreqerr("BOO") quit
	if ln.bpocl.isNull() do vreqerr("BPOCL") quit
	if ln.cbf.isNull() do vreqerr("CBF") quit
	if ln.cc.isNull() do vreqerr("CC") quit
	if ln.ccbind.isNull() do vreqerr("CCBIND") quit
	if ln.cdf.isNull() do vreqerr("CDF") quit
	if ln.chkeuro.isNull() do vreqerr("CHKEURO") quit
	if ln.chkiss.isNull() do vreqerr("CHKISS") quit
	if ln.cintbnp.isNull() do vreqerr("CINTBNP") quit
	if ln.cls.isNull() do vreqerr("CLS") quit
	if ln.cmsflg.isNull() do vreqerr("CMSFLG") quit
	if ln.cof.isNull() do vreqerr("COF") quit
	if ln.collimpr.isNull() do vreqerr("COLLIMPR") quit
	if ln.collque.isNull() do vreqerr("COLLQUE") quit
	if ln.comm.isNull() do vreqerr("COMM") quit
	if ln.concal.isNull() do vreqerr("CONCAL") quit
	if ln.cpf.isNull() do vreqerr("CPF") quit
	if ln.crcd.isNull() do vreqerr("CRCD") quit
	if ln.custom1.isNull() do vreqerr("CUSTOM1") quit
	if ln.custom2.isNull() do vreqerr("CUSTOM2") quit
	if ln.custom3.isNull() do vreqerr("CUSTOM3") quit
	if ln.dip.isNull() do vreqerr("DIP") quit
	if ln.dirdef.isNull() do vreqerr("DIRDEF") quit
	if ln.dlcaf.isNull() do vreqerr("DLCAF") quit
	if ln.dlrp.isNull() do vreqerr("DLRP") quit
	if ln.dmndln.isNull() do vreqerr("DMNDLN") quit
	if ln.drf.isNull() do vreqerr("DRF") quit
	if ln.dschpr.isNull() do vreqerr("DSCHPR") quit
	if ln.dxsi.isNull() do vreqerr("DXSI") quit
	if ln.eacip.isNull() do vreqerr("EACIP") quit
	if ln.eftdd.isNull() do vreqerr("EFTDD") quit
	if ln.eftdeb.isNull() do vreqerr("EFTDEB") quit
	if ln.eftreq.isNull() do vreqerr("EFTREQ") quit
	if ln.emplben.isNull() do vreqerr("EMPLBEN") quit
	if ln.entf.isNull() do vreqerr("ENTF") quit
	if ln.epa.isNull() do vreqerr("EPA") quit
	if ln.flat.isNull() do vreqerr("FLAT") quit
	if ln.fpaf.isNull() do vreqerr("FPAF") quit
	if ln.fpind.isNull() do vreqerr("FPIND") quit
	if ln.fsovrdue.isNull() do vreqerr("FSOVRDUE") quit
	if ln.genprjrep.isNull() do vreqerr("GENPRJREP") quit
	if ln.genprn.isNull() do vreqerr("GENPRN") quit
	if ln.glsc.isNull() do vreqerr("GLSC") quit
	if ln.grp.isNull() do vreqerr("GRP") quit
	if ln.highvol.isNull() do vreqerr("HIGHVOL") quit
	if ln.hip.isNull() do vreqerr("HIP") quit
	if ln.icap.isNull() do vreqerr("ICAP") quit
	if ln.icpa.isNull() do vreqerr("ICPA") quit
	if ln.intcap.isNull() do vreqerr("INTCAP") quit
	if ln.ipd.isNull() do vreqerr("IPD") quit
	if ln.iplcf.isNull() do vreqerr("IPLCF") quit
	if ln.ircb.isNull() do vreqerr("IRCB") quit
	if ln.irp.isNull() do vreqerr("IRP") quit
	if ln.lchgnoto.isNull() do vreqerr("LCHGNOTO") quit
	if ln.lip.isNull() do vreqerr("LIP") quit
	if ln.mdf.isNull() do vreqerr("MDF") quit
	if ln.minopt.isNull() do vreqerr("MINOPT") quit
	if ln.mscp.isNull() do vreqerr("MSCP") quit
	if ln.mt900.isNull() do vreqerr("MT900") quit
	if ln.mt910.isNull() do vreqerr("MT910") quit
	if ln.nai.isNull() do vreqerr("NAI") quit
	if ln.negacrpo.isNull() do vreqerr("NEGACRPO") quit
	if ln.ocaf.isNull() do vreqerr("OCAF") quit
	if ln.odt.isNull() do vreqerr("ODT") quit
	if ln.ooc.isNull() do vreqerr("OOC") quit
	if ln.osgncrdc.isNull() do vreqerr("OSGNCRDC") quit
	if ln.paf.isNull() do vreqerr("PAF") quit
	if ln.paoi.isNull() do vreqerr("PAOI") quit
	if ln.pap.isNull() do vreqerr("PAP") quit
	if ln.pas.isNull() do vreqerr("PAS") quit
	if ln.payeft.isNull() do vreqerr("PAYEFT") quit
	if ln.pbi.isNull() do vreqerr("PBI") quit
	if ln.peba.isNull() do vreqerr("PEBA") quit
	if ln.pflg.isNull() do vreqerr("PFLG") quit
	if ln.phld.isNull() do vreqerr("PHLD") quit
	if ln.piacm.isNull() do vreqerr("PIACM") quit
	if ln.pldf.isNull() do vreqerr("PLDF") quit
	if ln.ppflg.isNull() do vreqerr("PPFLG") quit
	if ln.psgncrdr.isNull() do vreqerr("PSGNCRDR") quit
	if ln.ptf.isNull() do vreqerr("PTF") quit
	if ln.ptsp.isNull() do vreqerr("PTSP") quit
	if ln.raclc.isNull() do vreqerr("RACLC") quit
	if ln.raclf.isNull() do vreqerr("RACLF") quit
	if ln.rcbind.isNull() do vreqerr("RCBIND") quit
	if ln.reccd.isNull() do vreqerr("RECCD") quit
	if ln.refflg.isNull() do vreqerr("REFFLG") quit
	if ln.regcc.isNull() do vreqerr("REGCC") quit
	if ln.revf.isNull() do vreqerr("REVF") quit
	if ln.rflg.isNull() do vreqerr("RFLG") quit
	if ln.rfmo.isNull() do vreqerr("RFMO") quit
	if ln.rnflg.isNull() do vreqerr("RNFLG") quit
	if ln.rpidc.isNull() do vreqerr("RPIDC") quit
	if ln.rpmo.isNull() do vreqerr("RPMO") quit
	if ln.secmtg.isNull() do vreqerr("SECMTG") quit
	if ln.segments.isNull() do vreqerr("SEGMENTS") quit
	if ln.sgncrd.isNull() do vreqerr("SGNCRD") quit
	if ln.sgncrdchgdt.isNull() do vreqerr("SGNCRDCHGDT") quit
	if ln.sibf.isNull() do vreqerr("SIBF") quit
	if ln.smet.isNull() do vreqerr("SMET") quit
	if ln.srcbind.isNull() do vreqerr("SRCBIND") quit
	if ln.stat.isNull() do vreqerr("STAT") quit
	if ln.swpel.isNull() do vreqerr("SWPEL") quit
	if ln.trb.isNull() do vreqerr("TRB") quit
	if ln.trunc.isNull() do vreqerr("TRUNC") quit
	if ln.type.isNull() do vreqerr("TYPE") quit
	if ln.wdlmtp.isNull() do vreqerr("WDLMTP") quit
	if ln.woff.isNull() do vreqerr("WOFF") quit
	if ln.wspousfl.isNull() do vreqerr("WSPOUSFL") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordLN ln

	if ln.cid.isNull() do vreqerr("CID") quit

	if 'vobj(ln,-100,49,"").order().isNull() do {
		if vx("MINOPT").exists(),ln.minopt.isNull() do vreqerr("MINOPT") quit
		if vx("ARUF").exists(),ln.aruf.isNull() do vreqerr("ARUF") quit
		if vx("PAP").exists(),ln.pap.isNull() do vreqerr("PAP") quit
		if vx("IRCB").exists(),ln.ircb.isNull() do vreqerr("IRCB") quit
		if vx("CPF").exists(),ln.cpf.isNull() do vreqerr("CPF") quit
		if vx("TRB").exists(),ln.trb.isNull() do vreqerr("TRB") quit
		if vx("PAS").exists(),ln.pas.isNull() do vreqerr("PAS") quit
		if vx("SIBF").exists(),ln.sibf.isNull() do vreqerr("SIBF") quit
		if vx("NEGACRPO").exists(),ln.negacrpo.isNull() do vreqerr("NEGACRPO") quit
	}
	if 'vobj(ln,-100,50,"").order().isNull() do {
		if vx("TYPE").exists(),ln.type.isNull() do vreqerr("TYPE") quit
		if vx("CLS").exists(),ln.cls.isNull() do vreqerr("CLS") quit
		if vx("GRP").exists(),ln.grp.isNull() do vreqerr("GRP") quit
		if vx("CC").exists(),ln.cc.isNull() do vreqerr("CC") quit
		if vx("CRCD").exists(),ln.crcd.isNull() do vreqerr("CRCD") quit
		if vx("ANLSYS").exists(),ln.anlsys.isNull() do vreqerr("ANLSYS") quit
		if vx("COMM").exists(),ln.comm.isNull() do vreqerr("COMM") quit
		if vx("REGCC").exists(),ln.regcc.isNull() do vreqerr("REGCC") quit
		if vx("GLSC").exists(),ln.glsc.isNull() do vreqerr("GLSC") quit
		if vx("CUSTOM1").exists(),ln.custom1.isNull() do vreqerr("CUSTOM1") quit
		if vx("CUSTOM2").exists(),ln.custom2.isNull() do vreqerr("CUSTOM2") quit
		if vx("CUSTOM3").exists(),ln.custom3.isNull() do vreqerr("CUSTOM3") quit
		if vx("HIGHVOL").exists(),ln.highvol.isNull() do vreqerr("HIGHVOL") quit
		if vx("EMPLBEN").exists(),ln.emplben.isNull() do vreqerr("EMPLBEN") quit
	}
	if 'vobj(ln,-100,51,"").order().isNull() do {
		if vx("RFLG").exists(),ln.rflg.isNull() do vreqerr("RFLG") quit
		if vx("PHLD").exists(),ln.phld.isNull() do vreqerr("PHLD") quit
		if vx("REVF").exists(),ln.revf.isNull() do vreqerr("REVF") quit
		if vx("PBI").exists(),ln.pbi.isNull() do vreqerr("PBI") quit
		if vx("ICPA").exists(),ln.icpa.isNull() do vreqerr("ICPA") quit
		if vx("STAT").exists(),ln.stat.isNull() do vreqerr("STAT") quit
		if vx("ADF").exists(),ln.adf.isNull() do vreqerr("ADF") quit
		if vx("ENTF").exists(),ln.entf.isNull() do vreqerr("ENTF") quit
	}
	if 'vobj(ln,-100,52,"").order().isNull() do {
		if vx("BOO").exists(),ln.boo.isNull() do vreqerr("BOO") quit
		if vx("ODT").exists(),ln.odt.isNull() do vreqerr("ODT") quit
		if vx("TRUNC").exists(),ln.trunc.isNull() do vreqerr("TRUNC") quit
	}
	if 'vobj(ln,-100,53,"").order().isNull() do {
		if vx("AMTREQ").exists(),ln.amtreq.isNull() do vreqerr("AMTREQ") quit
		if vx("SWPEL").exists(),ln.swpel.isNull() do vreqerr("SWPEL") quit
		if vx("AIPR").exists(),ln.aipr.isNull() do vreqerr("AIPR") quit
		if vx("IPD").exists(),ln.ipd.isNull() do vreqerr("IPD") quit
	}
	if 'vobj(ln,-100,54,"").order().isNull() do {
		if vx("IPLCF").exists(),ln.iplcf.isNull() do vreqerr("IPLCF") quit
		if vx("NAI").exists(),ln.nai.isNull() do vreqerr("NAI") quit
	}
	if 'vobj(ln,-100,55,"").order().isNull() do {
		if vx("DLCAF").exists(),ln.dlcaf.isNull() do vreqerr("DLCAF") quit
		if vx("WOFF").exists(),ln.woff.isNull() do vreqerr("WOFF") quit
	}
	if 'vobj(ln,-100,56,"").order().isNull() do {
		if vx("RFMO").exists(),ln.rfmo.isNull() do vreqerr("RFMO") quit
		if vx("RPMO").exists(),ln.rpmo.isNull() do vreqerr("RPMO") quit
		if vx("ALPRTY").exists(),ln.alprty.isNull() do vreqerr("ALPRTY") quit
		if vx("CCBIND").exists(),ln.ccbind.isNull() do vreqerr("CCBIND") quit
		if vx("SRCBIND").exists(),ln.srcbind.isNull() do vreqerr("SRCBIND") quit
		if vx("RNFLG").exists(),ln.rnflg.isNull() do vreqerr("RNFLG") quit
		if vx("RCBIND").exists(),ln.rcbind.isNull() do vreqerr("RCBIND") quit
		if vx("FPIND").exists(),ln.fpind.isNull() do vreqerr("FPIND") quit
	}
	if 'vobj(ln,-100,57,"").order().isNull() do {
		if vx("RPIDC").exists(),ln.rpidc.isNull() do vreqerr("RPIDC") quit
		if vx("AIR").exists(),ln.air.isNull() do vreqerr("AIR") quit
		if vx("FLAT").exists(),ln.flat.isNull() do vreqerr("FLAT") quit
	}
	if 'vobj(ln,-100,58,"").order().isNull() do {
		if vx("DRF").exists(),ln.drf.isNull() do vreqerr("DRF") quit
		if vx("PFLG").exists(),ln.pflg.isNull() do vreqerr("PFLG") quit
		if vx("FPAF").exists(),ln.fpaf.isNull() do vreqerr("FPAF") quit
		if vx("EACIP").exists(),ln.eacip.isNull() do vreqerr("EACIP") quit
		if vx("AUO").exists(),ln.auo.isNull() do vreqerr("AUO") quit
		if vx("PPFLG").exists(),ln.ppflg.isNull() do vreqerr("PPFLG") quit
		if vx("INTCAP").exists(),ln.intcap.isNull() do vreqerr("INTCAP") quit
	}
	if 'vobj(ln,-100,60,"").order().isNull() do {
		if vx("PIACM").exists(),ln.piacm.isNull() do vreqerr("PIACM") quit
	}
	if 'vobj(ln,-100,61,"").order().isNull() do {
		if vx("CHKISS").exists(),ln.chkiss.isNull() do vreqerr("CHKISS") quit
		if vx("CHKEURO").exists(),ln.chkeuro.isNull() do vreqerr("CHKEURO") quit
	}
	if 'vobj(ln,-100,62,"").order().isNull() do {
		if vx("EFTDEB").exists(),ln.eftdeb.isNull() do vreqerr("EFTDEB") quit
		if vx("EFTREQ").exists(),ln.eftreq.isNull() do vreqerr("EFTREQ") quit
		if vx("DSCHPR").exists(),ln.dschpr.isNull() do vreqerr("DSCHPR") quit
		if vx("EFTDD").exists(),ln.eftdd.isNull() do vreqerr("EFTDD") quit
		if vx("SMET").exists(),ln.smet.isNull() do vreqerr("SMET") quit
		if vx("ACTIBPAY").exists(),ln.actibpay.isNull() do vreqerr("ACTIBPAY") quit
	}
	if 'vobj(ln,-100,64,"").order().isNull() do {
		if vx("PAF").exists(),ln.paf.isNull() do vreqerr("PAF") quit
		if vx("MDF").exists(),ln.mdf.isNull() do vreqerr("MDF") quit
		if vx("EPA").exists(),ln.epa.isNull() do vreqerr("EPA") quit
		if vx("LCHGNOTO").exists(),ln.lchgnoto.isNull() do vreqerr("LCHGNOTO") quit
	}
	if 'vobj(ln,-100,70,"").order().isNull() do {
		if vx("DIP").exists(),ln.dip.isNull() do vreqerr("DIP") quit
		if vx("LIP").exists(),ln.lip.isNull() do vreqerr("LIP") quit
		if vx("HIP").exists(),ln.hip.isNull() do vreqerr("HIP") quit
		if vx("DLRP").exists(),ln.dlrp.isNull() do vreqerr("DLRP") quit
		if vx("PTSP").exists(),ln.ptsp.isNull() do vreqerr("PTSP") quit
		if vx("MSCP").exists(),ln.mscp.isNull() do vreqerr("MSCP") quit
		if vx("CMSFLG").exists(),ln.cmsflg.isNull() do vreqerr("CMSFLG") quit
	}
	if 'vobj(ln,-100,71,"").order().isNull() do {
		if vx("PLDF").exists(),ln.pldf.isNull() do vreqerr("PLDF") quit
	}
	if 'vobj(ln,-100,80,"").order().isNull() do {
		if vx("ADJCRLMT").exists(),ln.adjcrlmt.isNull() do vreqerr("ADJCRLMT") quit
	}
	if 'vobj(ln,-100,85,"").order().isNull() do {
		if vx("AFLG").exists(),ln.aflg.isNull() do vreqerr("AFLG") quit
		if vx("OCAF").exists(),ln.ocaf.isNull() do vreqerr("OCAF") quit
		if vx("CONCAL").exists(),ln.concal.isNull() do vreqerr("CONCAL") quit
	}
	if 'vobj(ln,-100,99,"").order().isNull() do {
		if vx("ACN").exists(),ln.acn.isNull() do vreqerr("ACN") quit
		if vx("ACNRELC").exists(),ln.acnrelc.isNull() do vreqerr("ACNRELC") quit
	}
	if 'vobj(ln,-100,101,"").order().isNull() do {
		if vx("DXSI").exists(),ln.dxsi.isNull() do vreqerr("DXSI") quit
		if vx("BMET").exists(),ln.bmet.isNull() do vreqerr("BMET") quit
		if vx("PEBA").exists(),ln.peba.isNull() do vreqerr("PEBA") quit
		if vx("BPOCL").exists(),ln.bpocl.isNull() do vreqerr("BPOCL") quit
		if vx("PTF").exists(),ln.ptf.isNull() do vreqerr("PTF") quit
	}
	if 'vobj(ln,-100,102,"").order().isNull() do {
		if vx("DIRDEF").exists(),ln.dirdef.isNull() do vreqerr("DIRDEF") quit
	}
	if 'vobj(ln,-100,111,"").order().isNull() do {
		if vx("RECCD").exists(),ln.reccd.isNull() do vreqerr("RECCD") quit
		if vx("ASSUMF").exists(),ln.assumf.isNull() do vreqerr("ASSUMF") quit
	}
	if 'vobj(ln,-100,431,"").order().isNull() do {
		if vx("PAYEFT").exists(),ln.payeft.isNull() do vreqerr("PAYEFT") quit
	}
	if 'vobj(ln,-100,432,"").order().isNull() do {
		if vx("COLLQUE").exists(),ln.collque.isNull() do vreqerr("COLLQUE") quit
	}
	if 'vobj(ln,-100,433,"").order().isNull() do {
		if vx("WDLMTP").exists(),ln.wdlmtp.isNull() do vreqerr("WDLMTP") quit
		if vx("CINTBNP").exists(),ln.cintbnp.isNull() do vreqerr("CINTBNP") quit
		if vx("AVCRLMT").exists(),ln.avcrlmt.isNull() do vreqerr("AVCRLMT") quit
		if vx("ICAP").exists(),ln.icap.isNull() do vreqerr("ICAP") quit
	}
	if 'vobj(ln,-100,435,"").order().isNull() do {
		if vx("ADDLCHG").exists(),ln.addlchg.isNull() do vreqerr("ADDLCHG") quit
		if vx("GENPRN").exists(),ln.genprn.isNull() do vreqerr("GENPRN") quit
	}
	if 'vobj(ln,-100,438,"").order().isNull() do {
		if vx("MT900").exists(),ln.mt900.isNull() do vreqerr("MT900") quit
		if vx("MT910").exists(),ln.mt910.isNull() do vreqerr("MT910") quit
	}
	if 'vobj(ln,-100,440,"").order().isNull() do {
		if vx("COF").exists(),ln.cof.isNull() do vreqerr("COF") quit
	}
	if 'vobj(ln,-100,445,"").order().isNull() do {
		if vx("WSPOUSFL").exists(),ln.wspousfl.isNull() do vreqerr("WSPOUSFL") quit
		if vx("REFFLG").exists(),ln.refflg.isNull() do vreqerr("REFFLG") quit
	}
	if 'vobj(ln,-100,447,"").order().isNull() do {
		if vx("PAOI").exists(),ln.paoi.isNull() do vreqerr("PAOI") quit
	}
	if 'vobj(ln,-100,448,"").order().isNull() do {
		if vx("SGNCRD").exists(),ln.sgncrd.isNull() do vreqerr("SGNCRD") quit
		if vx("PSGNCRDR").exists(),ln.psgncrdr.isNull() do vreqerr("PSGNCRDR") quit
		if vx("OSGNCRDC").exists(),ln.osgncrdc.isNull() do vreqerr("OSGNCRDC") quit
		if vx("SGNCRDCHGDT").exists(),ln.sgncrdchgdt.isNull() do vreqerr("SGNCRDCHGDT") quit
	}
	if 'vobj(ln,-100,449,"").order().isNull() do {
		if vx("CBF").exists(),ln.cbf.isNull() do vreqerr("CBF") quit
		if vx("CDF").exists(),ln.cdf.isNull() do vreqerr("CDF") quit
		if vx("IRP").exists(),ln.irp.isNull() do vreqerr("IRP") quit
	}
	if 'vobj(ln,-100,453,"").order().isNull() do {
		if vx("BCAPINT").exists(),ln.bcapint.isNull() do vreqerr("BCAPINT") quit
		if vx("AFFLN").exists(),ln.affln.isNull() do vreqerr("AFFLN") quit
	}
	if 'vobj(ln,-100,461,"").order().isNull() do {
		if vx("GENPRJREP").exists(),ln.genprjrep.isNull() do vreqerr("GENPRJREP") quit
	}
	if 'vobj(ln,-100,465,"").order().isNull() do {
		if vx("ADJCOL").exists(),ln.adjcol.isNull() do vreqerr("ADJCOL") quit
		if vx("COLLIMPR").exists(),ln.collimpr.isNull() do vreqerr("COLLIMPR") quit
		if vx("RACLF").exists(),ln.raclf.isNull() do vreqerr("RACLF") quit
		if vx("RACLC").exists(),ln.raclc.isNull() do vreqerr("RACLC") quit
		if vx("FSOVRDUE").exists(),ln.fsovrdue.isNull() do vreqerr("FSOVRDUE") quit
		if vx("OOC").exists(),ln.ooc.isNull() do vreqerr("OOC") quit
		if vx("SECMTG").exists(),ln.secmtg.isNull() do vreqerr("SECMTG") quit
	}
	if 'vobj(ln,-100,469,"").order().isNull() do {
		if vx("DMNDLN").exists(),ln.dmndln.isNull() do vreqerr("DMNDLN") quit
	}
	if 'vobj(ln,-100,471,"").order().isNull() do {
		if vx("SEGMENTS").exists(),ln.segments.isNull() do vreqerr("SEGMENTS") quit
	}
		if vx("ACN").exists(),ln.acn.isNull() do vreqerr("ACN") quit
		if vx("ACNRELC").exists(),ln.acnrelc.isNull() do vreqerr("ACNRELC") quit
		if vx("ACTIBPAY").exists(),ln.actibpay.isNull() do vreqerr("ACTIBPAY") quit
		if vx("ADDLCHG").exists(),ln.addlchg.isNull() do vreqerr("ADDLCHG") quit
		if vx("ADF").exists(),ln.adf.isNull() do vreqerr("ADF") quit
		if vx("ADJCOL").exists(),ln.adjcol.isNull() do vreqerr("ADJCOL") quit
		if vx("ADJCRLMT").exists(),ln.adjcrlmt.isNull() do vreqerr("ADJCRLMT") quit
		if vx("AFFLN").exists(),ln.affln.isNull() do vreqerr("AFFLN") quit
		if vx("AFLG").exists(),ln.aflg.isNull() do vreqerr("AFLG") quit
		if vx("AIPR").exists(),ln.aipr.isNull() do vreqerr("AIPR") quit
		if vx("AIR").exists(),ln.air.isNull() do vreqerr("AIR") quit
		if vx("ALPRTY").exists(),ln.alprty.isNull() do vreqerr("ALPRTY") quit
		if vx("AMTREQ").exists(),ln.amtreq.isNull() do vreqerr("AMTREQ") quit
		if vx("ANLSYS").exists(),ln.anlsys.isNull() do vreqerr("ANLSYS") quit
		if vx("ARUF").exists(),ln.aruf.isNull() do vreqerr("ARUF") quit
		if vx("ASSUMF").exists(),ln.assumf.isNull() do vreqerr("ASSUMF") quit
		if vx("AUO").exists(),ln.auo.isNull() do vreqerr("AUO") quit
		if vx("AVCRLMT").exists(),ln.avcrlmt.isNull() do vreqerr("AVCRLMT") quit
		if vx("BCAPINT").exists(),ln.bcapint.isNull() do vreqerr("BCAPINT") quit
		if vx("BMET").exists(),ln.bmet.isNull() do vreqerr("BMET") quit
		if vx("BOO").exists(),ln.boo.isNull() do vreqerr("BOO") quit
		if vx("BPOCL").exists(),ln.bpocl.isNull() do vreqerr("BPOCL") quit
		if vx("CBF").exists(),ln.cbf.isNull() do vreqerr("CBF") quit
		if vx("CC").exists(),ln.cc.isNull() do vreqerr("CC") quit
		if vx("CCBIND").exists(),ln.ccbind.isNull() do vreqerr("CCBIND") quit
		if vx("CDF").exists(),ln.cdf.isNull() do vreqerr("CDF") quit
		if vx("CHKEURO").exists(),ln.chkeuro.isNull() do vreqerr("CHKEURO") quit
		if vx("CHKISS").exists(),ln.chkiss.isNull() do vreqerr("CHKISS") quit
		if vx("CINTBNP").exists(),ln.cintbnp.isNull() do vreqerr("CINTBNP") quit
		if vx("CLS").exists(),ln.cls.isNull() do vreqerr("CLS") quit
		if vx("CMSFLG").exists(),ln.cmsflg.isNull() do vreqerr("CMSFLG") quit
		if vx("COF").exists(),ln.cof.isNull() do vreqerr("COF") quit
		if vx("COLLIMPR").exists(),ln.collimpr.isNull() do vreqerr("COLLIMPR") quit
		if vx("COLLQUE").exists(),ln.collque.isNull() do vreqerr("COLLQUE") quit
		if vx("COMM").exists(),ln.comm.isNull() do vreqerr("COMM") quit
		if vx("CONCAL").exists(),ln.concal.isNull() do vreqerr("CONCAL") quit
		if vx("CPF").exists(),ln.cpf.isNull() do vreqerr("CPF") quit
		if vx("CRCD").exists(),ln.crcd.isNull() do vreqerr("CRCD") quit
		if vx("CUSTOM1").exists(),ln.custom1.isNull() do vreqerr("CUSTOM1") quit
		if vx("CUSTOM2").exists(),ln.custom2.isNull() do vreqerr("CUSTOM2") quit
		if vx("CUSTOM3").exists(),ln.custom3.isNull() do vreqerr("CUSTOM3") quit
		if vx("DIP").exists(),ln.dip.isNull() do vreqerr("DIP") quit
		if vx("DIRDEF").exists(),ln.dirdef.isNull() do vreqerr("DIRDEF") quit
		if vx("DLCAF").exists(),ln.dlcaf.isNull() do vreqerr("DLCAF") quit
		if vx("DLRP").exists(),ln.dlrp.isNull() do vreqerr("DLRP") quit
		if vx("DMNDLN").exists(),ln.dmndln.isNull() do vreqerr("DMNDLN") quit
		if vx("DRF").exists(),ln.drf.isNull() do vreqerr("DRF") quit
		if vx("DSCHPR").exists(),ln.dschpr.isNull() do vreqerr("DSCHPR") quit
		if vx("DXSI").exists(),ln.dxsi.isNull() do vreqerr("DXSI") quit
		if vx("EACIP").exists(),ln.eacip.isNull() do vreqerr("EACIP") quit
		if vx("EFTDD").exists(),ln.eftdd.isNull() do vreqerr("EFTDD") quit
		if vx("EFTDEB").exists(),ln.eftdeb.isNull() do vreqerr("EFTDEB") quit
		if vx("EFTREQ").exists(),ln.eftreq.isNull() do vreqerr("EFTREQ") quit
		if vx("EMPLBEN").exists(),ln.emplben.isNull() do vreqerr("EMPLBEN") quit
		if vx("ENTF").exists(),ln.entf.isNull() do vreqerr("ENTF") quit
		if vx("EPA").exists(),ln.epa.isNull() do vreqerr("EPA") quit
		if vx("FLAT").exists(),ln.flat.isNull() do vreqerr("FLAT") quit
		if vx("FPAF").exists(),ln.fpaf.isNull() do vreqerr("FPAF") quit
		if vx("FPIND").exists(),ln.fpind.isNull() do vreqerr("FPIND") quit
		if vx("FSOVRDUE").exists(),ln.fsovrdue.isNull() do vreqerr("FSOVRDUE") quit
		if vx("GENPRJREP").exists(),ln.genprjrep.isNull() do vreqerr("GENPRJREP") quit
		if vx("GENPRN").exists(),ln.genprn.isNull() do vreqerr("GENPRN") quit
		if vx("GLSC").exists(),ln.glsc.isNull() do vreqerr("GLSC") quit
		if vx("GRP").exists(),ln.grp.isNull() do vreqerr("GRP") quit
		if vx("HIGHVOL").exists(),ln.highvol.isNull() do vreqerr("HIGHVOL") quit
		if vx("HIP").exists(),ln.hip.isNull() do vreqerr("HIP") quit
		if vx("ICAP").exists(),ln.icap.isNull() do vreqerr("ICAP") quit
		if vx("ICPA").exists(),ln.icpa.isNull() do vreqerr("ICPA") quit
		if vx("INTCAP").exists(),ln.intcap.isNull() do vreqerr("INTCAP") quit
		if vx("IPD").exists(),ln.ipd.isNull() do vreqerr("IPD") quit
		if vx("IPLCF").exists(),ln.iplcf.isNull() do vreqerr("IPLCF") quit
		if vx("IRCB").exists(),ln.ircb.isNull() do vreqerr("IRCB") quit
		if vx("IRP").exists(),ln.irp.isNull() do vreqerr("IRP") quit
		if vx("LCHGNOTO").exists(),ln.lchgnoto.isNull() do vreqerr("LCHGNOTO") quit
		if vx("LIP").exists(),ln.lip.isNull() do vreqerr("LIP") quit
		if vx("MDF").exists(),ln.mdf.isNull() do vreqerr("MDF") quit
		if vx("MINOPT").exists(),ln.minopt.isNull() do vreqerr("MINOPT") quit
		if vx("MSCP").exists(),ln.mscp.isNull() do vreqerr("MSCP") quit
		if vx("MT900").exists(),ln.mt900.isNull() do vreqerr("MT900") quit
		if vx("MT910").exists(),ln.mt910.isNull() do vreqerr("MT910") quit
		if vx("NAI").exists(),ln.nai.isNull() do vreqerr("NAI") quit
		if vx("NEGACRPO").exists(),ln.negacrpo.isNull() do vreqerr("NEGACRPO") quit
		if vx("OCAF").exists(),ln.ocaf.isNull() do vreqerr("OCAF") quit
		if vx("ODT").exists(),ln.odt.isNull() do vreqerr("ODT") quit
		if vx("OOC").exists(),ln.ooc.isNull() do vreqerr("OOC") quit
		if vx("OSGNCRDC").exists(),ln.osgncrdc.isNull() do vreqerr("OSGNCRDC") quit
		if vx("PAF").exists(),ln.paf.isNull() do vreqerr("PAF") quit
		if vx("PAOI").exists(),ln.paoi.isNull() do vreqerr("PAOI") quit
		if vx("PAP").exists(),ln.pap.isNull() do vreqerr("PAP") quit
		if vx("PAS").exists(),ln.pas.isNull() do vreqerr("PAS") quit
		if vx("PAYEFT").exists(),ln.payeft.isNull() do vreqerr("PAYEFT") quit
		if vx("PBI").exists(),ln.pbi.isNull() do vreqerr("PBI") quit
		if vx("PEBA").exists(),ln.peba.isNull() do vreqerr("PEBA") quit
		if vx("PFLG").exists(),ln.pflg.isNull() do vreqerr("PFLG") quit
		if vx("PHLD").exists(),ln.phld.isNull() do vreqerr("PHLD") quit
		if vx("PIACM").exists(),ln.piacm.isNull() do vreqerr("PIACM") quit
		if vx("PLDF").exists(),ln.pldf.isNull() do vreqerr("PLDF") quit
		if vx("PPFLG").exists(),ln.ppflg.isNull() do vreqerr("PPFLG") quit
		if vx("PSGNCRDR").exists(),ln.psgncrdr.isNull() do vreqerr("PSGNCRDR") quit
		if vx("PTF").exists(),ln.ptf.isNull() do vreqerr("PTF") quit
		if vx("PTSP").exists(),ln.ptsp.isNull() do vreqerr("PTSP") quit
		if vx("RACLC").exists(),ln.raclc.isNull() do vreqerr("RACLC") quit
		if vx("RACLF").exists(),ln.raclf.isNull() do vreqerr("RACLF") quit
		if vx("RCBIND").exists(),ln.rcbind.isNull() do vreqerr("RCBIND") quit
		if vx("RECCD").exists(),ln.reccd.isNull() do vreqerr("RECCD") quit
		if vx("REFFLG").exists(),ln.refflg.isNull() do vreqerr("REFFLG") quit
		if vx("REGCC").exists(),ln.regcc.isNull() do vreqerr("REGCC") quit
		if vx("REVF").exists(),ln.revf.isNull() do vreqerr("REVF") quit
		if vx("RFLG").exists(),ln.rflg.isNull() do vreqerr("RFLG") quit
		if vx("RFMO").exists(),ln.rfmo.isNull() do vreqerr("RFMO") quit
		if vx("RNFLG").exists(),ln.rnflg.isNull() do vreqerr("RNFLG") quit
		if vx("RPIDC").exists(),ln.rpidc.isNull() do vreqerr("RPIDC") quit
		if vx("RPMO").exists(),ln.rpmo.isNull() do vreqerr("RPMO") quit
		if vx("SECMTG").exists(),ln.secmtg.isNull() do vreqerr("SECMTG") quit
		if vx("SEGMENTS").exists(),ln.segments.isNull() do vreqerr("SEGMENTS") quit
		if vx("SGNCRD").exists(),ln.sgncrd.isNull() do vreqerr("SGNCRD") quit
		if vx("SGNCRDCHGDT").exists(),ln.sgncrdchgdt.isNull() do vreqerr("SGNCRDCHGDT") quit
		if vx("SIBF").exists(),ln.sibf.isNull() do vreqerr("SIBF") quit
		if vx("SMET").exists(),ln.smet.isNull() do vreqerr("SMET") quit
		if vx("SRCBIND").exists(),ln.srcbind.isNull() do vreqerr("SRCBIND") quit
		if vx("STAT").exists(),ln.stat.isNull() do vreqerr("STAT") quit
		if vx("SWPEL").exists(),ln.swpel.isNull() do vreqerr("SWPEL") quit
		if vx("TRB").exists(),ln.trb.isNull() do vreqerr("TRB") quit
		if vx("TRUNC").exists(),ln.trunc.isNull() do vreqerr("TRUNC") quit
		if vx("TYPE").exists(),ln.type.isNull() do vreqerr("TYPE") quit
		if vx("WDLMTP").exists(),ln.wdlmtp.isNull() do vreqerr("WDLMTP") quit
		if vx("WOFF").exists(),ln.woff.isNull() do vreqerr("WOFF") quit
		if vx("WSPOUSFL").exists(),ln.wspousfl.isNull() do vreqerr("WSPOUSFL") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("LN","MSG",1767,"LN."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VFKEYS // Foreign keys

	type public String vfkey(),vpar

	type public RecordLN ln
	if 'ln.acn.isNull() set vfkey("^CIF("_""""_ln.acn_""""_","_1_")")="LN(ACN) -> CIF"
	if 'ln.type.isNull() set vfkey("^UTBLDFTL("_""""_ln.type_""""_","_50_")")="LN(TYPE) -> PRODDFTL"
	quit

CHKFKS   // Check foreign keys when not under buffer


	type public RecordLN ln
	type public Number %O
	type String vERRMSG

	if 'Db.isDefined("CIF",":ln.acn") set vERRMSG = $$^MSG(8563,"LN(ACN) -> CIF") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if 'Db.isDefined("PRODDFTL",":ln.type") set vERRMSG = $$^MSG(8563,"LN(TYPE) -> PRODDFTL") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	quit


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vau30 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vau47 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() quit
	if vx("ACN").exists() do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ACNRELC").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ACS").exists() do vau4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIPR").exists()!vx("AUPTCID").exists()!vx("ALPDUE").exists() do vau5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AMBAS").exists()!vx("ONP").exists()!vx("PCM").exists()!vx("RPP").exists() do vau56 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANIRND").exists() do vau7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLD").exists()!vx("ANOFF").exists()!vx("APCND").exists()!vx("EACIP").exists() do vau6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANPTND").exists() do vau8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BALINT").exists()!vx("REVF").exists()!vx("TDR").exists()!vx("UDBAL").exists()!vx("DBT").exists()!vx("CBT").exists() do vau87 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BLDT").exists() do vau10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BMET").exists() do vau11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BNDT").exists()!vx("SCHND").exists() do vau9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BOO").exists() do vau12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BOO").exists()!vx("CC").exists()!vx("CCODE").exists()!vx("MF").exists()!vx("RESCD").exists() do vau35 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBF").exists()!vx("CDF").exists()!vx("IRP").exists() do vau13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBMET").exists() do vau14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBPND").exists() do vau15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CCL").exists()!vx("CPF").exists()!vx("CRLMT").exists() do vau16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CHKEURO").exists()!vx("CHKISS").exists()!vx("CHKCNT").exists() do vau17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNOFF").exists()!vx("CNCAL").exists() do vau20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVDT").exists() do vau19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVSTAT").exists() do vau21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CONVACN").exists() do vau22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRCD").exists()!vx("SDTA").exists() do vau74 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vau23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DICO").exists()!vx("DIRFRE").exists()!vx("DIRND").exists()!vx("DITGACN").exists() do vau24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST1FRE").exists() do vau25 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST1ND").exists() do vau26 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST2FRE").exists()!vx("DIST2ND").exists() do vau27 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST3FRE").exists()!vx("DIST3ND").exists() do vau28 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST4FRE").exists()!vx("DIST4ND").exists() do vau29 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DPA").exists() do vau31 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DPMT").exists() do vau32 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DTC").exists() do vau33 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DXSI").exists()!vx("BCAPINT").exists() do vau34 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FIA").exists() do vau36 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FPA").exists() do vau37 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GLSC").exists() do vau38 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GRP").exists() do vau39 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IAM").exists()!vx("IDP").exists()!vx("IPL").exists()!vx("IUN").exists()!vx("ICPA").exists()!vx("FLAT").exists()!vx("MDT").exists()!vx("TRM").exists()!vx("PCMVAL").exists()!vx("MAXPTRM").exists()!vx("MINPTRM").exists() do vau43 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICAP").exists()!vx("IROPT").exists() do vau40 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICHND").exists()!vx("INDEX").exists()!vx("INTFRE").exists()!vx("INTOFF").exists()!vx("IRN").exists()!vx("INTMAT").exists()!vx("INTSPR").exists()!vx("IRF").exists()!vx("RNDMTD").exists()!vx("MINRATE").exists() do vau42 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IGRC").exists() do vau41 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IRCID").exists()!vx("IRAMTO").exists() do vau44 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("LCAD").exists()!vx("POPT").exists() do vau45 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MAXAGGR").exists() do vau46 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists()!vx("MT900THR").exists() do vau48 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists()!vx("MT910THR").exists() do vau49 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NAI").exists() do vau50 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NBTR").exists()!vx("NTROPT").exists() do vau51 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NUMDTP").exists() do vau52 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ODD").exists()!vx("DTNT").exists()!vx("ODT").exists() do vau53 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PAYLKAMT").exists()!vx("PAYLKFRM").exists()!vx("PAYLKTO").exists() do vau54 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCFRE").exists()!vx("PCHND").exists()!vx("PCOFF").exists() do vau59 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCHM").exists() do vau55 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMRO").exists() do vau57 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMT").exists() do vau58 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTDIST").exists()!vx("PMTDISTF").exists() do vau60 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTMIN").exists() do vau61 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PPDCAT1").exists()!vx("PPDCAT2").exists()!vx("PPDCAT3").exists()!vx("PPDCAT4").exists()!vx("PPDCAT5").exists()!vx("PPDCAT6").exists()!vx("PPDCAT7").exists()!vx("PPDCAT8").exists()!vx("PPDCAT9").exists()!vx("PPDCAT10").exists() do vau62 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PRAMTCID").exists()!vx("PRAMT").exists() do vau63 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PRCNTCID").exists()!vx("PRCNTAP").exists() do vau64 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PTSP").exists() do vau65 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RAFRE").exists() do vau66 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RAND").exists() do vau67 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RDT").exists() do vau68 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RENCD").exists()!vx("TRACN").exists() do vau69 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RND").exists()!vx("ROPT").exists() do vau70 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RNOFF").exists()!vx("RNCAL").exists() do vau73 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RSINTSPR").exists()!vx("RSRNDMTD").exists() do vau71 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RSKOPT").exists() do vau72 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SEGMENTS").exists()!vx("REVF").exists()!vx("DSCHPR").exists()!vx("MDF").exists()!vx("AIR").exists()!vx("ADDLCHG").exists()!vx("ARUF").exists()!vx("ENTF").exists()!vx("ICM").exists()!vx("CLPS").exists()!vx("SLBL").exists() do vau75 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SFRE").exists() do vau76 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SGNCRD").exists()!vx("OSGNCRDC").exists()!vx("PSGNCRDR").exists() do vau77 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SMET").exists() do vau78 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SRCDT").exists() do vau79 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists() do vau80 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STROFF").exists()!vx("STRCAL").exists() do vau81 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SUBPLN").exists()!vx("IDP").exists()!vx("IAM").exists() do vau82 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TEB").exists() do vau84 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TITLE1").exists()!vx("TITLE2").exists()!vx("TITLE3").exists()!vx("TITLE4").exists() do vau85 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TRATE").exists()!vx("TREXD").exists()!vx("PROIND").exists() do vau83 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TYPE").exists() do vau86 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("VATINTOPT").exists()!vx("BILINFLCALIN").exists() do vau88 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WDLMT").exists() do vau89 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WDLMTP").exists()!vx("WDND").exists()!vx("WDFRE").exists()!vx("COLLIMPR").exists()!vx("PBNXTDT").exists()!vx("PBFRE").exists()!vx("ADJCOL").exists() do vau90 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WRKDTE").exists() do vau91 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordLN ln
	if vx("").order().isNull() do AUDIT^UCUTILN(ln,.vx(),10,"|") quit
	if vx("ACS").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ALPRTY").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ALPRTYD").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANOFFDT").exists() do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("APCND").exists()!vx("ANOFF").exists() do vbu5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("APRMTHD").exists() do vbu6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ARUF").exists() do vbu7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BALLAMT").exists() do vbu8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BLOFF").exists() do vbu9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBMET").exists()!vx("CBPND").exists() do vbu18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CLPS").exists() do vbu12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CLS").exists() do vbu13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVDT").exists() do vbu14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVSTAT").exists() do vbu15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("COLCD").exists() do vbu16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("COLLST").exists()!vx("PCOLLST").exists()!vx("COLCDTE").exists() do vbu17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRLMT").exists() do vbu19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vbu20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DFP").exists() do vbu21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DICO").exists() do vbu22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST1FRE").exists() do vbu23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST2FRE").exists() do vbu25 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST2ND").exists() do vbu24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST3FRE").exists()!vx("DIST3ND").exists() do vbu26 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST4FRE").exists()!vx("DIST4ND").exists() do vbu27 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DLCAF").exists() do vbu28 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EMPLBEN").exists()!vx("EMPLNO").exists() do vbu29 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICPA").exists() do vbu30 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICPF").exists()!vx("DIST1AF").exists() do vbu31 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INDEX").exists()!vx("IRN").exists()!vx("EIRN").exists()!vx("IACF").exists()!vx("INTSPR").exists()!vx("RNDMTD").exists()!vx("INTMAT").exists()!vx("INTFRE").exists()!vx("ICHND").exists()!vx("INTOFF").exists()!vx("INTOFFDT").exists()!vx("TRATE").exists()!vx("TREXD").exists() do vbu32 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IPL").exists() do vbu33 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IROPT").exists() do vbu34 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IUN").exists() do vbu35 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MDT").exists()!vx("PCM").exists()!vx("DTNT").exists()!vx("ODD").exists()!vx("TRM").exists()!vx("BUSOPT").exists()!vx("NBDC").exists()!vx("PIACM").exists() do vbu36 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists() do vbu37 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists() do vbu38 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NAI").exists()!vx("NAPLMTDT").exists() do vbu39 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PAP").exists()!vx("PAS").exists() do vbu40 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PAYTOL").exists()!vx("PAYTOLP").exists() do vbu55 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCFRE").exists() do vbu41 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCHND").exists()!vx("PCOFF").exists()!vx("RAND").exists() do vbu42 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCOFFDT").exists() do vbu43 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTDIST").exists() do vbu44 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTGRC").exists() do vbu45 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTPI").exists()!vx("PMTTRS").exists() do vbu46 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PPFREQ").exists() do vbu47 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PROVOAMT").exists()!vx("PROVOPCT").exists()!vx("RACOVR").exists() do vbu48 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RANDOFF").exists() do vbu49 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RENCD").exists()!vx("TRACN").exists() do vbu50 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("REVF").exists()!vx("TDR").exists() do vbu51 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SCHND").exists() do vbu52 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SGNCRD").exists()!vx("PSGNCRDR").exists()!vx("OSGNCRDC").exists() do vbu53 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists() do vbu54 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TITLE1").exists()!vx("TITLE2").exists()!vx("TITLE3").exists()!vx("TITLE4").exists() do vbu10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TYPE").exists() do vbu56 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("UDBAL").exists() do vbu57 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WDLMTP").exists()!vx("COLLIMPR").exists()!vx("PBNXTDT").exists()!vx("PBFRE").exists()!vx("ADJCOL").exists() do vbu58 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(ln,.vx(),10,"|")
	quit


vai1 // Trigger AFTER_INSERT - After insert trigger

	type public RecordLN ln
								/* 
								---- Revision History---------------------------------------------------

	09/18/01 - MYERSK 47550
		   Removed AU_SGNCRD trigger since XSGNCRD is now an Index.
		   Needed to put Revision History somewhere.

	04/03/00 - KELLYP - 37918
		   Moved all code and revision history comments from this 
		   trigger into a new procedure, LNAI, to prevent compilation
		   errors caused by the LN filer being too large.  Changes to
		   the AFTER_INSERT trigger should now be made to the LNAI proc.
								*/

	do PROC^LNAI(.ln)	// All code moved to AFTER_INSERT Procedure
	quit

vau1 // Trigger AU - After Update trigger for all columns

	type public RecordLN ln
								/*
								---- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 	

								07/29/01 - VETSENM - 46279
																			Code for LN.CONVACN has been removed to AU_CONVACN. 

								05/15/01 - VETSENM - 43026
																			Set error message for Non-PROFILE account if Conversion
																			Account (LN.CONVACN) is not defined.

																			Set XBAD message if user attempts to perform file
																			maintenance on a Non-PROFILE account (PRODCTL.NONPA=1) 
								*/

	type public Boolean ER

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")

								// File Maintenance Require Approval
								if prodctl.nonpa=1 do Runtime.setErrXBAD("LN",3005) quit:ER
	
								quit
	

vau2 // Trigger AU_ACN - After Update trigger

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI -14385
		   Modified to comply with DBI standards.
	
	01/22/99 - KONGJ - 28973
		   Added a check to return an XBAD msg if both Revolving Process
		   Flag is set to "Y" and small balance threshold fields contain
		   values.
	*/
	
	type public Boolean ER

	// Debit/Credit Balance cannot be defined for rev accts.
	if ln.revf,(ln.dbt!ln.cbt) do Runtime.setErrXBAD("LN",528) quit:ER 
	
	if 'CUVAR.LIMPRO quit

	do START^LIMUPD(ln.cid,"LOAN",ln.acn,ln.acn.oldVal)

	quit 

vau3 // Trigger AU_ACNRELC - After Update of ACNRELC

	type public RecordLN ln
   	/*
   	---- Revision History ------------------------------------------------
	03/15/06 - Srinivar - 19975
	           New after update trigger created to update the relationship
	           code of the escrow account.
	           
	----------------------------------------------------------------------
     	*/
     		
	type Number ECID 
	
	set ECID=$$ECID^LNU(ln.cid,"ESC1")
	if ECID="" quit
		
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	set dep.acnrelc=ln.acnrelc
	do dep.bypassSave()
		
	quit

vau4 // Trigger AU_ACS - After update accrual processed date

	type public RecordLN ln
	// Accrual Processed Indicator Error
	if ln.acs'=(%SystemDate-1) do Runtime.setErrXBAD("LN","ACS") quit:ER 
	quit
	

vau5 // Trigger AU_AIPR - After Update AIPR, AUPTCID & ALPDUE

	type public RecordLN ln
	/*	
	----Revision History----------------------------------------------------
	
	08/12/99 - ROYTENBERGE/SMITHC - 49809
		   Added code to check: Auto Loan Payment Due Method must be greater
		   than 0 when Auto Loan Payment Account is defined.
	*/


	
	// Auto ln pmt acct requird for int collectd on prin repayments
	if ln.aipr,ln.auptcid="" do Runtime.setErrXBAD("LN",522) quit:ER       
	
	// Auto ln pmt processing requires auto ln pmt acct
	if ln.alpdue,ln.auptcid="" do Runtime.setErrXBAD("LN",523) quit:ER 
	
	/*
	Auto Loan Payment Due Method must be greater than 0 when Auto Loan Payment
	Account is defined
	*/
	if 'ln.alpdue,ln.auptcid'="" do Runtime.setErrMSG("LN",3985) quit:ER 
	quit 

vau6 // Trigger AU_ANALYSIS_INFO - After update analysis information

	type public RecordLN ln
	/*
	Revision History
	------------------------------------------------------------------------
	5/24/02 - JERUCHIMC - 49996
	Define apcld variable if not defined already.	
	*/

	// ESCROW PAYMENT CHANGE Date in the Past
	if ln.apcnd'="",ln.apcnd<%SystemDate do Runtime.setErrXBAD("LN",77) quit:ER 
	if ln.anfre'="" do { quit:ER 
		new apcld
		if ln.apcld="",ln.apcnd set apcld=$$NJD^UFRE(ln.apcnd,"-"_ln.anfre) quit:ER
		if $G(apcld)="" set apcld=ln.apcld
		if $G(ER) do Runtime.setErrXBAD("LN",ET) quit:ER 

		/*	
		Analysis change in process flag not set and there was an analysis
		posting at some time.  We're OK if offset date in future, or if in
		the past and last period preceeds last analysis date (in that case
		in offset period and haven't posted)
		*/

		if 'ln.eacip,ln.anld,ln.anoffdt'>%SystemDate,ln.anld'<apcld do { quit:ER 
			// Analysis In-Proc Flag Not Set, Analysis Posted
			do Runtime.setErrXBAD("LN",509) quit:ER 
			}
	
		if ln.eacip do { quit:ER 
			// OK if offset date in past and next analysis date in the future
			if ln.anoffdt'>%SystemDate,%SystemDate<ln.apcnd quit 
	
			/*
			OK if analysis falls after the last analysis change date and before
			the next offset date -- then we've done off-cycle analysis
			*/
			if ln.anld<ln.anoffdt,ln.anld>apcld quit 

			// Analysis Chng In-Proc Flag Set, Ln Not in Analysis
			do Runtime.setErrXBAD("LN",505) quit:ER 
			}
		}
	quit
	

vau7 // Trigger AU_ANIRND - After update annual rate limit next chg

	type public RecordLN ln
	// NEXT ANNUAL RATE REVIEW DATE in the Past
	if ln.anirnd,ln.anirnd<%SystemDate do Runtime.setErrXBAD("LN",80) quit:ER 
	quit
	

vau8 // Trigger AU_ANPTND - After update annual pmt lmt nxt chg date

	type public RecordLN ln
	// NEXT ANNUAL PMT REVIEW DATE in the Past
	if ln.anptnd'="",ln.anptnd<%SystemDate do Runtime.setErrXBAD("LN",81) quit:ER 
	quit
	

vau9 // Trigger AU_BILL_SCH_INFO - AU bill & sch next dates & dist 1 AF

	type public RecordLN ln
	// Next bill date precedes system processing date
	if (ln.bndt.oldVal'=ln.bndt),ln.bndt'="",ln.bndt<%SystemDate do Runtime.setErrXBAD("LN",14,"BNDT",ln.bndt) quit:ER 
	
	if (ln.schnd.oldVal'=ln.schnd),ln.schnd'="" do { quit:ER 
		// Next scheduled payment date is invalid
		if ln.schnd<%SystemDate do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd) quit:ER 

		// Check that SCHND is correct relative to DIST1FRE
		if ln.schnd'="",ln.dist1fre'="" do { quit:ER 
			new bndt,cdpd,njd,pdd,XCID,XDATE
			if ln.dist1fre="*" do { quit:$G(pdd)=""!ER 
				new XCID
				set XCID=ln.cid
				new rs 
				type ResultSet rs=Db.select("PDD","LNPS1","CID=:XCID","PDD DESC") 
				if rs.isEmpty() quit
				set pdd=rs.next(),pdd=rs.getCol(1)
				}
	
			// Get date from first bill with due date in future
			set XCID=ln.cid 
			set XDATE=%SystemDate
			new rs 
			type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:XCID AND CDPD>:XDATE","SCHSEQ") 
			if rs.isEmpty() quit
			set cdpd=rs.next(),cdpd=rs.getCol(1)

			// Next scheduled payment date is invalid
			if $G(cdpd),$G(cdpd)'=ln.schnd do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd,cdpd) quit:ER 

			// Error if date does not correspond to frequency
			// Bump one
			set x=$$NJD^UFRE(ln.schnd,ln.dist1fre) quit:ER     
			// Then reverse
			set x=$$NJD^UFRE(x,"-"_ln.dist1fre) quit:ER
			if ln.schnd'=x do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd,x) quit:ER 
	
			// Check BNDT based on SCHND
			if ln.bloff="1P" set bndt=$S(ln.schld<%SystemDate:ln.schnd,1:ln.schld)
			else  do {
				new xfre
				set njd=ln.schnd 
				set xfre=ln.dist1fre
				for  set bndt=njd-ln.bloff quit:bndt'<%SystemDate  set njd=$$NJD^UFRE(njd,xfre) quit:$G(ER) 
				}
			// Check next bill date for possible errors
			if ln.bndt'=bndt!$G(ER) do Runtime.setErrXBAD("LN",46,"BNDT",ln.bndt,bndt) quit:ER 
			}
		}
	quit

vau10 // Trigger AU_BLDT - After update bill last date

	type public RecordLN ln
	if ln.bldt'="" do { quit:ER 
		new cbcd,lnbil1dt,XCID
		// Get last bill date from bill file to validate
		set XCID=ln.cid
		new rs 
		type ResultSet rs=Db.select("CBCD","LNBIL1","CID=:XCID","SCHSEQ DESC") 
		if rs.isEmpty() quit
		set cbcd=rs.next(),cbcd=rs.getCol(1)

		// Last bill sequence inconsistent with internal bill
		if $G(cbcd)'="",cbcd<ln.bldt do Runtime.setErrXBAD("LN",2,"BLDT",ln.bldt,cbcd) quit:ER 
		}
	quit
	

vau11 // Trigger AU_BMET - After Update Bill Print Flag Trigger

	type public RecordLN ln
	// Bill Print flag may only be enabled on master commitment when ln.cbf=1
	if (ln.cbf),(ln.ccl'=""),(ln.bmet) do Runtime.setErrMSG("LN","4323") quit:ER
	quit

vau12 // Trigger AU_BOO - After Update - Branch of Ownership

	type public RecordLN ln
	
	/*
	   ---------- Revision History ------------------------------------------
	   
	   07/05/07 - VanithaK - CR28007
	              Modified the changes made for CR 27879 to include a test
		      case when Region code starts with zero.
		      
	   06/28/07 - VanithaK - CR27879
	   	      Added validation for Branch of Ownership when bankid is 
	   	      defined.
	*/

	// Region Code must be three numbers
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")	
	if prodctl.iftanpro = "IFTAN" do { quit:ER
		
		type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD","BRCD=:ln.boo",1)
		type Number I
		type String CH, REGION
		
		if utblbrcd.region.length()'=3 do Runtime.setErrMSG("UTBLBRCD",6198) quit
		
		set REGION=""
		
		for I=1:1:utblbrcd.region.length() do { quit:ER
			set CH = utblbrcd.region.extract(I)
			if CH'="0" set REGION=REGION_CH
		}
		
		if 'REGION.isNumber() do Runtime.setErrMSG("UTBLBRCD",6198) quit
	}
	
	quit

vau13 // Trigger AU_CBF_CDF_IRP - After Update Builder Loan Flags

	type public RecordLN ln
	/*
								---- Revision History---------------------------------------------------
							 
								05/31/07 - KUMARB - CR 27163
		Modified to check for errors related to Credit Card processing
		if Segments Allowed (LN.SEGMENTS) is selected.
							 
								08/02/05 - KUMARB - CR16684
		Modified the table name LNLCOM to LN in Db.select
	*/

	/*
			This trigger performs several edit checks for the new Builder Loan flags
			introduced to the system by ARQ 35505.  The rules are as follows:

	- LN.CBF must be the same on a commitment and on all of the accounts
	  tied to the commitment (must be enabled or disabled on all).

	- LN.CDF must be the same on a commitment and on all of the accounts
	  tied to the commitment (must be enabled or disabled on all).

	- LN.IRP may not be enabled if LN.CBF is disabled.

	- If LN.IRP is enabled on the commitment, it must also be enabled on
	  all of the accounts tied to the commitment.

	*/
	
 	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do { quit:ER
			
			// Commitment Billing not allowed for segmented accounts
			if ln.cbf do Runtime.setErrMSG("LN",6208) quit:ER
			
			// Commitment Delinquency not allowed for segmented accounts
			if ln.cdf do Runtime.setErrMSG("LN",6209) quit:ER
			
			// Interest Reserve Processing not allowed for segmented accounts
			if ln.irp do Runtime.setErrMSG("LN",6210) quit:ER
			}
	#ENDIF

	// Cannot enable Interest Reserve Processing if Commitment Billing is disabled
	if (ln.irp),('ln.cbf) do Runtime.setErrMSG("LN","4281") quit:ER
	
	if ('ln.cpf),(ln.ccl) do { quit:ER   // Edit checks for an acct tied to a commitment
	
								set XCCL=ln.ccl         // Account's linked commitmemt
								set DATA=Db.getOneRow("CBF,CDF,IRP","LN","XCCL")
	
								// Commitment Billing Flag must equal linked commitment
								if ln.cbf'=$P(DATA,$C(9),1) do Runtime.setErrMSG("LN","4284") quit:ER
	
								// Commitment Delinquency Flag must equal linked commitment
								if ln.cdf'=$P(DATA,$C(9),2) do Runtime.setErrMSG("LN","4286") quit:ER
	
								// Interest Reserve Processing flag must be enabled on this account
								if ($P(DATA,$C(9),3)),('ln.irp) do Runtime.setErrMSG("LN","4305") quit:ER
	
								if 1    // Preserves $T
								}
	
	else  if ln.cpf do { quit:ER           // Edit checks for a commitment
								new ACCTS,rs,XCID
 	
	set XCID=ln.cid
	type ResultSet rs=Db.select("CID","LN","CCL=:XCID")
	if rs.isEmpty() quit

	while rs.next() do { quit:ER	    // Test each loan under commitment
		new DATA,SUBCID

		set SUBCID=rs.getCol(1)
		if 'Db.isDefined("LN","SUBCID") quit

		set DATA=Db.getOneRow("CBF,CDF","LN","SUBCID")

		// Commitment Billing flag must equal linked commitment
		if $P(DATA,$C(9),1)'=ln.cbf do Runtime.setErrMSG("LN","4284") quit:ER				

		// Commitment Delinquency flag must equal linked commitment
		if $P(DATA,$C(9),2)'=ln.cdf do Runtime.setErrMSG("LN","4286") quit:ER
		}
	} 
	quit

vau14 // Trigger AU_CBMET - After update of coupon info

	type public RecordLN ln
	/*
	------------------------------- Revision History -------------------
	10/09/01 - SIVCHUKA - 47644
		Created.
		This trigger will check and update value of LN.CBMET. 
		Section SETCPNS is moved from BU_COUPON_INFO trigger.
		The purpouse of this trigger is to update LN.CBMET before
		check on value of this data item will be performed 
		in LNCPN BEFORE_INSERT trigger.
		This will fix the problem when error msg was coming from ln
		account when payment method was switched from automated
		loan payment to coupon production.
	*/
	
	if 'ln.cbmet.oldVal,ln.cbmet do SETCPNS(.ln)
	if ln.cbmet.oldVal,ln.cbmet do SETCPNS(.ln)
	quit

SETCPNS(RecordLN ln) // Set up coupon information and dayend file for coupon production
	
	new numcpns,PMET
	if ln.cbmet=2,(ln.apcnd=""),(ln.pchnd="") set ln.cbmet.journal=0,ln.cbmet=1
	if ln.cbmet=1 set numcpns=$$CBMET1^LNFUNCS(ln.onp,ln.cntcr)
	if ln.cbmet=2 set numcpns=$$CBMET2^LNFUNCS("",ln.cboff,ln.apcnd,ln.anfre,ln.pchnd,ln.pcfre,ln.icm,ln.dist1nd,ln.dist1fre)
	if ln.cbmet=3 set numcpns=$$CBMET3^LNFUNCS("",ln.cboff,ln.cbfre,ln.dist1nd,ln.dist1fre)
	if ER do Runtime.setErrMSG("LN",3333,$G(RM)) quit
	set ln.cbond.journal=0,ln.cbond=ln.cbpnd
	 
	//Insert dayend entry for next date
	new XTJD,XPMET,XNCP,XPMT,XDIST
	set PMET=3 if ln.odt<ln.cbpnd set PMET=4
	set XTJD=%SystemDate
	set XPMET=PMET
	set XNCP=numcpns
	set XPMT=ln.pmt
	set XCID=ln.cid
	set XDIST=ln.dist1nd
	do Db.insert("LNCPN","PND,PMET,CID,NCP,NCN,NDD,TPT",":XTJD,:XPMET,:XCID,:XNCP,1,:XDIST,:XPMT")
	quit

vau15 // Trigger AU_CBPND - After update coupon book prod next date

	type public RecordLN ln
	// NEXT COUPON PRODUCTION DATE in the Past
	if ln.cbmet=3,ln.cbpnd'="",ln.cbpnd<%SystemDate do Runtime.setErrXBAD("LN",82,"CBPND",ln.cbpnd) quit:ER 
	quit
	

vau16 // Trigger AU_CCL_CPF_CRLMT - AU credit limit, comm link, comm flag

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	08/29/05 - KELLYP - CR 16684
		   Modified block of code that calls TTX^LNCL1 to post 
		   undisbursed funds transfers to pass the correct LN record.
		   Previously, this section was always passing the ln object 
		   that this trigger was being executed for, instead of the
		   loan's commitment.
	
	07/19/05 - RussellDS - CR 16614
		   Remove references to vpar("SYSTEM" and replace with variable
		   isSysChg based on system changes to columns that call this
		   trigger.
		   
		   Some PSL clean up.
		   
		   Removed old revision history.

	06/01/04 - KELLYP - CR 9670
		   Modified Db.delete call to use semicolons properly.  Also
		   removed pre-2001 history.
	*/
	
	type public Boolean ER

	type Boolean aruf, isSysChg
	type Number tamt
	          
	set aruf=""
	
	if (ln.ccl.oldVal'=ln.ccl)!(ln.cpf.oldVal'=ln.cpf) do { quit:ER 
		// See if link is valid
		if (ln.ccl.oldVal'=ln.ccl),ln.ccl'="" do { quit:ER
			
			type Boolean cpf, revf
			type Number avlbal, i, stat, XCCL
			type String crcd, data, PARAM

			set XCCL=ln.ccl

			// Cannot link account to itself
			if XCCL=ln.cid do Runtime.setErrMSG("LN",461) quit:ER 

			// Loan Linked to Invalid Commitment
			if 'Db.isDefined("LN","XCCL") do Runtime.setErrXBAD("LN",163,"CCL",XCCL) quit:ER 
		
			if ln.cpf do { quit:ER
				
				type Number XCCL

				set XCCL=ln.ccl
				type RecordLN ln1=Db.getRecord("LN","CID=:XCCL")
	
				// Commitment Billing Flag must equal linked commitment
				if ln1.cbf'=ln.cbf do Runtime.setErrMSG("LN","4284") quit:ER

				// Commitment Delinquency Flag must equal linked commitment
				if ln1.cdf'=ln.cdf do Runtime.setErrMSG("LN","4286") quit:ER
	
				// Loan Payment Frequency must equal linked commitment
				if ln1.dist1fre'=ln.dist1fre do Runtime.setErrMSG("LN","4285") quit:ER

				// Interest Reserve Processing flag must be enabled on this account
				if (ln1.irp=1),(ln.irp="") do Runtime.setErrMSG("LN","4305") quit:ER
			}

			type ResultSet rs=Db.select("AVLBAL,CPF,CRCD,REVF,STAT,ARUF","LN","CID=:XCCL") 
			quit:rs.isEmpty()
			
			set data=rs.next()
			set avlbal=rs.getCol(1)
			set cpf=rs.getCol(2)
			set crcd=rs.getCol(3)
			set revf=rs.getCol(4)
			set stat=rs.getCol(5)
			set aruf=rs.getCol(6)

			// Account ~p1 is not coded for commitment processing
			if 'cpf do Runtime.setErrMSG("LN",118,XCCL) quit:ER 
	
			// To prevent commitment with interest rate
																								if ln.cpf=1,ln.irn>0 do Runtime.setErrXBAD("LN",3004) quit:ER ;sivchuka 7/19/00

			// Loan Linked to Closed Commitment
			if stat=4 do Runtime.setErrXBAD("LN",164,"CCL",XCCL) quit:ER 

			// Credit limit for ~p1 exceeds undisbursed balance for ~p2
			set PARAM=ln.cid_"~"_XCCL          
			if ln.trb,ln.crlmt>avlbal do Runtime.setErrMSG("LN",650,PARAM) quit:ER    

			// Revolving commitments may not spawn sub-commitments
			if ln.cpf,revf do Runtime.setErrMSG("LN",2423) quit:ER 

			// Must use account of the same currency (~p1)
			if ln.crcd'=crcd do Runtime.setErrMSG("LN",6052,ln.crcd) quit:ER 
	
			// Make sure no more than five levels of commitments
			// First Level
			set XCCL=ln.ccl
			for i=1:1 quit:i>4!(XCCL="")  do { quit:ER!XCCL
				type RecordLN lnxccl=Db.getRecord("LN","CID=:XCCL")	
				set XCCL=lnxccl.ccl
			}
			// Commitment heirarchy five levels or less
			if i>4 do Runtime.setErrSTBLER("LN","CCL5") quit:ER 
		}
	
		// Maintain Master Commitments
		// Delete Old entries
		if ln.ccl.oldVal="",ln.cpf.oldVal do { 
			type Number ACN, XCCID
			
			set XCCID=ln.cid
			
			type ResultSet rs=Db.select("ACN","RELCIF","CID=:XCCID") quit:ER 
			while rs.next() do {
				set ACN=rs.getCol(1)
				do Db.delete("LNMCOM1","ACN=:ACN AND CID=:XCCID")
			}
	
		}
		// Add new entries
		if ln.ccl="",ln.cpf do {
			type Number ACN, XCCID
			
			set XCCID=ln.cid
	
			type ResultSet rs=Db.select("ACN","RELCIF","CID=:XCCID") quit:ER 
			while rs.next() set ACN=rs.getCol(1) do Db.insert("LNMCOM1","ACN,CID",":ACN,:XCCID")
	
		}
	}
	
	if (ln.crlmt.oldVal'=ln.crlmt) do { quit:ER 
		// Credit Limit Less Than Minimum
		if ln.crlmt<ln.mincl do Runtime.setErrXBAD("LN",143,"CRLMT",ln.mincl) quit:ER 

		// Credit Limit Greater Than Maximum
		if (ln.maxbal&(ln.amtreq>ln.maxbal)) do Runtime.setErrXBAD("LN",144,"CRLMT",ln.maxbal) quit:ER 
	
		// Maximum Aggregate Draw Amt can't be less than the loan amt
		if (ln.maxaggr'=""),(ln.maxaggr<ln.crlmt) do Runtime.setErrMSG("LN","4279") quit:ER

		if ln.ccl="" set aruf=ln.aruf       
		else  do {
			set XCCL=ln.ccl
			type RecordLN ln2=Db.getRecord("LN","CID=:XCCL")
			set aruf=ln2.aruf
		}
		// Validate credit limit change if commitment link
		if 'ln.aruf,ln.ccl'="" do { quit:ER 
			type Number tamt
			
			set tamt=ln.crlmt-ln.crlmt.oldVal
			if tamt'>0 quit 

			// Change to credit limit exceeds commitment available balance
			if tamt>ln.avlbal do Runtime.setErrMSG("LN",514) quit:ER 
		}

		// Process On Line Limit Check if Credit Limit Increases
		if (ln.crlmt>ln.crlmt.oldVal),(CUVAR.LIMPRO=1) do INIT^PROCLIM
	
		// Update Country, Industry and Soverign Risk Limits
		if CUVAR.LIMPRO do {
			
			type Number AMT, TOTCOM, TOTEXPI, TOTEXPS
			type String DATA, GRP, TMP
			
			if ln.grp="CBL" quit
			// BALCMP
			set AMT=ln.balcmp
			set CRCD=ln.crcd
			set TOTCOM=ln.crlmt.oldVal if AMT>ln.crlmt.oldVal set TOTCOM=AMT
			if ln.crlmt'>TOTCOM,ln.crlmt>ln.crlmt.oldVal quit 
			if ln.crlmt.oldVal'>AMT,ln.crlmt<ln.crlmt.oldVal quit
			
			type Number ACN, ADJ, TOTEXPC
			type String ACNDATA, CNTRY, GOVT, NEW, OLD, SIC, X
			
			set NEW=ln.crlmt set OLD=ln.crlmt.oldVal
			if CRCD'=%SystemCurrency do {
				set NEW=$$CONV^CRCDUTL(NEW,CRCD,%SystemCurrency,1)
				set OLD=$$CONV^CRCDUTL(OLD,CRCD,%SystemCurrency,1)
				set TOTCOM=$$CONV^CRCDUTL(TOTCOM,CRCD,%SystemCurrency,1)
				set AMT=$$CONV^CRCDUTL(AMT,CRCD,%SystemCurrency,1)
			}
			set ACN=ln.acn
			type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")
			set CNTRY=cif.pcntry
			set GOVT=cif.govt
			set SIC=cif.sic
			if 'Db.isDefined("UTBLCNTRYLIM","CNTRY") do Runtime.setErrMSG("LN",3560,CNTRY) quit:ER 
			type RecordEXPCNTRY expcnt=Db.getRecord("EXPCNTRY","CNTRY=:CNTRY")
			set TOTEXPC=expcnt.totcomexp
			if $E($G(SIC)) do {
				type RecordEXPIND expind=Db.getRecord("EXPIND","IND=:SIC")
				set TOTEXPI=expind.totcomexp
			}
			if $G(GOVT) do {
				type RecordEXPCNSOV expcns=Db.getRecord("EXPCNSOV","CNTRY=CNTRY")
				set TOTEXPS=expcns.totcomexp
			}
			if OLD'<TOTCOM do {
				if NEW>AMT set ADJ=NEW-OLD
				else  set ADJ=AMT-OLD
			}
			else  set ADJ=NEW-TOTCOM
			set TOTEXPC=$$^SCARND(TOTEXPC+ADJ,0,"",%SystemCurrency)     
			do Db.update("EXPCNTRY","TOTCOMEXP=:TOTEXPC","CNTRY=:CNTRY")
			if $G(TOTEXPI) set TOTEXPI=TOTEXPI+ADJ do Db.update("EXPIND","TOTCOMEXP=:TOTEXPI","IND=:SIC")
			if $G(TOTEXPS) set TOTEXPS=TOTEXPS+ADJ do Db.update("EXPCNSOV","TOTCOMEXP=:TOTEXPC","CNTRY=:CNTRY")
		}
	}
	
	// Do transaction(s) to handle changes to commitment link or credit limit
	set (tamt(1),tamt(2),tamt(3))=0
	if (ln.crlmt.oldVal'=ln.crlmt),'(ln.ccl.oldVal'=ln.ccl),ln.ccl'="" set tamt(1)=ln.crlmt.oldVal-ln.crlmt

	if ln.isChanged("CCL", "SYSTEM") set isSysChg = 1
	else  if ln.isChanged("CPF", "SYSTEM") set isSysChg = 1
	else  if ln.isChanged("CRLMT", "SYSTEM") set isSysChg = 1
	else  set isSysChg = 0

	if ln.refflg=1, isSysChg set tamt(1)=ln.crlmt	// ARQ 39399

	if (ln.ccl.oldVal'=ln.ccl) do {
		// Delete link
		if ln.ccl="" set tamt(1)=ln.crlmt.oldVal      
		// Add link
		else  if ln.ccl.oldVal="" set tamt(1)=-ln.crlmt
		// Change link
		else  set tamt(1)=-ln.crlmt set tamt(2)=ln.crlmt.oldVal  
	}
	
	if (ln.crlmt.oldVal'=ln.crlmt),'(ln.ccl.oldVal'=ln.ccl),ln.ccl="" set tamt(1)=ln.crlmt-ln.crlmt.oldVal
	;
	if ln.refflg=1, isSysChg set tamt(1)=ln.crlmt	

	if (ln.crlmt.oldVal'=ln.crlmt),ln.ccl'="",ln.aruf set tamt(3)=ln.crlmt-ln.crlmt.oldVal
	;
	if ln.refflg=1, isSysChg set tamt(1)=ln.crlmt

	// Post transaction(s)
	if aruf!(ln.ccl.oldVal'=ln.ccl) for I=1,2,3 if tamt(I) do { 
		type Number LINKCID, TAMT, XCID
		
		set XCID=CID                          
		set TAMT=tamt(I)
		if I=1 set LINKCID=ln.ccl
		else  set LINKCID=ln.ccl.oldVal
		if LINKCID="" set LINKCID=ln.ccl.oldVal
		if LINKCID="" set LINKCID=CID   
		
		// "~p1 limit modified."
		if (ln.crlmt.oldVal'=ln.crlmt) set TCMT=$$^MSG(4101,XCID)
		
		// Protect from ^LNCL1
		type Number CID
		if I=3 set CID=XCID                 
		else  set CID=LINKCID
		
		// Get the correct corresponding LN record to pass to LNCL1
		type RecordLN lntmp=Db.getRecord("LN","CID=:CID")
		
		do TTX^LNCL1(.lntmp)
		}
	
	// Loan Withdrawal Limit must be changed manually 
	if (ln.crlmt.oldVal'=ln.crlmt),ln.wdlmtp=1 do Runtime.setErrXBAD("LN",527) quit:ER 
	
	quit

vau17 // Trigger AU_CHECK - After Update Checkbook Processing Trigge

	type public RecordLN ln
	/*
	-----Revision History---------------------------------------------------
	12/27/00 - RAJARAMD - 42288
		   Created this trigger. Added code to insert a new record into
		   the Checkbook Production table (CHKPRD) during loan account
		   maintenance if the LN.CHKEURO and LN.CHKISS options are 
		   enabled, and if the LN.CHKCNT is greater than zero.
	*/

	if %ProcessMode=2,ln.chkeuro=1,ln.chkiss=1,ln.chkcnt>0 do { quit:ER
		new XBOO,XCID,XCHKS,XCHKCNT,XACN,XTJD,XUID
		set XBOO=ln.boo
		set XCID=ln.cid
		set XCHKS=ln.chks
		set XCHKCNT=ln.chkcnt
		set XACN=ln.acn
		set XTJD=%SystemDate
		set XUID=%UserID
		do Db.insert("CHKPRD","BRCD,TJD,CID,CHKS,SEQ,CHKCNT,UID,STAT,ACN",":XBOO,:XTJD,:XCID,:XCHKS,1,:XCHKCNT,:XUID,0,:XACN")
		}
	quit	

vau18 // Trigger AU_CID - After Cid change

	type public RecordLN ln
	/*
								---- Revision History ------------------------------------------------
 	
	03/30/05 - KinI - 14385
		   Cleaned up to comply with DBI standards. 
	*/

	if ln.lcad="" quit 

	type Number NEWCID,XCID
	type Date DATA,XTJD

	set NEWCID=ln.cid
	set XCID=ln.cid.oldVal
	set XTJD=%SystemDate-5

	type ResultSet rs=Db.select("TJD","DAYENDLCHG","CID=:XCID AND TJD>:XTJD")
	if rs.isEmpty() quit
	while rs.next() do { 
		set DATA=rs.getCol(1)
	
		type RecordDAYENDLCHG dayendlchg=Db.getRecord("DAYENDLCHG","CID=:XCID,TJD=:DATA")
		set dayendlchg.cid=NEWCID
		do dayendlchg.bypassSave()
		}
	quit

vau19 // Trigger AU_CNVDT - After Update Conversion Date

	type public RecordLN ln
	/* ------------- Revision History -------------------------------------

	03/30/05 - KinI - 14385
		   Cleaned up to comply with DBI standards.
		   Retrofitted CR4000 fix from P01: 
		   Removed Conversion Notification date (LN.CNDT) check for
																			business date since Conversion Notification Date will always
																			be a business date when a calendar is set.  
																			Moved Strike update code to Before Update Conversion Date
																			(BU_CNVDT) trigger.

	04/09/01 - APPLEYARDM - 44274
		   Roll forward ARQ 40572: Added check for conversion
		   notification date if is is a NBD and ln.cfreq is not coded
		   for actual date.
	 ----------------------------------------------------------------------
	*/

	if ln.cnvdt="" quit

	type public Boolean ER	

	// Conversion date must be a business date
	if '$$BD^UNBD(ln.cnvdt,ln.cncal) do Runtime.setErrXBAD("LN","CDTBUS") quit:ER

	// Conversion date requires conversion notification offset
	if ln.cnoff="" do Runtime.setErrXBAD("LN","CDROFF") quit:ER

	// Conversion date must be after the system date
	if ln.cnvdt'>%SystemDate do Runtime.setErrXBAD("LN","CDTASD") quit:ER

	// Conversion Notification Date must be after system date
	if ln.cndt'>%SystemDate do Runtime.setErrXBAD("LN","CNTASD") quit:ER      
	
	quit

vau20 // Trigger AU_CNVINFO - After Update Conversion Date Info

	type public RecordLN ln
	//Conversion date requires conversion notification offset
	if ln.cnvdt'="",ln.cnoff="" do Runtime.setErrMSG("LN",3183) quit
	quit

vau21 // Trigger AU_CNVSTAT - After Update Manual Conversion Status

	type public RecordLN ln
	/*
	This trigger sets the loan for conversion. It is invoked when the loan
	status changes to 1. The process involves setting XCNVMAN entry with the
	history cutoff sequence.
	*/

	if %O=0 quit

	if ln.cnvstat=1 do {
	 	new XTSEQ,XCID
	 	set XCID=ln.cid
	 	set XTSEQ=Db.nextVal("HIST","CID=:XCID")
	 	do Db.insert("XCNVMAN","TSEQ,CID",":XTSEQ,:XCID")
	}
	quit

vau22 // Trigger AU_CONVACN - After Update trigger for CONVACN column.

	type public RecordLN ln
								/*
								---- Revision History ------------------------------------------------

	03/30/05 - KinI - 14385
																			Cleaned up to comply with DBI standards.
	 
								07/29/01 - VETSENM - 46279
																			Set error message for Non-PROFILE account if Conversion
																			Account (LN.CONVACN) is not defined.
								*/ 

	type public Boolean ER
	
	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")

	// Conversion Account Required for Non-PROFILE Institution Account.
	if (prodctl.nonpa=1) , (ln.convacn="") do Runtime.setErrMSG("LN",4896) quit:ER
	quit

vau23 // Trigger AU_DARCOVR - After Update Delinquency Override

	type public RecordLN ln
	/*
	----Revision History---------------------------------------------------

 	08/10/05 - TITOVE - CR 16844
		   Cleaned up as part of DBI3 project. 
	
	*/

	// Asset Class Override has to have a valid value
	if 'ln.darcovr quit

	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE = :ln.type")
	
	// Delinquency reclassification processing not valid for product type ~p1
	if 'prodctl.darcpo do Runtime.setErrMSG("LN",1292,ln.type) quit
	
	// Verify the value exist in UTBLACC: "Invalid table value ~p1"
	if 'Db.isDefined("UTBLACC","ln.cls,ln.darcovr") do Runtime.setErrMSG("LN",1485,"UTBLACC.AC") quit 

	quit

vau24 // Trigger AU_DEF_INT_INFO - After update deferred interest info

	type public RecordLN ln
	/*
		revision history
	1/21/03- sPIER - CR 7985
		Corrected error with Recorddayendgegam in db.delete code
		which caused a compile error.
		
	1/7/03 - Spier - cr7501
		Modified to build DAYENDNEGAM table and delete it as well when dirnd is changed
		
	*/
	if ln.dico'="" do { quit:ER 
		if ln.ditgacn'="" do { quit:ER 
			new data,XCID
			set XCID=ln.cid
			set data=Db.getOneRow("CLS,STAT","LN","XCID") quit:ER 

			// Capitalization Target Account Not Found
			if $P($G(data),$C(9),1)'="L" do Runtime.setErrXBAD("LN",145) quit:ER 

			// Deferred Interest Target Account Closed
			if $P($G(data),$C(9),2)=4 do Runtime.setErrXBAD("LN",146) quit:ER 
			}
		// Deferred Int Resolution Frequency Missing
		if ln.dico="FR",ln.dirfre="" do Runtime.setErrXBAD("LN",147) quit:ER 

		// Deferred Int Not Billed or Capitalized
		if ln.dico="BL",ln.dirnd<ln.bldt do Runtime.setErrXBAD("LN",148) quit:ER 

		// Def Int Next Resolution Date Not Found
		if ln.dico="FR"!(ln.dico="BL"),ln.dirnd="" do Runtime.setErrXBAD("LN",151) quit:ER 

		// Def Int Next Res Date Precedes System Date
		if ln.dirnd'="",ln.dirnd'>%SystemDate do Runtime.setErrXBAD("LN",150) quit:ER 
		}
	if ln.isChanged("DIRND") do {
		type Date old
		set old=ln.dirnd.oldVal
		if old,Db.isDefined("DAYENDNEGAM","TJD=:old,CID=:CID") do Db.delete("DAYENDNEGAM","TJD=:old and CID=:CID")
		if ln.iropt=1!(ln.iropt=2) do {
					
			type RecordDAYENDNEGAM negam=Class.new("RecordDAYENDNEGAM","TJD=:ln.dirnd,CID=:CID")
			do negam.bypassSave()
		}
	}
	quit

vau25 // Trigger AU_DIST1FRE - After update master distribution freq

	type public RecordLN ln

								/*
								---- Revision History ------------------------------------------------
	
								04/05/00 - KELLYP - 35505
																			Added check to ensure that, if the Commitment Billing flag
		   (LN.CBF) is enabled on an account linked to a commitment, 
		   then LN.DIST1FRE must be the same on the account as it is 
		   on the commitment.

	*/


	// Distribution 1 frequency cannot be changed from a *
	if ln.dist1fre.oldVal="*" do Runtime.setErrMSG("LN",1784) quit:ER 

	// Payment elements may not be linked to master frequency of *
	if ln.dist1fre="*",("-"_ln.pmtdistf_"-")["-1-" do Runtime.setErrMSG("LN",1783) quit:ER 

								if (ln.ccl'=""),(ln.cbf) do { quit:ER    // PK - 35505
		new XCCL,XDIST

																set XCCL=ln.ccl
																set XDIST=Db.getOneRow("DIST1FRE","LN","XCCL")
	
																// Loan's payment frequency must equal linked commitment's
																if XDIST'=ln.dist1fre do Runtime.setErrMSG("LN","4285") quit:ER
																}

	
	// Unique considerations if change from regular frequency to payment schedule
	if ln.dist1fre="*" do { quit 

 		new I,XCID,columns,d2f,d3f,d4f,data,dist,element1,element2,fpc,seq
		new sqlcnt,update,values,ZVAL
	
		set XCID=ln.cid
	
		// Load all PEnnEA (Acronyms) and PEnnPF (Distributions) from LNBIL0 table
	
		new v set v="" 
		set v=v_"PE01EA,PE01PF,PE02EA,PE02PF,PE03EA,PE03PF,PE04EA,PE04PF,PE05" 
		set v=v_"EA,PE05PF,PE06EA,PE06PF,PE07EA,PE07PF,PE08EA,PE08PF,PE09EA,P" 
		set v=v_"E09PF,PE10EA,PE10PF,PE11EA,PE11PF,PE12EA,PE12PF,PE13EA,PE13P" 
		set v=v_"F,PE14EA,PE14PF,PE15EA,PE15PF,PE16EA,PE16PF,PE17EA,PE17PF,PE" 
		set v=v_"18EA,PE18PF,PE19EA,PE19PF,PE20EA,PE20PF" 
		set data=Db.getOneRow(v,"LNBIL0","XCID")
			
		/*	
		Build array element1 in form element1(seq)= acronym
		and array element2 in form element2(acronym)= distribution | seq
		For this purpose, seq is equal to 'nn' in column names LNBIL1.PEnnEA etc.
		*/
		set quit=0 for I=1:2:39 do { quit:quit 
	
			new seq,seq2char
	
			// No more elements defined for this loan
			if $P(data,$C(9),I)="" set quit=1 quit 
	
			// Which element are we dealing with?
			set seq=(I+1)/2
	
			// Two character sequence used in column names
			set seq2char=$E(100+seq,2,3)
	
			//  If element distribution is equal to null, change to 1
			if '$P(data,$C(9),(I+1)) set $P(data,$C(9),(I+1))=1
	
			set element1(seq)=$P(data,$C(9),I)
			set element2($P(data,$C(9),I))=$P(data,$C(9),(I+1))_"|"_seq2char
	
			}

		/*		
		Increment all distributions found in LNBIL0 by 1.  This is because
		no elements in payment schedule processing are linked to 1st distribution
		*/
		type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
		set (I,update)="" for  set I=$O(element2(I)) quit:I=""  do {
			set update=1
			
			// New distribution
			set dist=element2(I)+1
			set seq=$P(element2(I),"|",2)
	
			set $P(element2(I),"|",1)=dist
	
			if seq=1 set X=lnbil0.pe01 set $P(X,"#",4)=dist,lnbil0.pe01=X
			if seq=1 set X=lnbil0.pe02 set $P(X,"#",4)=dist,lnbil0.pe02=X
			if seq=1 set X=lnbil0.pe03 set $P(X,"#",4)=dist,lnbil0.pe03=X
			if seq=1 set X=lnbil0.pe04 set $P(X,"#",4)=dist,lnbil0.pe04=X
			if seq=1 set X=lnbil0.pe05 set $P(X,"#",4)=dist,lnbil0.pe05=X
			if seq=1 set X=lnbil0.pe06 set $P(X,"#",4)=dist,lnbil0.pe06=X
			if seq=1 set X=lnbil0.pe07 set $P(X,"#",4)=dist,lnbil0.pe07=X
			if seq=1 set X=lnbil0.pe08 set $P(X,"#",4)=dist,lnbil0.pe08=X
			if seq=1 set X=lnbil0.pe09 set $P(X,"#",4)=dist,lnbil0.pe09=X
			if seq=1 set X=lnbil0.pe10 set $P(X,"#",4)=dist,lnbil0.pe10=X
			if seq=1 set X=lnbil0.pe11 set $P(X,"#",4)=dist,lnbil0.pe11=X
			if seq=1 set X=lnbil0.pe12 set $P(X,"#",4)=dist,lnbil0.pe12=X
			if seq=1 set X=lnbil0.pe13 set $P(X,"#",4)=dist,lnbil0.pe13=X
			if seq=1 set X=lnbil0.pe14 set $P(X,"#",4)=dist,lnbil0.pe14=X
			if seq=1 set X=lnbil0.pe15 set $P(X,"#",4)=dist,lnbil0.pe15=X
			if seq=1 set X=lnbil0.pe16 set $P(X,"#",4)=dist,lnbil0.pe16=X
			if seq=1 set X=lnbil0.pe17 set $P(X,"#",4)=dist,lnbil0.pe17=X
			if seq=1 set X=lnbil0.pe18 set $P(X,"#",4)=dist,lnbil0.pe18=X
			if seq=1 set X=lnbil0.pe19 set $P(X,"#",4)=dist,lnbil0.pe19=X
			if seq=1 set X=lnbil0.pe20 set $P(X,"#",4)=dist,lnbil0.pe20=X
			}
	
		if update'="" do lnbil0.save()
		// Insert payment schedule row for elements in distribution 2
		if ln.dist2nd'="" do {
	
			set XFPC="" if +$G(element2("P"))=2 set XFPC=ln.fpa
	
			new XCID,XPDD                     
			set XCID=ln.cid 
			set XPDD=ln.dist2nd
			do Db.insert("LNPS1","CID,PDD,D2F,FPC",":XCID,:XPDD,1,:XFPC")
	
			}
	
		// Insert payment schedule row for elements in distribution 3
		if ln.dist3nd'="" do {
	
			set XFPC="" if +$G(element2("P"))=3 set XFPC=ln.fpa
	
			new XCID,XPDD               
			set XCID=ln.cid 
			set XPDD=ln.dist3nd
			do Db.insert("LNPS1","CID,PDD,D3F,FPC",":XCID,:XPDD,1,:XFPC")
			}
	
		// Insert payment schedule row for elements in distribution 4
		if ln.dist4nd'="" do {
	
			set XFPC="" if +$G(element2("P"))=4 set XFPC=ln.fpa
	
			new XCID,XPDD        
			set XCID=ln.cid 
			set XPDD=ln.dist4nd
			do Db.insert("LNPS1","CID,PDD,D4F,FPC",":XCID,:XPDD,1,:XFPC")
			}
	
		// Build payment schedule from existing payment records
	
		// Load LNBIL1 table CDPD (due date), PEnnEA (Element), PEnnAB (Amount Billed)
	
		set data=""
		new rs 
		new list
		set list="CDPD,PE01EA,PE01AB,PE02EA,PE02AB,PE03EA,PE03AB,PE04EA,PE04AB,PE05EA,PE05AB,PE06EA"
		set list=list_",PE06AB,PE07EA,PE07AB,PE08EA,PE08AB,PE09EA,PE09AB,PE10EA,PE10AB,PE11EA,PE11AB,PE12EA,PE12AB,PE13EA"
		set list=list_",PE13AB,PE14EA,PE14AB,PE15EA,PE15AB,PE16EA,PE16AB,PE17EA,PE17AB,PE18EA,PE18AB,"
		set list=list_"PE19EA,PE19AB,PE20EA,PE20AB"
		type ResultSet rs=Db.select(list,"LNBIL1","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next()  do { quit:ER
			set data=rs.getRow()
			/*
			Build payment schedule lnps1 row where:
	
			pdd = payment due date
			d2f = indicator of whether or not elements in dist 1 are billed
			d3f = indicator of whether or not elements in dist 2 are billed
			d4f = indicator of whether or not elements in dist 3 are billed
			fpc = fixed principal amount
			*/
	
			set (d2f,d3f,d4f,fpc)=""
			set pdd=$P(data,$C(9),1)

			for I=2:2 set PEnnEA=$P(data,$C(9),I) quit:PEnnEA=""  do {

				set PEnnAB=$P(data,$C(9),(I+1))
				if 'PEnnAB quit 
	
				set dist=$P(element2(PEnnEA),"|",1)
	
				if PEnnAB do {
					if dist=2 set d2f=1
					if dist=3 set d3f=1
					if dist=4 set d4f=1
	
					}
	
				if PEnnEA="P" set fpc=PEnnAB
	
				}
	
			new XCID,XPDD,XD2F,XD3F,XD4F,XFPC   
			set XCID=ln.cid 
			set XPDD=pdd 
			set XD2F=d2f 
			set XD3F=d3f 
			set XD4F=d4f 
			set XFPC=fpc
			do Db.insert("LNPS1","CID,PDD,D2F,D3F,D4F,FPC",":XCID,:XPDD,:XD2F,:XD3F,:XD4F,:XFPC")
	
			}
	
		}
	
	quit

vau26 // Trigger AU_DIST1ND - After update of next due date

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	06/22/00 - JERUCHIMC - 40734
		   Added an additional check before setting error
       		   1901 to see if the system changed the data item.
       		   If the system changed the next due date, we want
        	   to allow it.
	
	09/02/99 - ALBINK - 33413
		   Added check so that the account's due date may only be
		   advanced when the loan has been disbursed.  For future
		   dated disbursements, added check so next billing date
		   cannot precede the disbursement date.  Deleted line of code
		   to quit if DIST1ND is changed by the system.  This code
		   needs to be processed whenever DIST1ND is modified.
	*/	
	
	new count,jd,quit,tba
	
	set quit=0
	
	/*
	*** Verifications ***************************************************
	DIST1ND changes prohibited if amounts exist in payment file.
	"Satisfy outstanding obligation of ~p1 before attempting to advance
	due date"
	*/

	if ln.tba set tba=ln.tba do Runtime.setErrMSG("LN",1835,tba) quit:ER 
	
	// "The account's due date may only be advanced" 
	if '(ln.isChanged("DIST1ND","SYSTEM")),ln.bal,ln.dist1nd'>ln.dist1nd.oldVal do Runtime.setErrMSG("LN",1901) quit:ER 
	
	// "Billing precedes disbursement date"  
	if ln.odd'<ln.dist1nd do Runtime.setErrMSG("LN",354) quit:ER 
	
	/*
	"Changes to account's due date prohibited when payment frequency
	field is empty"
	*/
	if ln.dist1fre="" do Runtime.setErrMSG("LN",61) quit:ER 
	
	/*
	"The new due date must be after the due date of the last payment
	record on file"
	*/
	if ln.dist1nd'>ln.lbdd do Runtime.setErrMSG("LN",1867) quit:ER 
	
	/*
	Find payment dates to build.  Each payment record will be due
	after LN.LBDD, and based on the later of LN.LBDD or LN.SCHND
	*/
	set jd=ln.schnd 
	set count=0
	if ln.dist1fre="*",jd=ln.dfp set jd=ln.odd
	else  set jd=$$NJD^UFRE(jd,ln.dist1fre,,1) quit:ER
	for  set jd=$$NJD^UFRE(jd,ln.dist1fre) quit:ER  do { quit:quit 
	
		// Payment record already exists
		if jd'>ln.lbdd quit 
	
		// Payment records before date of first payment
		if jd<ln.dfp quit 
	
		// Only payment records due before the new date must be built
		if jd'<ln.dist1nd set quit=1 quit 
	
		// Guard against infinite loop if account data is corrupted
		set count=count+1 if count>1000 set quit=1 quit 
	
		// Construct payment date array for later use
		set payments(jd)=""
	
		}
	
	// "The new due date must correspond to the account's payment frequency"
	if ln.dist1nd'=jd do Runtime.setErrMSG("LN",1871) quit:ER 
	
	
	/*
	*** Processing ******************************************************
	
	Create zero-amount bills for all due dates between LBDD and
	the new value of DIST1ND, exclusive.
	*/
	
	new cbcd,cid,cirn,coia,cdib,copb,pmtdat,pmtarray
	
	// Account number
	set cid=ln.cid   
	// Cut-off date
	set cbcd=%SystemDate                  
	// Interest rate
	set cirn=ln.irn 
	// Interest adjustment
	set coia=$$^SCARND(ln.inta,,cid)
	// Balance
	set copb=ln.balint
	// Deferred interest
	set cdib=ln.dic-ln.narl
	
	set pmtdat=""
	for  set pmtdat=$O(payments(pmtdat)) quit:pmtdat=""  do {
	
		set pmtarray(pmtdat,"*","LNBIL1.CBCD")=cbcd
		set pmtarray(pmtdat,"*","LNBIL1.CIRN")=cirn
		set pmtarray(pmtdat,"*","LNBIL1.COIA")=coia
		set pmtarray(pmtdat,"*","LNBIL1.COPB")=copb
		set pmtarray(pmtdat,"*","LNBIL1.CDIB")=cdib
	
		}
	
	set ER=$$CHANGE^PROCLNBL(cid,.pmtarray,,0)
	
	quit

vau27 // Trigger AU_DIST2_INFO - After update distribution 2 info

	type public RecordLN ln
	new njd
	
	if ln.dist2fre'="" do {
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER 

		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist2fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST2FRE") quit:ER 

		// ~P1 Must be a multiple of master payment frequency
		if ln.dist2fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist2fre) do Runtime.setErrMSG("LN",1795,"LN.DIST2FRE") quit:ER 
		}
	
	// Requires "*" master payment frequency
	if ln.dist2fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER 
	
	if ln.pmtdistf["2" do {
		set njd=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist2fre,2,ln.dist2nd,ln.bloff,%SystemDate)

		// Invalid Next 2nd Payment Date
		if njd'="" do Runtime.setErrXBAD("LN",88,"DIST2ND",ln.dist2nd,njd) quit:ER 
		}
	quit

vau28 // Trigger AU_DIST3_INFO - After update distribution 3 info

	type public RecordLN ln
	new njd
	
	if ln.dist3fre'="" do {
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER 

		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist3fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST3FRE") quit:ER 

		// ~P1 Must be a multiple of master payment frequency
		if ln.dist3fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist3fre) do Runtime.setErrMSG("LN",1795,"LN.DIST3FRE") quit:ER 
		}
	
	// Requires "*" master payment frequency
	if ln.dist3fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER 
	
	if ln.pmtdistf["3" do {
		set njd=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist3fre,3,ln.dist3nd,ln.bloff,%SystemDate)

		// Invalid Next 3rd Payment Date
		if njd'="" do Runtime.setErrXBAD("LN",89,"DIST3ND",ln.dist3nd,njd) quit:ER 
		}
	quit

vau29 // Trigger AU_DIST4_INFO - After update distribution 4 info

	type public RecordLN ln
	new njd
	
	if ln.dist4fre'="" do {
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER 

		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist2fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST2FRE") quit:ER 

		// ~P1 Must be a multiple of master payment frequency
		if ln.dist4fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist4fre) do Runtime.setErrMSG("LN",1795,"LN.DIST4FRE") quit:ER 
		}
	
	// Requires "*" master payment frequency
	if ln.dist4fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER 
	
	if ln.pmtdistf["4" do {
		set njd=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist4fre,4,ln.dist4nd,ln.bloff,%SystemDate)

		// Invalid Next 4th Payment Date
		if njd'="" do Runtime.setErrXBAD("LN",90,"DIST4ND",ln.dist4nd,njd) quit:ER 
		}
	quit

vau30 // Trigger AU_DOD_INTEG - Date of Death/Disability Integrity Check

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	07/19/05 - RussellDS - CR16614
		   Removed references to vpar array, replaced with vpar
		   variable.
		   
		   Minor PSL clean up.
		   
		   Removed old revision history.
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
	
	06/01/04 - KELLYP - CR 9670
		   Modified vpar check to avoid operator precedence warning.
	-----------------------------------------------------------------------
	
	This trigger should never have a column name associated with it.  
	It should be called for any and all CIF maintenance.
	*/
	
	type public Boolean ER
	type public String verrors()

	type Boolean DISBRST, DODRST
	type String VERR1, VERR2
	
	quit:vpar.isLike("%/NOVALRI/%")
	quit:vpar.isLike("%/FRMFILER/%")
	
	type RecordCIF cif = Db.getRecord("CIF","ACN=:ln.acn")

	// Verify that the CIFDOD and CIFDODSABL restrictions have not been set.
	// Do not set the restrictions a second time.

	set (DODRST,DISBRST) = 0
	set (VERR1,VERR2) = ""
	
	for  set VERR1=verrors(VERR1).order() quit:VERR1.isNull()  do {
		for  set VERR2=verrors(VERR1,VERR2).order() quit:VERR2.isNull()  do {
			if verrors(VERR1,VERR2).piece("|",3) = "CIFDOD" set DODRST = 1
			if verrors(VERR1,VERR2).piece("|",3) = "CIFDODSABL" set DISBRST = 1
		}
	}
	
	// An account owner is deceased
	if (cif.dod > 0), 'DODRST do Runtime.setErrXBAD("LN","CIFDOD") quit:ER 

	// An account owner is disabled
	if (cif.dodsabl > 0) , 'DISBRST do Runtime.setErrXBAD("LN","CIFDODSABL") quit:ER

	quit 

vau31 // Trigger AU_DPA - AFTER UPDATE DPA

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------

	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
		
	03/17/99 - FINCHG - 27393
		   Added check - DPA must be a deposit account
	*/
	
	type public Boolean ER

	// Deposit Payoff Account 
	if ln.dpa'="" do { quit:ER 

		type RecordACN acn
		set acn=Db.getRecord("ACN","CID=:ln.dpa")
		
		// Deposit payoff account must be a deposit account
		if acn.cls'="D" do Runtime.setErrXBAD("LN","LNDPA") quit:ER

		}
	
	quit

vau32 // Trigger AU_DPMT - After insert next due date - pmt amount

	type public RecordLN ln
	// Invalid due payment amount
	if ln.dpmt>0,ln.tba'>0 do Runtime.setErrXBAD("LN",181,"DPMT",ln.dpmt,0) quit:ER 
	quit
	

vau33 // Trigger AU_DTC - After update date account closed

	type public RecordLN ln
	// Open Account has DATE CLOSED
	if ln.dtc'="",ln.stat'=4 do Runtime.setErrXBAD("LN",122,"DTC",ln.dtc) quit:ER 
	quit
	

vau34 // Trigger AU_DXSI - After Update Deferred Excess Interest

	type public RecordLN ln
	/*---- Revision History ------------------------------------------------
	
			09/11/00 - GOMAAR - 41648 
	      Roll Forward for ARQ # 37508 from v6.2
														Added verification check on Bill Capitalized Interest
														as Principal flag and Defer Interest In Excess of Accrual flag.

			---------------------------------------------------------------------*/

	// Deferred Excess interest flag and the Capitalize interest flag cannot both
	// be set at the same time.
	if ln.dxsi,ln.icap do Runtime.setErrMSG("LN","4207") quit:ER
	
	// Defer Excess Accrual must be set when Bill Cap Int as Prin
	if (ln.bcapint),'(ln.dxsi) do Runtime.setErrXBAD("LN","BCAPINT") quit:ER
	quit

vau35 // Trigger AU_ESCROW - After update - changes affecting escrows

	type public RecordLN ln
	/*

	Update escrow account(s) to reflect changes to the columns that fire this
	trigger
	---- Revision History ------------------------------------------------
	
	03/30/06 - RussellDS - CR16892
	   	   Remove references to obsolete membership info.

	03/13/06 - Srinivar -19975	
		   Modified the trigger to fetch the Escrow CID 
		   using $$ECID^LNU instead of $$GETESC^ESCFUNCS.
	
	01/28/04 - CARROLLJ - CR7997
		   Corrected undefined error on variable XMEMNBR.


	*/

	type Number ESCCID,UPDT
		
	
	// Create UPDATE statement based on changed columns
	set UPDT=0
	
	set ESCCID=$$ECID^LNU(ln.cid,"ESC1")
	if ESCCID.isNull() quit
	
	new dep
	type RecordDEP dep=Db.getRecord("DEP","ESCCID")
	if (ln.boo.oldVal'=ln.boo) set dep.boo=ln.boo,UPDT=1
	if (ln.cc.oldVal'=ln.cc) set dep.cc=ln.cc,UPDT=1
	if (ln.ccode.oldVal'=ln.ccode) set dep.ccode=ln.ccode,UPDT=1
	if (ln.mf.oldVal'=ln.mf) set dep.mf=ln.mf,UPDT=1
	if (ln.rescd.oldVal'=ln.rescd) set dep.rescd=ln.rescd,UPDT=1
	
	if UPDT do {
		if vpar.isLike("%/NOUPDATE/%") do dep.save("NOUPDATE/NOINDEX/NOJOURNAL")  if 1 
		else  do dep.save()	
		}
		
	quit

vau36 // Trigger AU_FIA - After Update trigger for FIA column

	type public RecordLN ln
	/*---------- Revision History ------------------------------------------ 

		05/09/06 - Dhanalakshmi R - 21105
		      Modified to use Db.getRecord with getmode instead
		      of Db.insert.

		03/16/06 - ratht - CR 20111
		      Used ln.genprjrep instead of REP variable and 
		      reference %SystemDate instead of DATE in the 
		      Db.insert() statement.
		      
		11/07/00 - VETSENM - 40359

	              If LN.GENPRJREP is set to "Yes" than an entry will be set
																						into the table DAYENDLNNOT.       
	------------------------------------------------------------------------ */ 


	if ln.genprjrep=1 do {

		type public Number CID
		type RecordDAYENDLNNOT lnnot=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=4",1)

		if 'lnnot.getMode() do lnnot.bypassSave()
	}
	quit

vau37 // Trigger AU_FPA - After Update trigger for FPA column.

	type public RecordLN ln
	
	/*---------- Revision History------------------------------------------ 

	05/09/06 - Dhanalakshmi R - 21105
		   Modified to use Db.getRecord with getmode instead
		   of Db.insert.
	
	02/13/02 - VETSENM - 49054
		   Assign %SystemDate value to the variable DATE.	

	11/07/00 - VETSENM - 40359
	           
	-----------------------------------------------------------------------*/


	if ln.genprjrep=1 do {

		type public Number CID
		type RecordDAYENDLNNOT lnnot=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=4",1)

		if 'lnnot.getMode() do lnnot.bypassSave()
	}
	quit

vau38 // Trigger AU_GLSC - After update valid G/L set code.

	type public RecordLN ln
	/* 
	---- Revision History ------------------------------------------------

	06/01/05 - Kini - 16153
		   Added GLSC verification via GLCHK^ACNFUNCS to ensure that
		   the class and group of GLSC match the class and group of 
		   the loan.

	02/17/05 - Kini - 13991	
		   Modified to replace UTBLGLSCX index table with UTBLGLSC
		   since UTBLGLSCX has been obsoleted.
	*/
	
	type public Boolean ER
	
	// Validate G/L Set Code
	do GLCHK^ACNFUNCS(ln.cls,ln.grp,ln.glsc) quit:ER
	
	quit
	

vau39 // Trigger AU_GRP - After update group

	type public RecordLN ln
	/* ---- Revision History -----------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 

	*/

	type public Boolean ER

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")

	// Product class or group does not match product type
	if ln.grp'=prodctl.grp do Runtime.setErrMSG("LN",8472) quit:ER 

	quit
	

vau40 // Trigger AU_ICAP - Validate ICAP options

	type public RecordLN ln
	/*	
	Check for valid entries in IROPT and ICAP
	Interest Resolution option required
	*/

	if (ln.icap),'(ln.iropt) do Runtime.setErrXBAD("LN","IROPTREQ") quit:ER 

	// Interest Resolution option cannot be 1 if ICAP is "yes"
	if (ln.icap),(ln.iropt=1) do Runtime.setErrXBAD("LN","RESOPT") quit:ER 
	
	quit

vau41 // Trigger AU_IGRC - After Update

	type public RecordLN ln
	/*
	 ---- Revision History--------------------------------------------------

	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
	*/

	if ln.stat=4 quit 

	if ln.idpf'=1 quit

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")
	if 'prodctl.defal quit  

	type RecordCIF cif
	set cif=Db.getRecord("CIF","ACN=:ln.acn")	
	if 'cif.semfin quit


	type Number AKEY,BUFF,SEQ
	type String NEW,OLD,TABLE

	if ln.igrc.oldVal set OLD=$$EOMJD^SCADAT($$EXT^UMDT(ln.igrc.oldVal,SEMFIN,"","N"))
	else  set OLD=$$EOMJD^SCADAT(SEMFIN)

	if ln.igrc set NEW=$$EOMJD^SCADAT($$EXT^UMDT(ln.igrc,SEMFIN,"","N"))
	else  set NEW=$$EOMJD^SCADAT(SEMFIN)

	// Update OLD, Turn it on

	set AKEY=ln.cid
	set SQL="UPDATE LN SET PTF=1 WHERE CID="_ln.cid
	set TABLE="LN" set SEQ=1
	set BUFF=Db.nextVal("EFD","OLD,SEQ")
	
	type RecordEFD efdold=Class.new("RecordEFD")

	set efdold.efdate=OLD
	set efdold.buff=BUFF	
	set efdold.seq=SEQ
	set efdold.akey=AKEY
	set efdold.table=TABLE
	set efdold.sql=SQL	

	do efdold.save()

	// Update NEW, turn it off

	set SQL="UPDATE LN SET PTF=0 WHERE CID="_ln.cid	
	set BUFF=Db.nextVal("EFD","NEW,SEQ")

	type RecordEFD efdnew=Class.new("RecordEFD")

	set efdnew.efdate=NEW
	set efdnew.buff=BUFF
	set efdnew.seq=SEQ
	set efdnew.akey=AKEY
	set efdnew.table=TABLE
	set efdnew.sql=SQL

	do efdnew.save()

	quit
	

vau42 // Trigger AU_INT_INFO - After Update Interest Information

	type public RecordLN ln
	/*
	----Revision History---------------------------------------------------
	
	01/05/07 - KUMARB - CR24680
		   Modified trigger to return error message "Interest Offset
		   Processing not allowed for segmented accounts" if Interest
		   Review Offset Days is defined and Segment in Use is selected.
	
	02/17/06 - TELIV - 19573
		   Added LN.MINRATE for the trigger event. Modified the check for 
		   Rate diffrential (IRN<MINRATE+(Max of DEP>IRN))
	
								03/27/05 - JERUCHIMC - 14822
																			Removed CRCD argument in call to RATEFC^LNFUNCS.
		   Retrofitted the following change:
			
																			04/11/04 - TITOVE - CR 8094
																			Modified to quit after first comparison of ln.ichnd to
																			%SystemDate (consistent with LNAI logic). Previously the
																			system would always set up an integrity error if ln.ichnd
																			was equal to today, no matter if the account utilizes
																			interest offset processing or not.

	01/28/04 - CARROLLJ - CR7997
		   Modified call to CTL^UINDX.

	01/17/02 - EDWARDSM - 47407
		   Updated trigger so that an error will be returned if an
		   Index Rounding Flag is defined without a Rounding Method
		   or a Rounding Method is defined without an Index Rounding
		   Flag.

	12/07/00 - PONGRACZD - 40927
		   Roll up change from ARQ 40201
		   Added call to INDFILE^LNU before call to CTL^UINDX to set
		   INDDATA up correctly.  Before, if there was no spread, an
		   extra space was included in INDDATA causing the rounding
		   method to be ingnored.

	08/25/00 - GOMAAR - 41615 
		   Condition of Error Message # 8745 was preventing the
																			Updating of the Interest rate on Effective Date of a loan
																			Account.

	07/19/00 - SIVCHUKA - 40946  (Original ARQ 1#37897 and 2#39849) 
	           Added Non-Fatal XBAD Massage(3004)"Commitment cannot accrue
																			interest"
																			The following message should appear if you attempt to open
																			a commitment with an interest rate, or modify a commitment
																			to have an interest rate. 
	
	07/12/99 - Jerry Petrole - 34005
		   Change for arq 33055 - Check to see that a new IRN falls
		   within account's min and max rates.
	
	03/10/99 - MALTEPESA 31813
		   Rolled code from v60 forward.
		   Added logic to not parse the INDEX field for Interest Matrix.
		   Also added logic to return error if creating an account
		   with Interest Matrix is set to null.
	
	02/27/99 - KLINEB - 32047
		   Roll forward from v5.3.
		   Moved logic for updating INTMAT, INTSPR, RNDMTD when INDEX is
		   updated to null to BU_INDEX trigger.  This was done for
		   processing considerations.  Modified logic to return error
		   message if INTMAT, INTSPR, or RNDMTD are defined and INDEX is
		   not, to accomodate these changes
	
	12/09/98 - HAYMANP - 30705
		   Modified logic to set XBAD code 91 from >SytemDate to '<.
		
	*/

	if (ln.index.oldVal'=ln.index),ln.index="" do {
		set ln.ichnd=""
		set ln.ichld=""
		set ln.intoff=""
		set ln.intfre=""
		set ln.ichm=""
		}
	
	// Interest Offset Required if a Payment change frequency exists
	if ln.intoff="" do { quit:ER 
		if ln.pcfre'="" do Runtime.setErrXBAD("LN","PCFRE") quit:ER 
		}
		
	
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		// Interest Offset Processing not allowed for segmented accounts
		if (ln.segments),('ln.intoff.isNull()) do Runtime.setErrMSG("LN",5339) quit:ER
	#ENDIF
	
	if ln.intoff'="" do { quit:ER 
		// Interest Offset Requires an Index 
		if ln.index="" do Runtime.setErrXBAD("LN","INDEX15") quit:ER 
		}
	
	if ln.intfre'="" do { quit:ER 
		// Interest Change Frequency Requires an Index
		if ln.index="" do Runtime.setErrXBAD("LN",8) quit:ER 
	
		// Check against master frequency
		do INTFREF^LNPPC3(ln.intfre,ln.dist1nd,ln.pcmval,ln.dist1fre)
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER 
		}
	
	if ln.index'="" do { quit:ER 
		// Interest Index reqs value in Last Change Date
		if ln.ichld="" do Runtime.setErrXBAD("LN","INDEX11") quit:ER 

		// Interest Index reqs value in Next Change Date
		if ln.ichnd="" do Runtime.setErrXBAD("LN","INDEX12") quit:ER 

		// Interest Index reqs value in int change freq
		if ln.intfre="" do Runtime.setErrXBAD("LN","INDEX13") quit:ER 
		}
	
	if (ln.intfre.oldVal'=ln.intfre)!(ln.ichnd.oldVal'=ln.ichnd)!(ln.intoff.oldVal'=ln.intoff) do { quit:ER 
		new XJD
		if ln.intfre="" quit 
		if ln.ichnd="" do Runtime.setErrMSG("LN",7531,"LN.ICHND") quit 

		// Check date against master frequency
		do ICHNDF^LNPPC3(ln.ichnd,ln.dist1nd,ln.pcmval,ln.dist1fre,ln.intfre)
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER 
	
		// No offset processing - next date can be today or greater
		// NEXT INTEREST CHANGE Date in the Past
		  if ln.intoff="" do { quit
																								if ln.ichnd<%SystemDate do Runtime.setErrXBAD("LN",76,"ICHND",ln.ichnd) quit:ER
																								}
		
		  

		// Offset processing -- next date must be greater than today
		// NEXT INTEREST CHANGE Date in the Past
		if ln.ichnd'>%SystemDate do Runtime.setErrXBAD("LN",76,"ICHND",ln.ichnd) quit:ER 
	
		// Offset periods may overlap.  Verify all offset dates in process.
		set XJD=ln.ichnd
		for  quit:(XJD-ln.intoff'<%SystemDate)  do { quit:ER 
			new rate,XCID
			set XCID=ln.cid
			set rate=Db.getOneRow("RATE","LNVRCHG","XJD,XCID") quit:ER 
			if $G(rate)="" do Runtime.setErrXBAD("LN",91) quit:ER 
			set XJD=$$NJD^UFRE(XJD,ln.intfre) quit:ER
			}
		}
	
	// Updating Interest Matrix, Interest Spread, Interest Rounding Method
	
	if ((ln.intmat'="")!(ln.intspr'="")!(ln.rndmtd'=""))&(ln.index="") do Runtime.setErrMSG("LN",8745) quit:ER 
	
	if ln.intmat'="" do {
		set NAME=ln.intmat
		set ITEM=Db.getOneRow("ROW","UTBLMATATT","NAME")
		set DITEM=Db.getOneRow("LN","STBLMATATT","ITEM")

		// Matrix values invalid for this account
		if DITEM="" do Runtime.setErrMSG("LN",3228,RM) quit:ER 
		set ITEM1=Db.getOneRow("MATCOL","UTBLMATATT","NAME")
		if ITEM1'="" do {                   
			set DITEM1=Db.getOneRow("LN","STBLMATATT","ITEM1")

			// Matrix values invalid for this account
			if DITEM1="" do Runtime.setErrMSG("LN",3228,RM) quit:ER 
			}
		}

	// IRF - Rounding Method is required with Interest Rounding Flag
	if ln.irf'="",ln.rndmtd="" do Runtime.setErrMSG("LN",5099) quit:ER

	// IRN validation 

	// To prevent commitment with interest rate
	if ln.cpf=1,ln.irn>0 do Runtime.setErrXBAD("LN",3004) quit:ER  ;SIVCHUKA 07/19/00

	// Data required in data item ~p1
	if ln.irn="",ln.ircb>0 do Runtime.setErrMSG("LN",7531,"LN.IRN") quit:ER 

	// Must have a rate or index
	if ln.irn="",(ln.index="") do Runtime.setErrSTBLER("LN","LNRTRQ") quit:ER 

	// Rate ceiling/floor validation
	new rfloor,rceiling
	do RATEFC^LNFUNCS(ln.type,.rfloor,.rceiling)
	if rceiling="" set rceiling=99.99

	// INTEREST RATE Outside Valid Range
	if ln.irn>rceiling!(ln.irn<rfloor) do Runtime.setErrXBAD("LN",117) quit:ER 
	
	// MINRATE - Minimum Rate Differential - Validate Minimum Rate Differential
	if ln.minrate,(ln.irn<($$MINRATE^LNCDI(CID)+ln.minrate)) do Runtime.setErrXBAD("LN","MINR") quit:ER 
	
	// RNDMTD - Interest Rounding Flag is required with Rounding Method
	if ln.rndmtd'="",ln.irf="" do Runtime.setErrMSG("LN",5100) quit:ER

	// Validate IRN againt account Min and Max Rates - JP 7/9/99 33055
	
	// Too Low
	if ln.intmn'="",ln.irn<ln.intmn do Runtime.setErrXBAD("LN","INVINTRTL") quit:ER       
	// Too High
	if ln.intmx'="",ln.irn>ln.intmx do Runtime.setErrXBAD("LN","INVINTRTH") quit:ER        
	
	// Validate IRN for calculated rate
	do { quit:ER 
		new baseamt,date,RATE
		if ln.intmx!ln.intmnic!ln.intmxic!ln.intmxiy quit 
		if ln.intmn!ln.intmndc!ln.intmxdc!ln.intmxdy quit 
		if ln.index="" quit 
		if ln.intfre="" quit 
		set date=ln.ichld-ln.intoff
		if date<ln.dtnt set date=ln.dtnt

		// No Index Rate Entered for Date
		if 'date do Runtime.setErrXBAD("LN",114) quit:ER 
		if 'ln.cntdr set baseamt=ln.amtreq
		else  set baseamt=ln.balint
		set PAR("INDEX")=ln.index
		set PAR("SPREAD")=ln.intspr
		set PAR("ROUND")=ln.rndmtd
		set PAR("RNDFC")=1
		set PAR("MATRIX")=ln.intmat
		do CTL^UINDX(.ln,date,baseamt,.PAR) quit:ER

		// Interest Rate Inconsistent with Calculated Rate
		if +RATE'=+ln.irn do Runtime.setErrXBAD("LN",133,"IRN",ln.irn,RATE) quit:ER 
		}
	quit

vau43 // Trigger AU_INT_INFO2 - After Update Int Amounts, IAM, IDP Info

	type public RecordLN ln
	/*
								---------- Revision History ------------------------------------------
							 
								05/31/07 - KUMARB - CR 27163
        	   Modified trigger to return error message "Interest
        	   Amortization Method must be No Interest Add-On/Discount
        	   for segmented accounts" if Segments Allowed (LN.SEGMENTS)
        	   selected and Interest Amortization Method (LN.IAM) is not 0.

	01/05/07 - KUMARB - CR24680
		   Modified trigger to return error message "Interest
		   Determination Point at payment not allowed for segmented
		   accounts" if Segments Allowed (LN.SEGMENTS) and Interest
		   Determination Point (LN.IDP) are selected.
		   
	12/12/01 - VERTLIBA - 48460
																			Modified previous fix to check dates only for loans
																			which have a maturity date.
	
	12/05/01 - GORDONT - 47316
	           Added Error Message check for LN.MDT not to be prior
		   to LN.ODD.

	11/28/01 - GORDONT - 47316
            	   Added code to verify that LN.MDT is greater than
																			LN.ODT else the error "Maturity date must be later than
																			opening date" is displayed.
	
	10/31/00 - LUS - 40355
		   Modified the code that validate the MAX/MIN loan payment
		   term.

	10/19/00 - LUS - 40355
		   Added XBAD Error message to verify whether Loan Payment Term
		   outside valid range. 
	
	09/19/00 - YENDAPALLIS - 39372
		   Changed table name from PRODDFTC to PRODCTL for INTYPRST.
	
	*/
	// abv - 48460 - check dates only for loans which have Maturity date
	// Maturity date must be after disbursement date - arq 47316
	if ln.mdt,ln.mdt'>ln.odd do Runtime.setErrMSG("LN",1680) quit:ER 
														 
	// abv - 48460 - check dates only for loans which have Maturity date
	// Maturity date must be later than opening date - arq 47316
	if ln.mdt,ln.mdt'>ln.odt do Runtime.setErrMSG("LN",1681) quit:ER
	
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do { quit:ER
			
			// Interest Determination Point at payment not allowed for segmented accounts
			if ln.idp do Runtime.setErrMSG("LN",6180) quit:ER
			
			// Interest Amortization Method must be No Interest Add-On/Discount for segmented accounts
			if ln.iam>0 do Runtime.setErrMSG("LN",6215) quit:ER
			}
	#ENDIF

	// Add-On Loan has Interest Determined at Payment
	if (ln.iam.oldVal'=ln.iam)!(ln.idp.oldVal'=ln.idp) do { quit:ER 
		if ln.iam,ln.idp do Runtime.setErrXBAD("LN",155) quit:ER 
		}
	
	// Collected Interest Exceeds Original Uncollected
	if (ln.iam.oldVal'=ln.iam)!(ln.ipl.oldVal'=ln.ipl)!(ln.iun.oldVal'=ln.iun) do { quit:ER 
		if ln.iam,ln.ipl>ln.iun do Runtime.setErrXBAD("LN",32,"IPL",ln.ipl,ln.iun) quit:ER 
		}
	
	// FLAT,IAM -Flat Rate Interest Calculation and Interest Amortization Method
	if (ln.flat.oldVal'=ln.flat)!(ln.iam.oldVal'=ln.iam) do { quit:ER 
		if ln.flat=1,ln.iam'>0 do Runtime.setErrXBAD("LN",517) quit:ER 
		}
	
	// IAM,MDT- Interest Amortization Method and Maturity date
	if (ln.mdt.oldVal'=ln.mdt)!(ln.iam.oldVal'=ln.iam) do { quit:ER 
		if ln.mdt="",ln.iam>0 do Runtime.setErrXBAD("LN",518) quit:ER 
		}
	
	// IAM - Interest Amortization Method
	if (ln.iam.oldVal'=ln.iam)!(ln.mdt.oldVal'=ln.mdt)!(ln.trm.oldVal'=ln.trm) do { quit:ER 
		if ln.iam'>0 quit 
		if $$EXT^UMDT(ln.trm,ln.dtnt,0,ln.busopt,ln.nbdc)'=ln.mdt do Runtime.setErrXBAD("LN",519) quit:ER 
		set JD=$$NJD^UFRE(ln.mdt,"-"_ln.dist1fre) quit:ER
		if $$NJD^UFRE(JD,ln.dist1fre)'=ln.mdt do Runtime.setErrXBAD("LN",519) quit:ER 
		}
	
	if (ln.iam.oldVal'=ln.iam) do { quit:ER 
		if ln.iam>0,$$NJD^UFRE(ln.dtnt,ln.dist1fre)'=ln.dfp do Runtime.setErrXBAD("LN",519) quit:ER 
	
		}
	
	// MAX/MIN Loan Payterm Term Verification	
	if ln.minptrm'="" do { quit:ER
																new ODT,TRM
																set ODT=%SystemDate
																set TRM=ln.minptrm
																// Validate term format
																do ^UMDT
																if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
																}
	if ln.maxptrm'="" do { quit:ER
																new ODT,TRM
																set ODT=%SystemDate
																set TRM=ln.maxptrm
																// Validate term format
																do ^UMDT
																if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
																}
	//Loan Payment Term outside valid range  LUS
								set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)
	if ln.minptrm'="",(ln.mdt<$$MDT^PROCLN(ln.dtnt,ln.odd,ln.minptrm,,ln.busopt,ln.nbdc,ln.amodt,PCMVAL,ln.dist1fre)) do Runtime.setErrXBAD("LN","LNPTRM") quit:ER
	if ln.maxptrm'="",(ln.mdt>$$MDT^PROCLN(ln.dtnt,ln.odd,ln.maxptrm,,ln.busopt,ln.nbdc,ln.amodt,PCMVAL,ln.dist1fre)) do Runtime.setErrXBAD("LN","LNPTRM") quit:ER

	/*
	Int Determ Point Invalid for Pmt Calc Method
	These types of loans should have their interest calculated at billing
	*/
	if (ln.idp.oldVal'=ln.idp) do { quit:ER 
		if ln.idp=1,($E(ln.pcmval,2)>0)!($E(ln.pcmval,3)>2) do Runtime.setErrXBAD("LN",127) quit:ER
		}
	
	// Interest balance option requires interest calc at billing
	if (ln.idp.oldVal'=ln.idp)!(ln.icpa.oldVal'=ln.icpa) do { quit:ER 
		if ln.idp'=1 quit 
		new prio,ICPA
		set ICPA=ln.icpa
		set prio=Db.getOneRow("PRIO","UTBLICPA","ICPA") quit:ER 
		if $E(prio,1)!$E(prio,2)!$E(prio,7)!$E(prio,8)!$E(prio,11) do Runtime.setErrXBAD("LN",521) quit:ER 
		}
	quit

vau44 // Trigger AU_IRCID - After Update Interest Reserve Acct Numbr

	type public RecordLN ln
								/*
								---- Revision History---------------------------------------------------
							 
								08/02/05 - KUMARB - CR16684
		Modified the table name LNLCOM to LN in Db.select
	
								05/15/00 - KELLYP - 35505
		Added code to remove interest reserve account to loan account
		reference in the RELIR global when ln.ircid and ln.iramto have
		been deleted from the loan account's record.
								*/


	/* 
		Interest Reserve Account Number and Interest Reserve Original Amount must 
		both be defined
	*/

	if (ln.ircid=""),(ln.iramto'="") do Runtime.setErrMSG("LN","4289") quit:ER
	if (ln.ircid'=""),(ln.iramto="") do Runtime.setErrMSG("LN","4289") quit:ER

	if (ln.ircid=""),(ln.iramto="") do { quit
	// 35505 - Remove RELIR reference
	new IRCID,LNCID
	set IRCID=ln.ircid.oldVal,LNCID=ln.cid
	if 'Db.isDefined("RELIR","IRCID,LNCID") quit
	do Db.delete("RELIR","IRCID=:IRCID AND LNCID=:LNCID")
	}

	if (ln.ccl'=""),(ln.ircid'="") do { quit:ER

	/* 
 	 This section ensures that the account's linked commitment does not 
	 also have an interest reserve account number defined.  Also performed
	 for sub-commitments tied to a commitment.
 	*/

	new IRCID,XCCL

	set XCCL=ln.ccl
	set IRCID=Db.getOneRow("IRCID","LN","XCCL")   // Commitment's I.R. Acct Number

	/* 
	 Cannot define Interest Reserve Account on both commitment and linked 
	 loans
 	*/

	if IRCID'="" do Runtime.setErrMSG("LN","4290") quit:ER
	
	if 1	// Preserves $T
	}

	else  if (ln.cpf),(ln.ircid'="") do { quit:ER
	
	/*
	 This section ensures that a commitment's linked loans do not have an 
	 interest reserve account number defined if one is defined on the 
	 commitment.
	*/

	new CID,rs

	set CID=ln.cid
	type ResultSet rs=Db.select("CID","LN","CCL=:CID")
	if rs.isEmpty() quit

	while rs.next() do { quit:ER
		new XCID,IRCID
		set XCID=rs.getCol(1)
		if 'Db.isDefined("LN","XCID") quit
		set IRCID=Db.getOneRow("IRCID","LN","XCID")	
		
		/* 
		 Cannot define Interest Reserve Account on both commitment 
		 and linked loans
		*/

		if IRCID'="" do Runtime.setErrMSG("LN","4290") quit:ER
		} 
	}

 if (ln.ircid'="") do { quit:ER		 

	/*
	 This section updates the Interest Reserve to Loan Commitment cross-
	 reference table with the new interest reserve account and loan account
	 numbers as well as the interest reserve original amount.
	*/

	new IRCID,IRAMTO,LNCID

	set IRCID=ln.ircid,LNCID=ln.cid,IRAMTO=ln.iramto

	// Interest Reserve Account is not a valid PROFILE account
	if 'Db.isDefined("DEP","IRCID") do Runtime.setErrMSG("LN","4318") quit:ER

	if Db.isDefined("RELIR","IRCID,LNCID") quit

	type RecordRELIR relir=Class.new("RecordRELIR")
	
	/* 
	 relir.iramtr will be updated by the deposit posting programs when 
	 funds are actually transferred to the account.
	*/

	set relir.ircid=IRCID,relir.lncid=LNCID,relir.iramtr="0"
	do relir.save()  
	}
	quit

vau45 // Trigger AU_LATECHG_INFO - After update late charge information

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	02/01/99 - HAYMANP - 28976
		   Added condition LCHGNOTO'=1 to check on LCAD.
	
	*/

	
	if (ln.lcad.oldVal'=ln.lcad) do { quit:ER 
		// Data required in Data Item ~p1
		if ln.dlcaf,ln.lcad="" do Runtime.setErrMSG("LN",7531,"ln.lcad") quit:ER 
	
		// Maintain DAYEND file
		new LCAD,X,XCID,XLCEFD
		set XCID=ln.cid
		set XLCEFD=ln.lcefd
		set XLCAD=ln.lcad
		set XTJD=ln.lcad.oldVal
		if ln.lcad="",ln.lcad.oldVal>%SystemDate  do Db.delete("DAYENDLCHG","TJD=:XTJD and CID=:XCID")
		if ln.lcad'="" do {
			if ln.lcad.oldVal'=""  do Db.delete("DAYENDLCHG","TJD=:XTJD AND CID=:XCID")
			do Db.insert("DAYENDLCHG","TJD,CID,LCEFD",":XLCAD,:XCID,:XLCEFD")
			}
		}
	
	if ln.popt'="",ln.dist1fre'="",ln.lchgnoto'=1 do { quit:ER 
		new i,lcad,lcefd,pmtgrc,XBLDT,XCID
		set XCID=ln.cid 
		set XBLDT=ln.bldt
	
		new rs 
		type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:XCID AND CBCD=:XBLDT","SCHSEQ DESC") 
		//type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:XCID AND CBCD=:XBLDT")
		if rs.isEmpty() quit
		set lcefd=rs.next(),lcefd=rs.getCol(1)
		if $G(lcefd)="" quit 
		set pmtgrc=ln.pmtgrc
		set lcad=lcefd+pmtgrc
		if pmtgrc["P" set lcad=lcefd do { quit:ER 
			for i=1:1:$E(pmtgrc) set lcad=$$NJD^UFRE(lcad,ln.dist1fre) quit:ER 
			set lcad=lcad-$P(pmtgrc,"-",2)
			}
	
		if ln.lcbo="N" for lcad=lcad:1 quit:$$BD^UNBD(lcad) 
		if 'ln.bseq!(ln.bldt+1=ln.odd) quit 
		// Late Charge Action Date Invalid
		if lcad'=ln.lcad do Runtime.setErrXBAD("LN",124,"LCAD",ln.lcad,lcad) quit:ER 
		if lcefd'=ln.lcefd do Runtime.setErrXBAD("LN",129,"LCEFD",ln.lcefd,lcefd) quit:ER 
		}
	quit

vau46 // Trigger AU_MAXAGGR - After Update Maximum Aggregate Draw Amt

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------

	01/17/06 - KELLYP - CR 19080
		   Modified the check on ln.maxaggr to check for (ln.maxaggr)
		   instead of ('ln.maxaggr.isNull()).  This prevents a problem
		   from occurring where the system defaults in a zero for this
		   column (because DBTBL1D.NULLIND is enabled) and the check
		   then determines that 0 is not null and 0 is less than the
		   credit limit, and returns error message # 4279 incorrectly.

	03/30/05 - KinI - 14385
	           Cleaned up to comply with DBI standards. 

	*/
	
	type public Boolean ER

	// Maximum Aggregate Draw Amount may not be less than the loan amount
	if (ln.maxaggr),(ln.maxaggr<ln.crlmt) do Runtime.setErrMSG("LN","4279") quit:ER

	quit

vau47 // Trigger AU_MAXO - Late Charge Method Maximum Override

	type public RecordLN ln
	/*---- Revision History--------------------------------------------------------
	
	11/16/00 - MAGERAM - 42816	
		   Modified code for XBAD Message "MAXGTMIN" to check if
		   LN.MAXO has a value.            
	
	10/17/00 - MAGERAM - 40354
		   Created AU_MAXO to verify that LN.MAXO is greater than 
		   LN.MINO else the error "Late Chrg Max Ovr must be greater 
		   than Late Chrg Min Ovr" is displayed.
		
	----------------------------------------------------------------------
	*/
	
	// Late Chrg Max Ovr must be greater than Late Chrg Min Ovr
	if ln.maxo,(ln.maxo<ln.mino) do Runtime.setErrXBAD("LN","MAXGTMIN") quit:ER 
	quit

vau48 // Trigger AU_MT900THR - After Update MT900 Debit Threshold Trgr

	type public RecordLN ln
	// Check to ensure that MT900 Debit Threshold is present if Generate MT900="Y"
	
	if ln.mt900=1 do {
 	if ln.mt900thr="" do {
		new cif900thr,XACN
		set XACN=ln.acn
		set cif900thr=Db.getOneRow("MT900THR","CIF","XACN")
		if cif900thr="" do Runtime.setErrMSG("LN","4077") quit:ER
	}
	}
	quit

vau49 // Trigger AU_MT910THR - After Update MT910 Credit Threshold Trgr

	type public RecordLN ln
	// Check to ensure that MT910 Credit Threshold is defined if Generate MT910='Y'

	if ln.mt910=1 do {
	if ln.mt910thr="" do {
		new cif910thr,XACN
		set XACN=ln.acn
		set cif910thr=Db.getOneRow("MT910THR","CIF","XACN")
		if cif910thr="" do Runtime.setErrMSG("LN",4078) quit:ER
	}
	}
	quit

vau50 // Trigger AU_NAI - After update of Non accrual indicator.

	type public RecordLN ln
	/*---- Revision History ------------------------------------------------

			02/22/00 - HALPINJ - 43896
	      Added code to check if dayend global exists then quit.
	      If trigger is called during dayend processing a SAVEFAIL
	      error would be received.

			08/24/00 - HALPINJ - 41326
	      Create trigger so user cannot modify LN.NAI without
	      changing the G/L set code.
	
			----------------------------------------------------------------------
	*/
	
	new GLSC,LTYPE,NAGL,values
	// If called by dayend process quit.
 if Db.isDefined("DAYENDLNNAO","TJD,CID") quit		// JMH - 02/22/01
	// Non-accrual G/L link not changed.
	if '(ln.glsc.oldVal'=ln.glsc) do Runtime.setErrSTBLER("LN","LNNA3") quit:ER
	set LTYPE=ln.type
	set GLSC=Db.getOneRow("GLSC","PRODDFTL","LTYPE")
	set NAGL=Db.getOneRow("NAGL","PRODCTL","LTYPE")
	if ln.nai=1 do {
	// Non-accral G/L link differs from product type value.
	if ln.glsc'=NAGL do Runtime.setErrSTBLER("LN","LNNA1") quit:ER
	do Db.insert("DAYENDLNNAO","EJD,CID,MAN,UID",":TJD,:CID,1,:%UID") quit:ER
	}
	else  do {
	// G/L link differs from product type value.
	if ln.glsc'=GLSC do Runtime.setErrSTBLER("LN","LNNA2") quit:ER
	do Db.insert("DAYENDLNNAO","EJD,CID,DEL,UID",":TJD,:CID,1,:%UID") quit:ER
	}
	Q
	quit

vau51 // Trigger AU_NBTR - After Neg. Bal. Transfer update

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------------
	09/15/99 - KELLYP 34662
		   Added NTROPT column to "Columns Associated" area of trigger
		   definition.  Previously, trigger was not forcing the entry
		   of the NTROPT column when NBTR was present because NTROPT
		   was not associated with the trigger.
	
	03/11/99 - MALTEPESA 31430
		   Added a check to return an XBAD msg if Negative Balance Transfer
		   has value but Negative Transfer option does not.
	*/

	if ln.nbtr="" quit
	if (ln.nbtr),(ln.ntropt="") do Runtime.setErrXBAD("LN",529) quit:ER 
	quit
	

vau52 // Trigger AU_NUMDTP - After Update trigger for column NUMDTP

	type public RecordLN ln
	/*
	---------- Revision History -------------------------------------------

	   03/30/05 - KinI - 14385
		      Added error message text comment.
	
											11/07/00 - VETSENM - 40359
          	      Set XBAD error message for LN.NUNDTP if LN.GENPRJREP=1       
	*/
	
	type public Boolean ER

	// Ln activity proj requires nbr of days to project or mat
								if (ln.genprjrep=1) , (ln.numdtp="") do Runtime.setErrXBAD("LN",238) quit:ER

	quit

vau53 // Trigger AU_ODD_DTNT_ODT - After update of initial dates

	type public RecordLN ln
	/*
	  ------------------------------- Revision History -------------------
	
	02/27/06 - ratht - CR19435
	 	   Added a new line to check the conditon for the column ODD.
	 	   
	12/12/01 - VERTLIBA - 48460
		   Modified previous fix to check dates only for loans
		   which have a maturity date.
	
 	04/06/01 - Terrie Dougherty - 36921
		   Modified to return an error if the opening date is modified 
		   to a date later than the maturity date.
	
	05/24/00 - MOTENJ - 40196
		   Changed the condition checking syntax of %ProcessMode to the
		   correct form(if %ProcessMode'=).

	*/

	// DTNT - Date of Note
	if ln.dtnt="" set ln.dtnt=ln.odd
	else  if ln.mdt,ln.odt>ln.mdt do Runtime.setErrMSG("LN",1681) quit:ER	
	// abv - 48460 - check dates only for loans which have Maturity date
 	
	// DTNT - Date of Note
	if %ProcessMode'=2,ln.dtnt>ln.odd do {
		new odd,dtnt
		set odd=ln.odd 
		set dtnt=ln.dtnt
		if odd set odd=$$DAT^%ZM(odd)
		if dtnt set dtnt=$$DAT^%ZM(dtnt)
		// Disbursement date p1 precedes note date p2.  Change one or both values.
		do Runtime.setErrMSG("LN",1599,"odd~dtnt") quit:ER 
		}

	//ODD - Original Disbursement Date
	
	// "Billing precedes disbursement date" 
	if ln.odd>ln.dist1nd do Runtime.setErrMSG("LN",354) quit:ER 

	quit

vau54 // Trigger AU_PAYOFFLKO - After update- payoff lockout parameters

	type public RecordLN ln

 	/*
 	NOTE: This logic was formerly in LNPO1.m. This trigger maintains the 
 	      Payoff Lockout Dayend exception file LNPOLOE ("POLOE" DAYEND) 
 	      table. The PAYLKTO index on LN will in turn maintain "POLO" 
 	      DAYEND enries.
 	
 	Revision History
 	
 	05/12/06 - SANTHUMS - CR 21227
 		   Modified to check NOT NULL conditions for the columns
 		   prodctl.plmdr,prodctl.plmpr.
 		   
 	03/16/06 - Mugilvannan - CR 20019
 		   . Modified Percentage difference by multipying with 100 to
 		     get the correct percentage.
 		     
 	02/27/06 - SmithCD / Mugil - CR 19740
 		   . Modified to only maintain LNPOLOE records using 
 		     %SystemDate (as original code did in LNPO1.m) to prevent 
 		     "Insufficient Values" error when lnpoloe.paylkto was null
 		   . Added PAYLKFRM and PAYLKTO to the list of column names 
 		     associated with the UPDATE action on the control page
 		   . Used POAM variable instead of referencing ln.poamt 
 		     multiple times for efficiency (ln.poamt is a computed 
 		     column)
 		   . Corrected other logic errors, and simplified code
							 
								06/06/05 - Carol Scott - CR 15816
        	   Modify Db.delete statement.
        	
	05/10/05 - Carol Scott - CR 15816
		   Added trigger.
	
	*/
							 
								type public Cache %CACHE()

	type Number DIFFD, DIFFP, POAM
	type Boolean OVER = 0

	set POAM = ln.poam

	// Difference between Calculated and Entered (absolute value)
	set DIFFD = POAM - ln.paylkamt
	if DIFFD < 0 set DIFFD = -DIFFD

	// Percentage difference 
	if POAM set DIFFP = (DIFFD / POAM)*100
	else  set DIFFP = 0

								//Check limits in product file
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:ln.type")

	// Flag overages if no limits
  	if prodctl.plmdr.isNull(), prodctl.plmpr.isNull() set OVER = (DIFFD '= 0)
  	
	// Payoff Lockout - Min $ Diff To Report
	else  if 'prodctl.plmdr.isNull() set OVER = (DIFFD '< prodctl.plmdr)
	// Payoff Lockout - Min % Diff To Report
	else  if 'prodctl.plmpr.isNull() set OVER = (DIFFP '< prodctl.plmpr)

	// No overage - delete exception file that may exist for current date, 
	// user ID, and account number
	if 'OVER do Db.delete("LNPOLOE", "EFD=:%SystemDate AND CID=:ln.cid") quit

	// There is an overage - add / overwrite exception file for current 
	// date, user ID, account number
	type RecordLNPOLOE lnpoloe = Db.getRecord("LNPOLOE", "EFD=:%SystemDate,%UID=:%UserID,CID=:ln.cid", 1)

	set lnpoloe.polo = ln.paylkamt
	set lnpoloe.posc = POAM
	set lnpoloe.paylkfrm = ln.paylkfrm
	set lnpoloe.paylkto = ln.paylkto

	do lnpoloe.bypassSave()
	
	quit			

vau55 // Trigger AU_PCHM - After Update - Payment Change Method

	type public RecordLN ln
	/* ---- Revision History -------------------------------------------------
	
								11/19/02 - APPLEYARDM - CR 1729/ARQ 50943
																Created trigger to ensure that payment change method
																cannot be updated unless all required data items are
																defined.
	*/
	
	if ln.pchm=2!(ln.pchm=3) do { quit:ER
	
								// Error message "Required if payment change method equals 2 or 3"
								if ln.ppinc="" do Runtime.setErrSTBLER("PRODDFTL","LNGPMREQ") quit:ER
								if ln.numch="" do Runtime.setErrSTBLER("PRODDFTL","LNGPMREQ") quit:ER
								if ln.caf="" do Runtime.setErrSTBLER("PRODDFTL","LNGPMREQ") quit:ER
								}
	
	
	quit

vau56 // Trigger AU_PCM_INFO - AU AMBAS, ONP, PCM, and RPP

	type public RecordLN ln
 	/*
								---------- Revision History ------------------------------------------
	05/10/05 - Carol Scott - CR 15816
		   Remove the crcd parameter from the call to LNFUNCS.
		   It only requires the type parameter.
	
	01/29/04 - CARROLLJ - CR7997
		   Removed dead code.

	09/19/00 - YENDAPALLIS - 39372
		   Added an integrity check for invalid combinations of
		   interest determination point (IDP) and Payment calculation
		   method (PCM). 

	10/13/00 - LEVINTOLR - 40358
																			Added XBAD Error Message checks on the LN.PIIND and LN.PMRO

	*/
	
	
	if (ln.onp.oldVal'=ln.onp)!(ln.ambas.oldVal'=ln.ambas) do { quit:ER 
		new cnt
		// Commitment
		if ln.cpf quit

		// Non-amortizing
		if '$E(ln.pcmval)
		if 'ln.mdt!'ln.trm quit 

		// Original # Pmts Inconsistent with Term of Loan
		if 'ln.onp do Runtime.setErrXBAD("LN",136,"ONP",0) quit 
		if ln.dist1fre="" quit 

		// Only matters for variable pmts
		if ln.pcfre=""!'ln.pcoff quit
		if ln.dist1fre="*" set cnt=$$DATECNT^LNFUNCS(ln.cid)
		else  do { quit:ER 
			new af,njd
			set njd=$$NJD^UFRE(ln.dfp,"-"_ln.dist1fre,.af) quit:ER
			set cnt=$J(((ln.mdt-njd)/365)*af,0,0)
			}
		// Original # Pmts Inconsistent with Term of Loan
		if ln.onp'=cnt do Runtime.setErrXBAD("LN",136,"ONP",cnt) quit:ER 

		// Origin. # PMTS inconsistent with Amort Base # PMT
		if ln.onp>ln.ambas do Runtime.setErrXBAD("LN",168,"ONP",ln.onp,ln.ambas) quit:ER 
		}
	
	if (ln.pcm.oldVal'=ln.pcm)!(ln.rpp.oldVal'=ln.rpp) do { quit:ER 
		// PAYMENT CALC METHOD Requires Missing Payment Plan
		if ln.rpp="",$E(ln.pcmval,3)=4!($E(ln.pcmval,3)=5) do Runtime.setErrXBAD("LN",52) quit:ER 
		}
	
	if $E(ln.pcmval),'ln.onp!'ln.ambas do { quit:ER 
		if $$FBP^LNFUNCS(ln.type)=2,ln.dfp>%SystemDate quit 

		// Payment Meth Requires "Number of Payments" Fields
		do Runtime.setErrXBAD("LN",9) quit:ER 
		}
	
	/*
	Int Determ Point Invalid for Pmt Calc Method
	These types of loans should have their interest calculated at billing
	*/
	if ln.idp=1,($E(ln.pcmval,2)>0)!($E(ln.pcmval,3)>2) do Runtime.setErrXBAD("LN",127) quit:ER

	// Pmt/Mat Recalculation Opt can only be used with P&I loans
								// Only for a P&I loans
								if 'ln.piind,ln.pmro>0 do Runtime.setErrXBAD("LN",236) quit:ER
	quit

vau57 // Trigger AU_PMRO - After Update Pmt/Mat Recalculation Opt

	type public RecordLN ln
	/*
								---------- Revision History ------------------------------------------
	
	01/28/04 - CARROLLJ - CR7997
		   Removed dead code.

															10/13/00 - LEVINTOLR - 40358
																			Added XBAD Error Message checks on the LN.PIIND and LN.PMRO
	
								*/



  	 // Pmt/Mat Recalculation Opt can only be used with P&I loans
 	 // Only for a P&I loans
  	 if 'ln.piind,ln.pmro>0 do Runtime.setErrXBAD("LN",236) quit:ER
	 
	 quit

vau58 // Trigger AU_PMT - After Update PMT

	type public RecordLN ln
		/*
								---- Revision History---------------------------------------------------
	
								04/19/02 - JERUCHIMC - 49370
               	   Created this trigger to update the coupon book if the
		   current payment LN.PMT is changing for today.  This
		   happens, for example, if a cycled item is addded to the
		   loan. In this case, the payment change requires updating
	           the coupon book.  For this change, we are only concerned
		   about updating the coupon book for today, for a new account
																			coupon book method.

								*/
	
	new XPMT,XTJD
	set XTJD=%SystemDate,XPMT=ln.pmt
 	if Db.isDefined("LNCPN","XTJD,3,CID"),ln.cbmet do Db.update("LNCPN","TPT=:XPMT","PND=:XTJD AND PMET=3 AND CID=:CID") 
	quit

vau59 // Trigger AU_PMTCHG_INFO - After Update Payment Change Info

	type public RecordLN ln
	if (ln.pcfre.oldVal'=ln.pcfre),ln.pcfre'="" do { quit:ER 

		// Only P&I loans may use payment change frequencies
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINAPF") quit:ER 

		// Pmt Calc Meth Indicates No Pmt Change Freq
		if $E(ln.pcmval,3)=2 do Runtime.setErrXBAD("LN",126) quit:ER 

		// Interest Offset required when payment change frequency contains data
		if ln.intoff="" do Runtime.setErrXBAD("LN","PCFRE") quit:ER 
	
		// Check against master frequency
		// D PCFREF^LNPPC3(LN.INTFRE,LN.DIST1ND,LN.DIST1FRE,LN.PCHM,LN.INTFRE,LN.ICHND)
		do PCFREF^LNPPC3(ln.pcfre,ln.dist1nd,ln.dist1fre,ln.pchm,ln.intfre,ln.ichnd)
		if $G(ER) do Runtime.setErrSTBLER("LN",ET) quit:ER 
		}
	
	if (ln.pchnd.oldVal'=ln.pchnd),ln.pchnd do { quit:ER 

		// Only P&I loans may have payment change next dates
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINAPD") quit:ER 

		// NEXT PAYMENT CHANGE DATE in the Past
		if ln.pchnd'>%SystemDate do Runtime.setErrXBAD("LN",79) quit:ER 
	
		// Check against master frequency
		do PCHNDF^LNPPC3(ln.pchnd,ln.dist1nd,ln.intfre,ln.pcfre,ln.ichnd,ln.dist1fre,ln.pchm)
		if $G(ER) do Runtime.setErrSTBLER("LN","NPINAPD") quit:ER 
		}
	
	// NEXT PAYMENT CHANGE DATE in the Past
	if ln.pchnd'>%SystemDate do Runtime.setErrXBAD("LN",79) quit:ER 
	
	// Check that LNPTCHG is set up for correct dates
	set jd=ln.pchnd
	if jd'="" for  quit:jd-ln.pcoff>%SystemDate  do { quit:ER 
		// P&I Change Offset in Past, No New P&I Calculated
		if 'Db.isDefined("LNPTCHG","jd,ln.cid") do Runtime.setErrXBAD("LN",63) quit:ER 
		set jd=$$NJD^UFRE(jd,ln.pcfre) quit:ER
		}
	quit

vau60 // Trigger AU_PMTDIST - After update payment distribution

	type public RecordLN ln
	/*
	If PMTDIST changes, in order or elements, must change bill files,
	LNBIL0 and LNBIL1 to reflect the change.  Note that dropping elements
	is an error
	
	NOTE:  The code in PMTDIST^LNFUNCS should eventually be embedded here
		using SQL.
	*/

	do PMTDIST^LNFUNCS(ln.cid,ln.pmtdist,ln.pmtdistf)
	quit

vau61 // Trigger AU_PMTMIN - After update minimum payment amount

	type public RecordLN ln
	// Minimum payment amount requires principal in string
	if ln.pmtmin,"-"_ln.pmtdist_"-"'["-P-" do Runtime.setErrSTBLER("LN","PMTMIN") quit:ER 
	quit
	

vau62 // Trigger AU_PPDCAT - After update payment due categories

	type public RecordLN ln
	/*
	PPDCAT1-PPDCAT10 - Payment Due Categories
	If any category changes, check them all.  See same code in AFTER_INSERT
	Note:  PPDCAT may look like I-v-ESC3-v-P-v
		Bill file payment element order would be -
		|I...|ESC1...|ESC2...|ESC3...|P...
	First get payment elements from bill file (LNBIL0) in order
	*/


	new element,i,j,k,num,pe,pmtelem,ppdcat
	// Get payment elements
	do PMTELEM^LNFUNCS(ln.cid,.pmtelem) 
	
	// Get valid payment due categories
	set ppdcat(1)=ln.ppdcat1 
	set ppdcat(2)=ln.ppdcat2 
	set ppdcat(3)=ln.ppdcat3
	set ppdcat(4)=ln.ppdcat4 
	set ppdcat(5)=ln.ppdcat5 
	set ppdcat(6)=ln.ppdcat6
	set ppdcat(7)=ln.ppdcat7 
	set ppdcat(8)=ln.ppdcat8 
	set ppdcat(9)=ln.ppdcat9
	set ppdcat(10)=ln.ppdcat10
	
	// Check validity against payment element order
	for i=1:1:ln.npc do { quit:ER 
		set ppdcat="-"_ppdcat(i)_"-"
		// Payment element sequence
		set pe=0                   
		for j=2:2 set element=$P(ppdcat,"-",j) quit:element=""  do { quit:ER 
			set num=0
			// If escrow, get number
			if $$FEEPLN^LNU(element)="" do { 
				for k=$L(element):-1:1 quit:$E(element,k)'?1N 
				set num=+$E(element,k+1,99)
				}
			if '$G(num) set num=1
			set pe=pe+num

			// Account payment string inconsistent with bills
			if $P(pmtelem(pe),"#",1)'=element do Runtime.setErrXBAD("LN",37) quit:ER 
			}
		}
	quit:ER 
	quit

vau63 // Trigger AU_PRAMTCID - After Update Principal Amt Target Acct

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	      Cleaned up to comply with DBI standards. 
	*/ 

	type public Boolean ER

	// Principal Amt Target Acct & Principal Amount at Payoff must both be defined
	if (ln.pramt="") , (ln.pramtcid'="") do Runtime.setErrMSG("LN","4291") quit:ER
	if (ln.pramt'="") , (ln.pramtcid="") do Runtime.setErrMSG("LN","4291") quit:ER
	
	quit

vau64 // Trigger AU_PRCNTCID - After Update Percent at Payoff Trgt Acct

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	      Cleaned up to comply with DBI standards. 
	*/

	type public Boolean ER

	// Percent at Payoff Target Account and Percent at Payoff must both be defined
	if (ln.prcntap="") , (ln.prcntcid'="") do Runtime.setErrMSG("LN","4292") quit:ER
	if (ln.prcntap'="") , (ln.prcntcid="") do Runtime.setErrMSG("LN","4292") quit:ER

	quit

vau65 // Trigger AU_PTSP - After update capitalized points flag

	type public RecordLN ln
	// Net deferred fee data does not exist
	if ln.ptsp,'Db.isDefined("LNCYCPTS","ln.cid,'PTS'") do Runtime.setErrXBAD("LN",36) quit:ER 
	if 'ln.ptsp,Db.isDefined("LNCYCPTS","ln.cid,'PTS'") do Runtime.setErrXBAD("LN",36) quit:ER 
	quit
	

vau66 // Trigger AU_RAFRE - After update re-amoritzation frequency

	type public RecordLN ln
	if ln.rafre'="" do { quit:ER 
		// Only P&I loans may use reamortization frequencies
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINARF") quit:ER 
	
		// Check against master frequency
		do RAFREF^LNPPC3(ln.rafre,ln.dist1nd,ln.dist1fre,ln.pcfre,ln.pchnd) quit:ER 
		}
	quit

vau67 // Trigger AU_RAND - After update re-amortization next date

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	        Cleaned up to comply with DBI standards. 

	01/21/04 spier 7985
		correct oldVal reference which did not compile
		when on the OLDRAND instantion line
			
	12/22/03 Spier 7501
		Added code to create a new DAYENDRAND record as well as delete
		the old one when it exists. This is similar to a index except 
		that some processing requires that two entries exist.
	*/

	type public Boolean ER

	if ln.rand do { quit:ER 

		// Only P&I loans may have reamortization next dates
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINARD") quit:ER 
	
		// NEXT RE-AMORTIZATION DATE in the Past
		if ln.rand<%SystemDate do Runtime.setErrXBAD("LN",78) quit:ER 
	
		// Check against master frequency
		do PCFREF^LNPPC3(ln.rand,ln.dist1nd,ln.intfre,ln.rafre,ln.ichnd,ln.dist1fre,ln.pchm) quit:ER 
		
		type RecordDAYENDRAND rand=Class.new("RecordDAYENDRAND","RAND=:ln.rand,CID=:ln.cid")
		do rand.bypassSave()
		}

	type Date OLDRAND=ln.rand.oldVal
	type Number CID=ln.cid

	if OLDRAND do Db.delete("DAYENDRAND","RAND=:OLDRAND AND CID=:CID")
	
	quit

vau68 // Trigger AU_RDT - After Update Return Date

	type public RecordLN ln
	new CAL,RD
	set RD=ln.rdt
	if RD="" quit
	set CAL=ln.nbdc
	if CAL="" set CAL="IBS"
	if '$$BD^UNBD(RD,CAL) do Runtime.setErrXBAD("LN","RDTBUS") quit 
	if RD'>%SystemDate do Runtime.setErrXBAD("LN","RDTASD") quit 
	if ln.rnoff="" do Runtime.setErrXBAD("LN","RDROFF") quit 
	quit

vau69 // Trigger AU_RENCD_TRACN - AU Maturity Renewal Code & Transfer Acct

	type public RecordLN ln

	/*
	-----Revision History---------------------------------------------------
	03/28/05 - ALAGARSS - CR 20329
		   Modified the condition prodctl.fbp=2 from prodctl.fbp'=2.
		   
	05/20/05 - MBUIM - CR15982
		   Modified to remove deprecated feature Db.getOneRow and clean
		   up some PSL code.
	*/
	
	type Number TYPE

	set TYPE=ln.type
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
	
	if ln.tracn'="" do { quit:ER 
		// Transfer account not allowed for this maturity option.
		if ln.rencd=0!(ln.rencd=4) do Runtime.setErrXBAD("LN","MATOPT") quit 
		
		// For maturity option #1C,#2C,#3C Transfer account must be a loan account
		
		type Number YTRACN
		
		set YTRACN=ln.tracn
		
		type RecordACN acn=Db.getRecord("ACN","CID=:YTRACN")
		
		// Transfer account must be a loan account
		if ((ln.rencd="1C")!(ln.rencd="2C")!(ln.rencd="3C")),(acn.cls'="L") do Runtime.setErrSTBLER("LN","TRACN2") quit:ER
		}
	if ln.tracn="" do { quit:ER 
		// Maturity Option Requires Transfer Account
		if ln.rencd=1!(ln.rencd=2)!(ln.rencd=3) do Runtime.setErrXBAD("LN",110) quit 

		// Fixed Bullet Product Option Requires Transfer Acct
		if prodctl.fbp=2 do Runtime.setErrXBAD("LN",154) quit:ER
		}
	else  if prodctl.fbp=2 do { quit:ER 
	
		type Number XTRACN

		// Maturity Option Requires Transfer Account
		if 'ln.ccl do Runtime.setErrXBAD("LN",110) quit 
		
		set XTRACN=ln.tracn
		
		type RecordLN ln2=Db.getRecord("LN","CID=:XTRACN")
		
		// Transfer Account Requires Same Payment Frequency
		if ln.dist1fre'=ln2.dist1fre do Runtime.setErrXBAD("LN",33) quit:ER 

		// Transfer Account Requires Same Pmt Calc Method
		if ln.pcm'=ln2.pcm do Runtime.setErrXBAD("LN",34) quit:ER 

		// Pmt dates must start on or after variable loan pmts
		if ln.dfp<ln2.dfp do Runtime.setErrXBAD("LN",514) quit:ER 
		}
	quit

vau70 // Trigger AU_RND_ROPT - AU Escrow Elem to Round and Rounding Opt

	type public RecordLN ln
								/*
								---- Revision History---------------------------------------------------
							 
								02/18/00 - SIVCHUKA - 35604
																			Modify Loan Rounding Option. If Escrow Element to Round
																			([LN]RND) present,  Payment Rounding Option ([LN]ROPT)
																			must be=1. And if it's not=1-We sendin ErrMsg.
																			if ln.rnd'="",ln.ropt'=1 do Runtime.setErrXBAD("LN",533).  


								*/

	if ln.rnd'="",ln.ropt'=1 do Runtime.setErrXBAD("LN",533) quit //Sivchuka
	if ln.ropt'>1 do { quit:ER 
		new data,pe,pmtelem,rndesc,x,XESCCID

		do PMTELEM^LNFUNCS(ln.cid,.pmtelem)
		set pe=""
		for  set pe=$O(pmtelem(pe)) quit:pe=""  do {
			set x=pmtelem(pe)
			if ln.rnd=$P(x,"#",1) do {
				// Element to round
				set rndesc=$P(x,"#",1)   
				// Escrow account number
				set XESCCID=$P(x,"#",2)  
				}
			}
		// No escrow account
		if $G(XESCCID)="" quit

		// Loan Rounding Option Set, Escrow Unspecified
		if ln.rnd="" do Runtime.setErrXBAD("LN",112) quit 

		// "Escrow to Round" Account Invalid
		if $G(rndesc)="" do Runtime.setErrXBAD("LN",113) quit 
	
		// Acct does not exist
		if 'Db.isDefined("DEP","XESCCID") do Runtime.setErrXBAD("LN",113) quit

		set data=Db.getOneRow("STAT,ESPF","DEP","XESCCID")

		// Acct closed
		if $P(data,$C(9),1)=4 do Runtime.setErrXBAD("LN",113) quit

		// Acct is self pay
		if $P(data,$C(9),2)=1 do Runtime.setErrXBAD("LN",113) quit
		}
	quit

vau71 // Trigger AU_RSINTSPR_RSRNDMTD - After Update RSINTSPR or RSRNDMTD.

	type public RecordLN ln
	/*---------Revision History---------------------------------------------------
	08/29/00 - LUS - ARQ41547 
	Retrofitted change below:
								ORIG:LUS - ARQ38013 08/15/00
									Rate Schedule Interest Spread and Rounding Method Verification
	*/
	
	if ln.sch'="" do { quit:ER
								new X
								// INDEX2 - Invalid  offset syntax
								set X=ln.rsintspr
								do SPRPP^UINDX if ER do Runtime.setErrSTBLER("LN",ET) quit:ER
								// INDEX3 - Invalid rounding instruction
								set X=ln.rsrndmtd
								do RNDPP^UINDX if ER do Runtime.setErrSTBLER("LN",ET) quit:ER
								}
	quit

vau72 // Trigger AU_RSK_OPT - After Update Risk Analysis Option

	type public RecordLN ln
	/*
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.
	*/
	
	// RSKOPT - Risk Analysis Option
	type Public Boolean ER
	if ln.rskopt=1 do Runtime.setErrMSG("LN",3266) quit:ER 
	
	// After Update Trigger Checking group
	type String GRP
	type Number RSKOPT

	set RSKOPT=ln.rskopt
	type ResultSet rs=Db.select("GRP","ACN","CID=:CID")
	set GRP=rs.getCol("GRP")
	// Risk option ~p1 is invalid for product ~p2
	if GRP="CBL",RSKOPT do Runtime.setErrMSG("LN",3337,"RSKOPT~GRP") quit:ER 
	quit
	

vau73 // Trigger AU_RTRNINFO - After Update Return Info

	type public RecordLN ln
	new AO,CDT

	set CDT=ln.cnvdt

	//Return date requires return notification offset
	if ln.rdt'="",ln.rnoff="" do Runtime.setErrMSG("LN",3191) quit
	if ln.rdt'="" quit 
	if CDT=%SystemDate quit 
	
	new rs 
	type ResultSet rs=Db.select("ROSEQ","LNRENEW","CID=:CID AND CNVAPP=1") 
	if rs.isEmpty() quit
	set A0=rs.next(),AO=rs.getCol(1)
	
	
	if rs.getCol(1)'="",ln.rnoff'="" do Db.update("LN","RDT=:CDT","CID=:CID")
	quit

vau74 // Trigger AU_SDTA - After update scheduled disb target acct

	type public RecordLN ln
 	/*
	---- Revision History -------------------------------------------------
	
	03/30/05 - KinI - 14385
	      Cleaned up to comply with DBI standards. 

 	04/26/02 - VERTLIBA - 46419
	     Modified code to quit with an error message: "Disbursement
													Target account not active" if target account is closed (stat=4).
	     Also, added CRCD logic from the BU_SDTA trigger which will be
													deleted.
	*/

	type public Boolean ER

	if ln.sdta do { quit:ER

		type String CRCD
		set CRCD=ln.crcd
		if CRCD="" set CRCD=%SystemCurrency
		
		type RecordACN acn=Db.getRecord("ACN","CID=:ln.sdta")

		// Target account must be different from source account
		if ln.sdta=ln.cid do Runtime.setErrMSG("LN",2599) quit:ER

		// Currency code of target account must be consistent with 
		// source account
		if CRCD'=acn.crcd do Runtime.setErrMSG("LN",655) quit:ER

		// Disbursement Target account not active
		if acn.stat=4 do Runtime.setErrXBAD("LN",160) quit:ER

 		}
	quit

vau75 // Trigger AU_SEGMENTS - After Update of Segments Allowed

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------------
	
	05/31/07 - KUMARB - CR 27163
		Modified to check for errors related to Credit Card processing
		if Segments Allowed (LN.SEGMENTS) is selected.
	
	01/05/07 - KUMARB - CR24680
		Created new trigger
	*/
	
	type public Boolean ER
	
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do { quit:ER
			
			// Revolving Credit indicator must be set for segmented accounts
			if 'ln.revf do Runtime.setErrMSG("LN",6204) quit:ER
			
			// Disbursement Schedule Processing not allowed for segmented accounts
			if ln.dschpr do Runtime.setErrMSG("LN",6205) quit:ER
			
			// Multiple Distributions not allowed for segmented accounts
			if ln.mdf do Runtime.setErrMSG("LN",6206) quit:ER
			
			// Average Interest Recalculation not allowed for segmented accounts
			if ln.air do Runtime.setErrMSG("LN",6207) quit:ER
			
			// Cannot Advance Due Dates with Late Charge Payments for segmented accounts
			if ln.addlchg do Runtime.setErrMSG("LN",6211) quit:ER
			
			// Advances to Reduce Undisbursed balances not allowed for segmented accounts
			if ln.aruf do Runtime.setErrMSG("LN",6212) quit:ER
			
			// Loan Budget Processing not allowed for segmented accounts
			if ln.entf do Runtime.setErrMSG("LN",6213) quit:ER
					
			// Interest cannot be Collected in Advance for segmented accounts
			if ln.icm>0 do Runtime.setErrMSG("LN",6214) quit:ER
			
			// Construction Loan Processing not allowed for segmented accounts
			if ln.clps>0 do Runtime.setErrMSG("LN",6216) quit:ER
			
			// Segmented accounts cannot be saleable
			if ln.slbl=0 do Runtime.setErrMSG("LN",6217) quit:ER
			}
	#ENDIF
	
	// Change to column ~p1 not allowed
	if ln.isChanged("SEGMENTS") do Runtime.setErrMSG("LN",412,"LN.SEGMENTS") quit:ER
	
	quit

vau76 // Trigger AU_SFRE - Modify SFRE on group when SFRE modified

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------------
							01/17/01 - SCOTTC - 43455
																Added the call to UFRE to calculate the statement next date when
																the statement frequency is modified on the account.  This
																deviates from standard Profile practices due to the fact that
																when default statement frequencies are being used, and a freq
																changes and forces the creation of a new statement group, the
																statement next date will change. Same action by the user,
																different results.
	09/23/99 - SCOTTC 34881
		Changed SQLSELECT statement to see if more than one account in
		statement group to search in CMBSTM instead of CMBCID
	*/

	new CSTMGRP,XACN,XDESC,XSFRE,XADDR,XCID,XCMBGRP,XREST,XSFRE
	set XCID=ln.cid 
	set XACN=ln.acn
	
	// find existing statement group
	set CSTMGRP=Db.getOneRow("STMGRP","CMBCID","XCID,XACN")
	if CSTMGRP="" quit

	// find out if more than one account in statement group
	new rs 
	type ResultSet rs=Db.select("ACN","CMBSTM","STMGRP=:CSTMGRP AND ACN=:XACN AND CID<>:XCID") 
	if rs.isEmpty() quit
	set FNDGRP=rs.next(),FNDGRP=rs.getCol(1)
	
	
	//get information to pass to a new group
	if FNDGRP do { quit:ER 
		set XCMBGRP=Db.getOneRow("DESC,ADDR,REST,SFRE","CMBGRP","XACN,CSTMGRP")
		set XDESC=$P(XCMBGRP,$C(9),1) 
		set XADDR=$P(XCMBGRP,$C(9),2) 
		set XREST=$P(XCMBGRP,$C(9),3) 
		set XSFRE=$P(XCMBGRP,$C(9),4)
		if XSFRE'=ln.sfre do { quit:ER 
			// find last statement group for CID
			set NEWGRP=Db.nextVal("CMBGRP","XACN,STMGRP")

			// set new statement group number
			set XSFRE=ln.sfre
			if XADDR="" set XADDR=XCID
			do Db.insert("CMBSTM","ACN,STMGRP,CID",":XACN,:NEWGRP,:XCID")
			do Db.update("CMBSTM","STMGRP=:NEWGRP","ACN=:XACN AND CID=:XCID")
			}
		}

	if '(FNDGRP) do { quit:ER
		//Modify statement group's frequency
		set XSFRE=ln.sfre 
		set XACN=ln.acn
		new njd
		set njd=$$NJD^UFRE(Db.getOneRow("TJD","CUVAR"),XSFRE,.AF) quit:ER		
		do Db.update("CMBGRP","SFRE=:XSFRE,SNDT=:njd","STMGRP=:CSTMGRP AND ACN=:XACN")
		}
	quit 

vau77 // Trigger AU_SGNCRD - Signature Card Letter Processing

	type public RecordLN ln
	/*
	
	 05/18/05 - KELLYP - CR 15268
		Re-introduced this trigger since the XSGNCRD table cannot be
		populated by an index in DBI.  XSGNCRD is now handled as a 
		"calculated" table and its records are created/modified by
		the filers.
	*/


	// Remove any records from XSGNCRD with old signature card values
	do Db.delete("XSGNCRD","CID=:ln.cid")
	
	// If SGNCRD>0 AND PSGNCRDR'=1 track this account in XSGNCRD
	if ln.sgncrd>0,ln.psgncrdr'=1 do {
		type RecordXSGNCRD xsgncrd=Class.new("RecordXSGNCRD")
		set xsgncrd.sjd=%SystemDate
		set xsgncrd.sgncrd=ln.sgncrd
		set xsgncrd.osgncrdc=+ln.osgncrdc
		set xsgncrd.psgncrdr=+ln.psgncrdr
		set xsgncrd.cid=ln.cid
		do xsgncrd.bypassSave()
		}	

	quit

vau78 // Trigger AU_SMET - After Update statement flag

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------

	06/01/04 - KELLYP - CR 9670
		   Modified Db.delete call to use semicolons properly.

	*/	
	
	if ln.smet'=0 quit
	
	type String XACN,XCID,XSTMGRP

	set XCID=ln.cid
	
	type ResultSet rs=Db.select("STMGRP","CMBCID","CID=:XCID") 
	if rs.isEmpty() quit
	set XSTMGRP=rs.next(),XSTMGRP=rs.getCol(1)
	
	if XSTMGRP="" quit 
	set XACN=Db.getOneRow("ACN","LN","XCID")
	
	// Issue a delete to CMBSTM which will then delete CMBCID
	do Db.delete("CMBSTM","ACN=:XACN AND STMGRP=:XSTMGRP AND CID=:XCID")

	quit
	

vau79 // Trigger AU_SRCDT - After update Strike Rate Compare Date

	type public RecordLN ln
	/*
	 -- Revision History ------------------------------------------------
	 
	12/12/2005 - Sreeram Panyaram
		     Added Additional Check into the Error Condition. 	
	
	03/30/05 - KinI - 14385
	        Cleaned up to comply with DBI standards. 

	06/12/00 - RHINEHARTJ - 40586
		Added checks on Strike rate calendar and Strike rate comparative
 		date to make sure they are populated when Strike rate offset 
		has a value.
	*/

	type public Boolean ER
		
	// Strike rate offset requires strike rate compare date
	if ln.stroff,ln.srcdt.isNull() do Runtime.setErrMSG("LN",4359) quit:ER

	// Strike rate compare date cannot precede system date
	if ln.srcdt,ln.srcdt<%SystemDate do Runtime.setErrXBAD("LN","SRCDPSD") quit:ER 

	// Strike rate offset requires strike rate calendar
	if ln.stroff,ln.strcal.isNull() do Runtime.setErrMSG("LN",3198) quit:ER

	// Strike rate compare date must be a business date
	if '$$BD^UNBD(ln.srcdt,ln.strcal) do Runtime.setErrXBAD("LN","SRCDBUS") quit:ER 

	quit

vau80 // Trigger AU_STAT - AFTER UPDATE STAT

	type public RecordLN ln
	/*
	----- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
	           Cleaned up to comply with DBI standards. 

	03/18/99 - MOHAMEDE - 31429
		   Will create future dated entry in DAYENDAROD file if the
		   loan status becomes 4 (closed).
		   Also will remove DAYENDAROD entry if loan status changes from
		   status 4 to any other value.
	*/

	// When loan status becomes 4 (close), create a future dated DAYENAROD.

	type Number XCID=ln.cid
	type public Boolean ER

	if ln.stat=4 do { quit:ER  

		type Number XCOLL

		// COLTYP - Collateral Type
		type ResultSet rs=Db.select("COLL","LNCOL","CID=:ln.cid AND COLTYP=70")
		if rs.isEmpty() quit
		while rs.next() do { 
			set XCOLL=rs.getCol(1)
			
			type RecordCOL col
			set col=Db.getRecord("COL","COLL=:XCOLL")

			if 'col.avrsl quit 

			type RecordDAYENDAROD dayendarod=Class.new("RecordDAYENDAROD")

			set dayendarod.tjd=col.arod + %SystemDate
			set dayendarod.cid=XCID
			set dayendarod.coll=XCOLL

			do dayendarod.bypassSave()
			}
		}

	// Remove future dated DAYENDAROD entry.	
	if ln.stat.oldVal=4,ln.stat'=4 do { quit:ER   

		type Date XAROD
		set XAROD=%SystemDate-1

		do Db.delete("DAYENDAROD","CID=:XCID AND TJD>:XAROD")

		}
	quit

vau81 // Trigger AU_STRINFO - After Update Strike Rate Info

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	           Modified to comply with DBI standards. 
	*/

	if ln.stroff="" quit 

	// Strike Rate Compare Date
	if ln.srcdt="" do {

		type Number CID=ln.cid	
		type Date SCD
		
		set SCD=$$FINDATE^LNCDI(ln.cnvdt,ln.stroff,ln.strcal,ln.srcbind)
		
		do Db.update("LN","SRCDT=:SCD","CID=:CID")
		}
	quit

vau82 // Trigger AU_SUBSIDY - After update of Subsidy Values

	type public RecordLN ln

	/*
								---------------------- Revision History  --------------------------
 	03/16/06 - chhabris - CR19833
		   Added this trigger for keeping check on iam and idp.
	-------------------------------------------------------------------
	 
								*/

	// Subsidized Loans must have interest determined at billing
	if 'ln.subpln.isNull(),ln.idp do Runtime.setErrXBAD("LN",103) quit:ER 

	// Subsidized Loans cannot be Add-On or discount Loan
	if 'ln.subpln.isNull(),ln.iam do Runtime.setErrXBAD("LN",104) quit:ER
	
	quit

vau83 // Trigger AU_TEASER_INFO - After Update Teaser Rate Info

	type public RecordLN ln
	/*
	----Revision History----------------------------------------------------
	
	01/05/07 - KUMARB - CR24680
		   Modified trigger to return error message "Promotional Rate
		   processing not allowed for segmented accounts" if Segments
		   Allowed (LN.SEGMENTS) and Promotional Index (LN.PROIND),
		   Promotional Rate (LN.TRATE), or Promotional Rate  
		   Expiration Date (LN.TREXD) is defined.

	09/24/99 - ROYTENBERGE - 34627
		   Added code to return error message if Promotional Rate
		   Expiration Date is not greater than system date.
	*/


	// Teaser Expiration Date Exists without Teaser Rate
	if ln.trexd>%SystemDate,ln.trate="" do Runtime.setErrXBAD("LN",15) quit:ER 

	// Teaser Rate Exists without Expiration Date
	if ln.trate'="",ln.trexd="" do Runtime.setErrXBAD("LN",102) quit:ER 
	if ln.trexd'="",ln.trexd'>%SystemDate do Runtime.setErrMSG("LN",914,RM) quit 
	
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		// Promotional Rate processing not allowed for segmented accounts
		if (ln.segments),(('ln.proind.isNull())!('ln.trate.isNull())!('ln.trexd.isNull())) do Runtime.setErrMSG("LN",6181) quit:ER
	#ENDIF
	
	quit
	

vau84 // Trigger AU_TEB - After update total escrow balance

	type public RecordLN ln
	new data,escacr,escbal,pe,pmtelem,XESCCID
	do PMTELEM^LNFUNCS(ln.cid,.pmtelem)
	set pe="" set (escacr,escbal)=0
	for  set pe=$O(pmtelem(pe)) quit:pe=""  set XESCCID=$P(pmtelem(pe),"#",2) if XESCCID do { quit:ER 

		set data=Db.getOneRow("BAL,ACR","DEP","XESCCID")
		set escbal=escbal+$P(data,$C(9),1)
		set escacr=escacr+$P(data,$C(9),2)
		}
	// TOTAL ESCROW BALANCE Not Supported by Accounts
	if +ln.teb'=escbal do Runtime.setErrXBAD("LN",47,"TEB",ln.teb,escbal) quit:ER 

	// Account Status Flag of 1 with No Escrow Balance
	if ln.stat=1,'escbal&'escacr do Runtime.setErrXBAD("LN",131) quit:ER 

	quit

vau85 // Trigger AU_TITLE - After Update Title

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	03/13/06 - Srinivar -19975	
		   Added code to update the account TITLE changes 
		   in Escrow Account when any changes are done in 
		   associated Loan Account.
		   Modified the trigger to fetch the escrow cid 
		   using $$ECID^LNU instead of $$GETESC^ESCFUNCS.
		
	10/02/00 - LAMY - 42029
	           Added a check fo the Pledge account. If one does not
		   exist then quit.
	
	03/17/99 - FINCHG - 27393
		   Added check that loan title matches with any pledged deposit
		   accounts.
	

	If title has changed and loan account is secured by pledged account, tiltles
	between the pledged account and the loan account should be identical.
	*/
	
	type Number ECID
			 
	set ECID=$$ECID^LNU(CID,"ESC1")
	if ECID="" quit
	                
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")         
	if ln.title1'=ln.title1.oldVal set dep.title1=ln.title1         
	if ln.title2'=ln.title2.oldVal set dep.title2=ln.title2         
	if ln.title3'=ln.title3.oldVal set dep.title3=ln.title3         
	if ln.title4'=ln.title4.oldVal set dep.title4=ln.title4          
	do dep.bypassSave()  

	new XPLCID,XDEPO,XLNO
	set XLNO=ln.title1_$C(9)_ln.title2_$C(9)_ln.title3_$C(9)_ln.title4
	new rs 
	type ResultSet rs=Db.select("PLDGACN","LNCOL","LNCOL.CID=:CID")
	if rs.isEmpty() quit
	while rs.next() do { quit:ER  
		set XPLCID=rs.getCol(1)
		if XPLCID="" quit  // no pledged account
		set XDEPO=Db.getOneRow("TITLE1,TITLE2,TITLE3,TITLE4","DEP","XPLCID")
		// "Pledged account owners not owners of loan account"
		if XDEPO'=XLNO do Runtime.setErrXBAD("LN","PCIF") quit:ER    
		}
	quit

vau86 // Trigger AU_TYPE - After update type

	type public RecordLN ln
	/*
	---------- Revision History ------------------------------------------
	
	07/05/07 - VanithaK - CR28007
		   Modified the changes made for CR 27879 to include a test
		   case when Region code starts with zero.
	
	06/28/07 - VanithaK - CR27879
	   	   Added validation for Branch of Ownership when bankid is 
	   	   defined.

	03/30/05 - KinI - 14385
	      	   Modified to comply with DBI standards. 
	
	03/10/03 - Allan Mattson - 51351
	           Removed calls to ^CFMAIN (Cash Flow obsoleted in V7.0).

	02/04/99 - KONGJ - 30071
		   Changed table name from PRODDFTC to PRODCTL for INTYPRST.
	
	12/23/98 - KONGJ - 30071
		   Changed CIFTYP.INTYPRST to PRODDFTC.INTYPRST.
	
	11/18/98 - KONGJ - 30071
		   Added check to verify a valid combination of customer type,
		   institution type and account type during account maintenance.
	
	*/

	type Number OTYPE
	type Date ZDATE
	type public Boolean ER

	set OTYPE=ln.type.oldVal

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")	

	set ZDATE=%SystemDate-prodctl.blpsav

	// Product class cannot be changed
	if ln.cls.oldVal'=ln.cls do Runtime.setErrXBAD("LN",178) quit:ER 

	// Distinct processing parameters prohibit product transfer
	if ln.trb.oldVal'=ln.trb do Runtime.setErrXBAD("LN",180) quit:ER 

	// Move contents of bill print file
	type ResultSet rs=Db.select("BILDT","LNBLP","BILDT>:ZDATE AND TYPE=:OTYPE AND CID=:ln.cid")
	if 'rs.isEmpty() while rs.next() do {
	
		type Date BILDT

		set BILDT=rs.getCol("BILDT")	

		type RecordLNBLP lnblp
		set lnblp=Db.getRecord("LNBLP","BILDT=:BILDT,TYPE=:OTYPE,CID=:ln.cid")
		set lnblp.type=ln.type
		
		do lnblp.save()
		}

	// Check Institution Type Restriction at account maintenance

	type RecordCIF cif
	set cif=Db.getRecord("CIF","ACN=:ln.acn")

	// Check for Institution Type Restriction.
	if cif.intype'="" do { quit:ER 
		
		type RecordPRODCTL prodctl1
		set prodctl1=Db.getRecord("PRODCTL","TYPE=:cif.type")
	
		// Check the user table UTBLINTTBL for a valid combination.
		if prodctl1.intyprst do { quit:ER 

			if Db.isDefined("UTBLINTTBL","CIFTYPE=:cif.type,INTYPE=:cif.intype,TYPE=:ln.type") quit 

			// Product not valid for Institution Type
			do Runtime.setErrXBAD("LN","INTYPRST") quit:ER 
			}
		}
			
	// Region Code must be three numbers
	if prodctl.iftanpro = "IFTAN" do { quit:ER
		
		type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD","BRCD=:ln.boo",1)
		type Number I
		type String CH, REGION
		
		if utblbrcd.region.length()'=3 do Runtime.setErrMSG("UTBLBRCD",6198) quit
		
		set REGION=""
		
		for I=1:1:utblbrcd.region.length() do { quit:ER
			set CH = utblbrcd.region.extract(I)
			if CH'="0" set REGION=REGION_CH
		}
		
		if 'REGION.isNumber() do Runtime.setErrMSG("UTBLBRCD",6198) quit
	}
	
	quit

vau87 // Trigger AU_UDBAL_INFO - After udpate unadvanced balance info

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 
	
	04/10/03 - CARROLLJ - 51349
		   Modified call to BALINT^LNFUNCS to only pass ln object and 
		   removed the use of the data array.

	08/15/02 - CARROLLJ - 43583
		   Modified calls to LNCL1 tp pass the ln object and also
		   removed getoneRow's.
	*/
	
	type public Boolean ER
	type Number TAMT
	
	if ln.aruf do { quit:ER
		// Change revolving flag when undisbursed processing is used
		if ln.cpf do { quit                
			
			// Modify the available credit by the total principal 
			// repaid within all linked non-revolving loans.
			
			type Number NCID
			
			set TAMT=0
			
			// Get each linked loan and add principal repaid
	
			type ResultSet rs=Db.select("CID","LN","CCL=:ln.cid") quit:ER 
			if rs.isEmpty() quit
			while rs.next() do { quit:ER  

				set NCID=rs.getCol(1)
				
				Type RecordLN ln1=Db.getRecord("LN","CID=:NCID")
				
				set TAMT=TAMT+ln1.prnrpd
				}
		
			// Increase available commitment if changed to 
			// revolving, otherwise decrease.

			if TAMT do {
				if 'ln.revf set TAMT=-TAMT
				
				do TTX^LNCL1(.ln)  // Post transaction
				}
			}
	
		// Update BAL and UDBAL by total principal repaid.
		// If REVF is changed to "Y", then increase.  Else decrease.

		set TAMT=ln.prnrpd

		if 'TAMT quit 

		if 'ln.revf set TAMT=-TAMT

		do TTX^LNCL1(.ln)
	
		/*
		The account has been processed.  Now check to see if there is
		a controlling commitment.  If so, then either increase or decrease
		BAL and UDBAL on the commitment.
		*/

		set TAMT=-TAMT
		
		if 'ln.ccl quit      // No controlling commitment       
		
		if 'ln.revf quit     // Commitment is non-revolving        

		do TTX^LNCL1(.ln)
		}
	
	else  do {
		// Modify revolving flag when account does not use undisbursed processing

		set TAMT=ln.prnrpd
		if 'ln.revf set TAMT=-TAMT
	
		if 'TAMT quit 

		set TAMT=-TAMT
		
		// Post transaction to commitment
		if ln.ccl do {                   
			
			Type RecordLN ln2=Db.getRecord("LN","CID=:ln.ccl")
			
			if 'ln2.revf quit	// Not revolving
			
			do TTX^LNCL1(.ln2)
			}
		}
	
	if (ln.balint.oldVal'=ln.balint) ! (ln.udbal.oldVal'=ln.udbal) ! (ln.icpa.oldVal'=ln.icpa) do { quit:ER 
		type Number BALINT
		set BALINT=$$BALINT^LNFUNCS(.ln)

		// Balance for Interest Calculation not supported
		if (+ln.balint '= +BALINT) do Runtime.setErrXBAD("LN",43,"BALINT",ln.balint,BALINT) quit:ER 
		}
	
	// Debit/Credit Balance cannot be defined for rev accts
	if (ln.revf) , (ln.dbt!ln.cbt) do Runtime.setErrXBAD("LN",528) quit:ER 
	
	quit

vau88 // Trigger AU_VATINTOPT - After Update of VATINTOPT

	type public RecordLN ln
	/*
	----Revision History---------------------------------------------------
		
	03/16/07 - PUTTASWH - CR 24945
		   Added the trigger to validate for LN.VATINTOPT to 2
		   if data is present in LN.BILINFLCALIN for VAT processing.

	*/
	
	// VAT on interest calculation option must be 2 if billing inflation index defined
	if ('ln.bilinflcalin.isNull())&(ln.vatintopt'=2) do Runtime.setErrMSG("LN",6186) quit:ER 
		
	quit

vau89 // Trigger AU_WDLMT - After update withdrawal limit (WDLMT)

	type public RecordLN ln
	/*
	---- Revision History---------------------------------------------------

	05/10/00 - ANTONOVV - 39845
		Created this trigger to check if the withdrawal limit (WDLMT) is
		higher than the credit limit (CRLMT).
	*/

	// WDLMT(Withdrawal Limit) cannot be greater than CRLMT(Credit Limit)
	if ln.wdlmt'="",ln.wdlmt>ln.crlmt do Runtime.setErrMSG("LN",4191) quit:ER

	quit

vau90 // Trigger AU_WDLMTP - After Update Withdrawal Limit Processing

	type public RecordLN ln
	/*-----Revision History------------------------------------------------
	 05/15/06 - NATRAJAH - 21189	 	    
	 	    Modified the if codition to restrict the system date in 
	 	    "Next Reduction Date" field	 	   
	 	    
	 12/27/00 - RAJARAMD - 42288
		    Added Error messages for the following conditions:
		    1) LN.PBFRE is defined and LN.PBNXTDT is not defined.
		    2) LN.PBNXTDT is defined and LN.PBFRE is not defined.
		    3) LN.COLLIMPR and LN.WDLMTP are both enabled.
		    4) LN.ADJCOL is enabled and LN.COLLIMPR is disabled.
	*/

	// Next withdrawal reduction date on or before the system date
	if ln.wdnd'="",ln.wdnd'>%SystemDate do Runtime.setErrXBAD("LN",524) quit:ER 
	
	// Withdrawal limit frequency requires next withdrawal limit reduction date
	if ln.wdfre'="",ln.wdnd="" do Runtime.setErrXBAD("LN",525) quit:ER 

	// Penalty Balance Next Cutoff Date required
	if ln.pbfre,('ln.pbnxtdt) do Runtime.setErrMSG("LN",4650) quit:ER
	
	// Penalty Balance Review Frequency required
	if ln.pbnxtdt,('ln.pbfre) do Runtime.setErrMSG("LN",4649) quit:ER

	/*
	   Cannot use processing for both Collateral Credit Limit and Loan
	   Withdrawal Limit
	*/
	if ln.collimpr,ln.wdlmtp do Runtime.setErrMSG("LN",4648) quit:ER
	
	/*
	   Adjust Collateral Credit Limit cannot be enabled if Collateral
	   Credit Limit Processing is disabled
	*/
	if ln.adjcol,('ln.collimpr) do Runtime.setErrMSG("LN",4656) quit:ER	
	quit

vau91 // Trigger AU_WRKDTE - After Update Work Date

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
		
	03/21/07 - RengaSP - 25969
																			Modified to process next record in the result set.
	
	11/11/05 - SATYANAS -18007
		   Converted the code to PSL Standards.
	
	06/03/99 - HILLANBRAND - ARQ33064
		   Added new trigger AU_WRKDTE for Collection Queue
	*/

	type public Boolean ER
	type public Number CID
	
	// Update worked in Collection Report File
	
	type ResultSet rs=Db.select("QUEUE,CLS,WRKED","QCOLLREP","CID=:CID") 
	if 'rs.next() quit
	
	if 'rs.getCol(3),('rs.getCol(1).isNull()) do { quit:ER
		
		type RecordQCOLLREP qcollrep=Db.getRecord("QCOLLREP","CID=:CID,CLS=:rs.getCol(2),QUEUE=:rs.getCol(1)",1)
		if qcollrep.getMode() do {
			set qcollrep.wrked=1
			do qcollrep.save()
			}
		}	
		
	quit
	

vbd1 // Trigger BEFORE_DELETE - Before delete trigger

	type public RecordLN ln
								/*
								---- Revision History -----------------------------------------------

	03/09/06 - KELLYP - CR 19958
		   Modified to remove the third parameter from the call to 
		   REMOVE^PROCEFT.  Also removed pre-2003 revision history.

								02/05/04 - Erik Scheetz - CR7501
        	   Removed call to LNPURGU.  This functionality has been
        	   removed from profile04 and is expected to be replaced with
        	   a database independent version.  
	
								*/

	type public Boolean ER

	// Delete escrow accounts
	do DELESC^ESCFUNCS(ln.cid)

	// Delete EFT's	
	do REMOVE^PROCEFT(ln.cid,%SystemDate)

	// Delete RELCIF entries for this account
								do Db.delete("RELCIF","CID=:ln.cid AND ACN=:ln.acn") quit:ER
	do Db.delete("CMBSTM","CID=:ln.cid AND ACN=:ln.acn") quit:ER
	
	quit 

vbi1 // Trigger BEFORE_INSERT - Before Insert trigger

	type public RecordLN ln
								/*
								---- Revision History---------------------------------------------------
	
								04/03/00 - KELLYP - 37918
																			Moved all code and revision history comments from this
																			trigger into a new procedure, LNAI, to prevent compilation
																			errors caused by the LN filer being too large.  Changes to
																			the AFTER_INSERT trigger should now be made to the LNAI proc.
								*/
	
								do PROC^LNBI(.ln)       // All code moved to BEFORE_INSERT Procedure
								quit

vbu1 // Trigger BU_ACS - Before update accrual indicator

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("ACS","SYSTEM") do Runtime.setErrMSG("LN",412,"LN.ACS") quit:ER 
	quit
	

vbu2 // Trigger BU_ALPRTY - Before Update Automatic Loan Payment

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History--------------------------------------------------------
	
	03/19/99 - KUCHEROVSKYA - 49806
		   When an institution is in the middle of upgrading, the server may
		   on v6.2, some clients are on v62, and other  clients are on v61.
	*/


	if ln.alprty=1,('ln.alprtyd) set ln.alprtyd=999
	if 'ln.alprty set ln.alprtyd=""
	quit
	

vbu3 // Trigger BU_ALPRTYD - Before Update Auto Payment Retry Days

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	03/19/99 - KUCHEROVSKYA - 49806
		   When an institution is in the middle of upgrading, the server may
		   on v6.2, some clients are on v62, and other  clients are on v61.
	*/

	if ln.alprtyd>0 set ln.alprty=1
	else  set ln.alprty=0
	quit
	

vbu4 // Trigger BU_ANOFFDT - Before update pmt change offset date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("ANOFFDT","SYSTEM") do Runtime.setErrMSG("LN",412,"LN.ANOFFDT") quit:ER 
	quit
	

vbu5 // Trigger BU_APCND - Before update analysis payment next date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// If old change date, move to new date
	if (ln.apcnd.oldVal'=ln.apcnd),ln.apcnd.oldVal do {
		new APCND,CID,NAPCND
		set APCND=ln.apcnd.oldVal
		set CID=ln.cid
		if 'Db.isDefined("LNAPCHG","APCND,CID") quit
		set NAPCND=ln.apcnd
		do Db.update("LNAPCHG","APCND=:NAPCND","CID=:CID AND APCND=:APCND")
		}
	
	// Calculate new value for Payment Change Analysis Offset Date
	if 'ln.apcnd set ln.anoffdt.journal=0,ln.anoffdt=""
	else  set ln.anoffdt.journal=0,ln.anoffdt=ln.apcnd-ln.anoff
	quit

vbu6 // Trigger BU_APRMTHD - Before Update of the APRMTHD

	type public RecordLN ln
	do ln.setAuditFlag(1)
	new PAPRM,XTYPE
	set XTYPE=ln.type
	set PAPRM=Db.getOneRow("APRMTHD","PRODDFTL","XTYPE")

	// APR calc method must be consistent with the product type
	if PAPRM'=ln.aprmthd do Runtime.setErrXBAD("LN","526") quit:ER 
	quit
	

vbu7 // Trigger BU_ARUF - Before update advances to reduce undisb

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Undisbursed balance prohibits changes to undisbursed flag
	if ln.udbal>0 do Runtime.setErrSTBLER("LN","CNVARUF") quit:ER 
	
	// Changes to undisbursed processing prohibited on commitments
	if ln.cpf>0 do Runtime.setErrSTBLER("LN","CNVARUF2") quit:ER 
	quit
	

vbu8 // Trigger BU_BAMT - Before Update Balloon Amount Trigger

	type public RecordLN ln
	do ln.setAuditFlag(1)
								/*
								---- Revision History---------------------------------------------------
	41056 - KELLYP - 07/11/00
		Created this trigger.  Need to set payment term (LN.PTRM) equal
		to acount term (LN.TRM) when balloon amount (LN.BALLAMT) is
		defined. 
								*/

	// Set payment term = account term if balloon amount is declared
	if ln.ballamt'="" set ln.ptrm=ln.trm
	quit

vbu9 // Trigger BU_BLOFF - Before update billing offset

	type public RecordLN ln
	do ln.setAuditFlag(1)
	if ln.bloff="1P"!(ln.bloff?.N) do { quit:ER 
		if ln.bloff.oldVal="1P"!(ln.bloff="1P"),ln.schld'=%SystemDate do { quit:ER 
			// May not transfer from/to frequency "1P" on other than payment date
			do Runtime.setErrSTBLER("LN","LNBLOFF3") quit:ER 
			}
	
		// Determine whether or not change is allowed
		if '(ln.bloff="1P"!(ln.bloff.oldVal="1P")) do { quit:ER 
			// New billing offset must be greater than 0
			if ln.bloff'>0 do Runtime.setErrSTBLER("LN","LNBLOFF4") quit:ER 
	
			// May not change billing offset if currently in offset period
			if ln.bseq,ln.bldt+ln.bloff.oldVal>%SystemDate do Runtime.setErrSTBLER("LN","LNBLOFF1") quit:ER 
	
			// Invalid if change would put account in billing offset period
			if ln.bndt.oldVal+ln.bloff.oldVal-ln.bloff<%SystemDate do Runtime.setErrSTBLER("LN","LNBLOFF2") quit:ER 
			}
	
		// Determine new billing next date
		if ln.bloff="1P",ln.bndt'=ln.schnd set ln.bndt=ln.schnd
		else  do {
			new NEWVAL
			set NEWVAL=ln.bndt.oldVal+ln.bloff.oldVal-ln.bloff
			if ln.bndt'=NEWVAL set ln.bndt=NEWVAL
			}
		}
	quit
	

vbu10 // Trigger BU_CCLD - Before update customer contact last date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
		Modified to comply with DBI standards. 
	*/

	// Don't update based on title changes
	if 'CUVAR.LCCTIT quit  

	// Already set for today
	if ln.ccld=%SystemDate quit

	set ln.ccld.journal=0,ln.ccld=%SystemDate

	quit
	

vbu11 // Trigger BU_CID - Account number changed

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Change escrow accounts loan reference number (AREF)
	
	do CHGESC^ESCFUNCS(ln.cid.oldVal,ln.cid)
	quit 

vbu12 // Trigger BU_CLPS - Before update construction loan status

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Additional processing if construction loan status changes from
	1 (interim) to 2 (permanent):
	*/

	if ln.clps.oldVal=1,ln.clps=2 do { quit 
	
		new CRCD,TYPE,data,iacm,pcm
	
		/*
		No further processing required if LN.CNVPRD contains no
		value.  This column indicates the new product to which
		the account should be linked after this change.
		*/
		if ln.cnvprd="" quit 
	
		set ln.type=ln.cnvprd
	
		// Define LTYPE table keys
		set TYPE=ln.type

		/*	
		Retrieve column values from the new product, and update
		the LN record with those values.  PROFILE institutions
		requiring additional columns should modify this trigger
		to reflect that need.
		*/
		set data=Db.getOneRow("PCM,IACM","PRODDFTL","TYPE")
	
		set pcm=$P(data,$C(9),1)
		set iacm=$P(data,$C(9),2)

		/*	
		Update account record unless product value is null, or
		column has already been manually changed by user
		*/
		if '(ln.pcm.oldVal'=ln.pcm),(pcm'="") set ln.pcm=pcm
		if '(ln.iacm.oldVal'=ln.iacm),(iacm'="") set ln.iacm=iacm
	
		quit 
		}
	quit
	

vbu13 // Trigger BU_CLS - Before update class

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Change to column ~p1 not allowed
	do Runtime.setErrMSG("LN",412,"LN.CLS") quit:ER 
	quit
	

vbu14 // Trigger BU_CNVDT - Before update Conversion Date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/* ------------- Revision History --------------------------------------
	
	03/30/05 - KinI - 14385
		   Created the trigger to accomodate the code moved from 
		   AU_CNVDT.

	------------------------------------------------------------------------
								*/

	if ln.cnvdt="" set ln.srcdt="" quit
	
	if ln.srcdt'="" quit

	if ln.stroff'="" set ln.srcdt=$$FINDATE^LNCDI(ln.cnvdt,ln.stroff,ln.strcal,ln.srcbind)

	quit

vbu15 // Trigger BU_CNVSTAT - Before Update Manual Conversion Status

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	This trigger resets the conversion data related to the loan when the 
	loan conversion status changes to reset status.  Possible values for 
	the conversion status [LN]CNVSTAT item are:
	 NULL - loan is not setup for conversion or
	        is in the preconversion status (shell of the loan created) 
	        or is being reset for conversion or
	    1 - loan is setup for conversion
	    2 - loan is in the postconversion status
	*/

	/*
	---- Revision History ------------------------------------------------

	04/10/03 - CARROLLJ - 51349
		   Modified call to BALINT^LNFUNCS to only pass the ln object
		   and removed the use of the data array.

	----------------------------------------------------------------------
	*/

	if %O=0 quit

	if ln.cnvstat=2 quit

	// Calc BALINT for manual loan for conversion
	if ln.cnvstat=1 do {   
		new balint
		set ln.balint=$$BALINT^LNFUNCS(.ln)
	}
	// Reset loan for conversion
	if ln.cnvstat="" do {
		set HISCTF=ln.hisctf
		if (ln.aruf)!(ln.cpf) set ln.udbal=ln.crlmt
		new XCCL
		set XCCL=ln.ccl
		if XCCL do { quit:ER
 			// Update loan's commitment
 			new XBAL,XUDBAL,P
			if ln.revf'="" quit
			if 'Db.isDefined("LN","XCCL") quit   // No commitment on file
			new data
			set data=Db.getOneRow("REVF,BAL,UDBAL","LN","XCCL")
			if '$P(data,$C(9),1) quit   // REVF
			// The commitment is revolving and the underlying loan
			// is not. Decrease the toal principal repaid, which 
			// should be ideally the difference betweenTDR and BAL
			// where bal is the amount that the borrower owes as 
			// entered for conversion.
			set P=ln.tdr-ln.bal       // Total principal repaid
			set XBAL=+$P(data,$C(9),2)-P
			set XUDBAL=+$P(data,$C(9),3)-P
			do Db.update("LN","BAL=:XBAL,UDBAL=:XUDBAL","CID=:XCCL")
		}
		// Reset the loan to a preconversion status
		set ln.bal=""
		set ln.udbal=""
		set ln.teb=""
		set ln.habl1=""
		set ln.hisctf=""
		set ln.schseq=0
		set ln.tdue=0
		set ln.inta=0
		set ln.tba=0
		set ln.bseq=0
		set ln.cuin=0
		set ln.unin=0
		set ln.cupr=0
		set ln.unpr=0
		set ln.cues=0
		set ln.unes=0
		set ln.balint=""
		// Delete billing information
		new XCID
		set XCID=ln.cid
		new rs
		type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:XCID") quit:ER
		while rs.next() do {
			new XSCHSEQ
 			set XSCHSEQ=rs.getCol(1)
 			do Db.delete("LNBIL1","SCHSEQ=:XSCHSEQ AND CID=:XCID")
		}
		// Select all PEnnDA from LNBIL0
		new v,row
		set v=""
		set v=v_"PE01DA,PE02DA,PE03DA,PE04DA,PE05DA,PE06DA,PE07DA,"
		set v=v_"PE08DA,PE09DA,PE10DA,PE11DA,PE12DA,PE13DA,PE14DA,"
		set v=v_"PE15DA,PE16DA,PE17DA,PE18DA,PE19DA,PE20DA"
 		set row=Db.getOneRow(v,"LNBIL0","XCID") quit:ER
		if $G(row)'="" for i=1:1:20 set data=$P(row,$C(9),i) if data'="" do { Q:ER
			new ECID,esccnt
			set ECID=data
			do Db.update("DEP","BAL='',POSACR=''","CID=:ECID")
			new rs
			type ResultSet rs=Db.select("TYP","TRTYPE","CID=:ECID")
			while rs.next() do {
				new TYP
				set TYP=rs.getCol(1)
				do Db.update("TRTYPE","REMYTD='',REMPY=''","TYP=:TYP AND CID=:ECID")
			}
 			if i=1 do Db.update("LNBIL0","PE01PF='',PE01LA='',PE01NA=''","CID=:XCID")
			if i=2 do Db.update("LNBIL0","PE02PF='',PE02LA='',PE02NA=''","CID=:XCID")
			if i=3 do Db.update("LNBIL0","PE03PF='',PE03LA='',PE03NA=''","CID=:XCID")
			if i=4 do Db.update("LNBIL0","PE04PF='',PE04LA='',PE04NA=''","CID=:XCID")
			if i=5 do Db.update("LNBIL0","PE05PF='',PE05LA='',PE05NA=''","CID=:XCID")
			if i=6 do Db.update("LNBIL0","PE06PF='',PE06LA='',PE06NA=''","CID=:XCID")
			if i=7 do Db.update("LNBIL0","PE07PF='',PE07LA='',PE07NA=''","CID=:XCID")
			if i=8 do Db.update("LNBIL0","PE08PF='',PE08LA='',PE08NA=''","CID=:XCID")
			if i=9 do Db.update("LNBIL0","PE09PF='',PE09LA='',PE09NA=''","CID=:XCID")
			if i=10 do Db.update("LNBIL0","PE10PF='',PE10LA='',PE10NA=''","CID=:XCID")
			if i=11 do Db.update("LNBIL0","PE11PF='',PE11LA='',PE11NA=''","CID=:XCID")
			if i=12 do Db.update("LNBIL0","PE12PF='',PE12LA='',PE12NA=''","CID=:XCID")
			if i=13 do Db.update("LNBIL0","PE13PF='',PE13LA='',PE13NA=''","CID=:XCID")
			if i=14 do Db.update("LNBIL0","PE14PF='',PE14LA='',PE14NA=''","CID=:XCID")
			if i=15 do Db.update("LNBIL0","PE15PF='',PE15LA='',PE15NA=''","CID=:XCID")
			if i=16 do Db.update("LNBIL0","PE16PF='',PE16LA='',PE16NA=''","CID=:XCID")
			if i=17 do Db.update("LNBIL0","PE17PF='',PE17LA='',PE17NA=''","CID=:XCID")
			if i=18 do Db.update("LNBIL0","PE18PF='',PE18LA='',PE18NA=''","CID=:XCID")
			if i=19 do Db.update("LNBIL0","PE19PF='',PE19LA='',PE19NA=''","CID=:XCID")
			if i=20 do Db.update("LNBIL0","PE20PF='',PE20LA='',PE20NA=''","CID=:XCID")
		}
		new XTYPE,XGRP
		set XTYPE=ln.type
		set XGRP=ln.grp
		if $G(CEFD)="" set CEFD=TJD-1
		do Db.delete("LNCONCMP","CEFD=:CEFD AND CLS='L' AND TYPE=:XTYPE AND GRP=:XGRP AND CID=:XCID")
		do Db.delete("LNCONVES","CEFD=:CEFD AND CID=:XCID")
		do Db.delete("LNCONBL1","CEFD=:CEFD AND CID=:XCID")
		do Db.delete("XCNVMAN","CID=:XCID")
	}
	quit

vbu16 // Trigger BU_COLCD - Before update collateral code

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// If collateral code changes, reassign the primary collateral record number

	new X,XCID,XCOLCD
	set XCID=ln.cid 
	set XCOLCD=ln.colcd

	// new colcd is being changed to null
	if XCOLCD="" quit                    
	new rs 
	type ResultSet rs=Db.select("COLL","LNCOL,COL","LNCOL.CID=:XCID AND COL.SCOLCD=:XCOLCD") 
	if rs.isEmpty() quit
	set COLL=rs.next(),COLL=rs.getCol(1)
	
	if $G(COLL)'="" if ln.coll'=COLL set ln.coll=COLL
	quit
	

vbu17 // Trigger BU_COLLST - Collection Status Change

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	
	11/15/05 - SATYANAS - 18007
		   Added the declaration for ER.
	
	06/14/99 - CARROLLJ 33064
		   If [LN]COLLST-Collsection Status is modified update the
		   [LN]PCOLLST-Previous Collection Status and [LN]COLCDTE-
		   Collection Status Change date.

	
	If collection status is changed update previous collection status and
	Collection Status Change Date
	*/
	
	type public Boolean ER
	
	if (ln.collst.oldVal'=ln.collst) do { quit:ER 
		if ln.colcdte'=%SystemDate set ln.colcdte=%SystemDate
		if ln.collst.oldVal'=ln.collst set ln.pcollst=ln.collst.oldVal
		}
	
	quit
	

vbu18 // Trigger BU_COUPON_INFO - Before update of coupon info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	------------------------------- Revision History -------------------
	10/09/01 - SIVCHUKS - 47644
		Move section SETCPNS to AU_CBMET. This will fix the problem
		when error msg was coming from ln account when payment method
		was switched from automated loan payment to coupon production.
		When data item ln.cbmet(Reorder Basis)was set in ln account in
		PFW for the first time, call was made to LN to check if record
		for this data item exist in table, and if not,the error msg
		was displayed.
		To prevent error occurring during creation, and before checking
		for ln.cbmet in this trigger, value of data item ln.cbmet will
		be set to LN in AU_CBMET trigger.
		
	07/17/01 - PARRAS - 45335
		Added error checking after the calls to CBMET*^LNFUNCS. 
		Invalid errors were displayed later in the process if the
		error was set in one of these functions.
	
	*/

	if 'ln.cbmet.oldVal,ln.cbmet do {
		if 'ln.cbpnd set ln.cbpnd.journal=0,ln.cbpnd=%SystemDate
		set ln.cbond.journal=0,ln.cbond=ln.cbpnd
		}
	
	if ln.cbmet.oldVal,'ln.cbmet do {
		if ln.cbpnd set ln.cbpnd.journal=0,ln.cbpnd=""
		do DELCPNS(.ln)
		}
	
	if ln.cbmet.oldVal,ln.cbmet do {
		if 'ln.cbpnd set ln.cbpnd.journal=0,ln.cbpnd=%SystemDate
		do DELCPNS(.ln)
		}
	quit 


DELCPNS(RecordLN ln) // Delete future dated coupon records

	// This section will delete multiple future coupon records for an account.
	new DATA,XCID,XJD,XPND,XPMET,rs
	set XJD=(%SystemDate-1)
	set XCID=ln.cid
	type ResultSet rs=Db.select("PND","LNCPN","PND>:XJD AND CID=:XCID")
	if rs.isEmpty() quit
	while rs.next() do { quit:ER  
		set XPND=rs.getCol(1)
		do Db.delete("LNCPN","PND=:XPND AND CID=:XCID")
		}
	quit 

vbu19 // Trigger BU_CRLMT - Before update credit limit

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------

	09/26/06 - SANTHUMS - 23201
		   Modified the code use ln.udbal.oldVal while updating
		   the LN.UDBAL,  since unadvanced balance(Ln.UDBAL) was 
		   not getting updated properly while creating the account.
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
		   Removed second argument from MAXFND^LNFUNCS call.

	02/12/99 - MOHAMEDE - 28968
		   If ICPA is set on and the loan balance is greater than credit limit
		   then the credit limit is selected for the interest calculation rather
		   than the loan balance otherwise the loan balance is selected.
	*/

	type public Boolean ER

	// Must change revolving flag and credit limit seperately
	if (ln.revf.oldVal'=ln.revf) do Runtime.setErrSTBLER("LN","REVCR") quit:ER 
	
	// Update UDBAL by the change in CRLMT if appropriate
	if 'ln.aruf set ln.udbal.journal=0,ln.udbal=ln.udbal.oldVal+(ln.crlmt-ln.crlmt.oldVal)
	
	// Update HTBLLTYPE table for correct credit limit total

	// Max funding limit
	if $$MAXFND^LNFUNCS(ln.type) > 0 do {  

		type Number AMT
		set AMT=ln.crlmt-ln.crlmt.oldVal
		
		type RecordHTBLLTYPE htblltype=Db.getRecord("HTBLLTYPE","TYPE=:ln.type",1)	

		if htblltype.getMode()=0 set htblltype.crlmt=AMT
		else  set htblltype.crlmt=htblltype.crlmt+AMT

		do htblltype.bypassSave()

		}

	// New balance amount > credit limit

	type RecordUTBLICPA utblicpa=Db.getRecord("UTBLICPA","KEY=:ln.icpa")

	if (utblicpa.prio).extract(12) set ln.balint=$S(ln.bal'>ln.crlmt:ln.bal,1:ln.crlmt)   

	quit
	
	

vbu20 // Trigger BU_DARCOVR - Before Update Delinq Asset Class Overrid

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	If Delinquency Asset Class Override is updated, update Suspect Indicator.
	If DARCOVR > 0 set SUSPECT to 1.
	If DARCOVR = Null and Expiration period exists set SUSPECT to 3, else set
	SUSPECT to NULL
	*/

	set ln.suspect=$S(ln.darcovr>0:1,(ln.darcexpd&'ln.darcovr):3,1:"")
	quit
	

vbu21 // Trigger BU_DFP - Before update date first payment

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History -------------------------------------------------------
	
	09/02/99 - ALBINK - 33413
		   Added code in order to change and check the value of LN.DIST1ND
		   when the value of LN.DFP is modified.
	*/	


	
	if 'ln.bseq do {
		new newval
		if ln.bloff="1P" set newval=$$NJD^UFRE(ln.dfp,"-"_ln.dist1fre) quit:ER
		else  set newval=ln.dfp-ln.bloff
		if ln.bndt'=newval set ln.bndt=newval
		if ln.schnd'=ln.dfp set ln.schnd=ln.dfp
		if ln.dist1nd'=ln.dfp set ln.dist1nd=ln.dfp 
		}
	
	quit

vbu22 // Trigger BU_DICO - BEFORE UPDATE IROPT FROM DICO

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Synchronize values between DICO & IROPT so that DICO might eventually be
	obsoleted.
	*/
	
	set XDICO=ln.dico
	set ln.iropt.journal=0,ln.iropt=$S(XDICO="":0,XDICO="BL":1,XDICO="FR":2,XDICO="PC":3,XDICO="SP":4)
	quit
	

vbu23 // Trigger BU_DIST1FRE - Before update distribution 1 frequency

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History -------------------------------------------------
	01/28/04 - CARROLLJ - CR7997
		   Correct undefined error on newdistf variable.

	12/04/00 - HUNDERMARKD - 42333
		   Added code to produce an error message if a payment schedule
		   loan has flag PIACM (Calculate P&I Based on IACM) turned on.
	
	03/25/99 - KUCHEROVSKYA - 32401
		   Modified calls to DFP^PROCLN to use LN.TYPE and LN.CRCD as
		   parameters rather than TYPE and CRCD.
	
	02/10/99 - Pete Hayman - 31540
		   Added DIST1LD to list of updated data items.  Also added section
		   for condition when SCHSEQ=0.
	*/	


	if ln.mdt="" do {
		/*
		New method to calculate maturity date using tools in PROCLN.M,
		which is the loan procedure.
		*/

		// Need loan term.
		if ln.trm="" quit 
	
		new BUSOPT,DFP,DIST1FRE,DTNT,LPD,MDT,NBDC,ODD,PCMVAL,TRM,ZAMODT

		// First, we need to calculate DFP (date of first payment.)
		set ODD=ln.odd 
		set DFP="" 
		set DIST1FRE=ln.dist1fre 
		set BLOFF=ln.bloff 
		set DIST1ND=ln.dist1nd
		set DFP=$$DFP^PROCLN(ln.type,ln.crcd,ODD,DIST1FRE,DIST1ND,DFP,BLOFF)

		// Next, calculate LPD (last payment date.)
		set LPD="" set ZAMODT=$$AMODT^PROCLN(ln.type,ln.crcd,ODD,DIST1FRE,DFP,.LPD)
	
		// Finally, calculate MDT (maturity date)
		set DTNT=ln.dtnt 
		set BUSOPT=ln.busopt 
		set TRM=ln.trm 
		set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)
		set NBDC=ln.nbdc
		set MDT=$$MDT^PROCLN(DTNT,ODD,,TRM,BUSOPT,NBDC,LPD,PCMVAL,DIST1FRE) quit:ER 
		set ln.mdt=MDT
	
		}

	new lbdd,npfre,raf,rbndt,rschnd
	
	// Unique considerations if change from regular frequency to payment schedule
	if ln.dist1fre="*" do { quit 
		new dist,n,pmtdistf
	
		// Verification checks to ensure propriety of payment schedule processing
		do { quit:ER 
	
			// Invalid payment calc method for payment schedule processing
			if $E(ln.pcmval,3)'=3!$E(ln.pcmval,2)!($E(ln.pcmval,5)) do Runtime.setErrSTBLER("LN","PFRE*1") quit 
	
			/*
			First character of interest accrual method must not be "0" unless
			interest calculation period frequency has a value.
			Standard interest period method conflicts with payment schedule processing
			*/
			if '$E(ln.iacm),ln.icpf="" do Runtime.setErrSTBLER("LN","PFRE*4") quit 
			
			// Flag PIACM (Calculate P&I Based on IACM) cannot be turned on.
			if ln.piacm do Runtime.setErrSTBLER("LN","PFRE*5") quit		// DJH 12/04/00

			// Maturity date required for payment schedule processing
			if ln.mdt="" do Runtime.setErrSTBLER("LN","PFRE*2") quit 
	
			// Move 4th distribution values before changing to a payment schedule
			if ln.dist4fre'="" do Runtime.setErrMSG("LN",1260) quit 
			}
	
		/*
		Update secondary due dates equal to value of preceding frequency because
		no elements in payment schedule may be linked to dist 1.
		*/
		set ln.dist2nd.journal=0,ln.dist2nd=ln.schnd.oldVal
		set ln.dist2ld.journal=0,ln.dist2ld=ln.schld.oldVal
		set ln.dist3nd.journal=0,ln.dist3nd=ln.dist2nd.oldVal
		set ln.dist3ld.journal=0,ln.dist3ld=ln.dist2ld.oldVal
		set ln.dist4nd.journal=0,ln.dist4nd=ln.dist3nd.oldVal
		set ln.dist4ld.journal=0,ln.dist4ld=ln.dist3ld.oldVal
	
		set ln.dist2fre.journal=0,ln.dist2fre="*"
		set ln.dist3fre.journal=0,ln.dist3fre="*"
		set ln.dist4fre.journal=0,ln.dist4fre="*"
	
		/*
		Bump all values in LN.PMTDISTF.  Corresponding changes to LNBIL0 will
		occur in LNBIL0.
		*/
		set pmtdistf=ln.pmtdistf
		for N=1:1 set dist=$P(pmtdistf,"-",N) quit:dist=""  set $P(newdistf,"-",N)=dist+1
		set ln.pmtdistf.journal=0,ln.pmtdistf=newdistf
	
		/*
		Initialize ONP and AMBAS to 0.  Each payment schedule inserts will
		increment number of payments by 1.
		*/
		set ln.onp=0
		set ln.ambas=0
	
		}
	
	new DATA
	if ln.schseq'=0 do { quit:ER 
		new LBDD
		set LBDD=ln.lbdd
		if LBDD="" set LBDD=ln.schld
		if (ln.schnd.oldVal'=ln.schnd) do { quit:ER 
			if ln.schnd-ln.bloff<%SystemDate do Runtime.setErrSTBLER("LN","LNBLDDT2") quit:ER 
			set DATA=$$DIST1FRE^LNU(ln.dist1fre,ln.bloff,LBDD,ln.dist1nd,ln.schnd,ln.dist1ld) quit:ER 
			}
		else  set DATA=$$DIST1FRE^LNU(ln.dist1fre,ln.bloff,LBDD,ln.dist1nd,,ln.dist1ld) quit:ER 
		}
	
	if ln.schseq=0 do { quit:ER 
		set ln.schld=ln.amodt

		// Since before first scheduled bill, send in AMODT instead of LBDD
		set DATA=$$DIST1FRE^LNU(ln.dist1fre,ln.bloff,ln.amodt,ln.dist1nd,,ln.dist1ld) quit:ER 

		// Update date of first payment
		set ln.dfp=$P(DATA,"|",4)
		}
	
	if $P(DATA,"|",1)'=ln.dist1af set ln.dist1af=$P(DATA,"|",1)
	if $P(DATA,"|",2)'=ln.bndt set ln.bndt=$P(DATA,"|",2)
	if $P(DATA,"|",3)'=ln.schnd set ln.schnd=$P(DATA,"|",3)
	if $P(DATA,"|",4)'=ln.dist1nd set ln.dist1nd=$P(DATA,"|",4)
	if $P(DATA,"|",5)'=ln.dist1ld set ln.dist1ld=$P(DATA,"|",5)
	
	quit

vbu24 // Trigger BU_DIST2ND - Before Update - Distribution 2 Next Due

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------

		07/09/02 - BECKERW - 49913
			Added code to verify that the secondary due dates do
			not precede the first payment due dates.
	 
							09/06/01 - OFALTR - 47394 Custom for RI/RollForward of ARQ 46575
															Created this Trigger to ensure that Int/Div Change - Next Date
															will be equal to Distribution 2 - Next Due, when a frequency of
															'*2' is being Processed.
	
	------------------------------------------------------------------------
	*/
	
	// WVB - 49913
	// Secondary due dates may not precede first payment due dates.
	if ln.dist2nd'="" if ln.dist2nd<ln.dist2nd.oldVal do SETERR^DBSEXECU("LN","ER","DUEDFP") quit:ER

	if ln.intfre'="*2" quit
	set ln.ichnd=ln.dist2nd
	quit

vbu25 // Trigger BU_DIST2_INFO - Before Update Of Distribution 2 Info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	if ln.dist1fre="*" do { quit:ER 
		if ln.dist2fre'="",ln.dist2fre'="*" do { quit:ER 
			do PSREGF1^PROCLN(ln.dist2fre,ln.dist2nd,ln.mdt,2,.ln) quit:ER 
			set ln.dist2fre="*"
			}
		}
	quit 

vbu26 // Trigger BU_DIST3_INFO - Before Update Of Distribution 3 Info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------

		07/09/02 - BECKERW - 49913
			Added code to verify that the secondary due dates do
			not precede the first payment due dates.

	------------------------------------------------------------------------
	*/

	// WVB - 49913
	// Secondary due dates may not precede first payment due dates.
	if ln.dist3nd'="" if ln.dist3nd<ln.dist3nd.oldVal do SETERR^DBSEXECU("LN","ER","DUEDFP") quit:ER

	if ln.dist1fre="*" do { quit:ER 
		if ln.dist3fre'="",ln.dist3fre'="*" do { quit:ER 
			do PSREGF1^PROCLN(ln.dist3fre,ln.dist3nd,ln.mdt,3,.ln) quit:ER 
			set ln.dist3fre="*"
			}
		}
	quit 

vbu27 // Trigger BU_DIST4_INFO - Before Update of Distribution 4 Info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------

		07/09/02 - BECKERW - 49913
			Added code to verify that the secondary due dates do
			not precede the first payment due dates.

	------------------------------------------------------------------------
	*/

	// WVB - 49913
	// Secondary due dates may not precede first payment due dates.
	if ln.dist4nd'="" if ln.dist4nd<ln.dist4nd.oldVal do SETERR^DBSEXECU("LN","ER","DUEDFP") quit:ER

	if ln.dist1fre="*" do { quit:ER 
		if ln.dist4fre'="",ln.dist4fre'="*" do { quit:ER 
			do PSREGF1^PROCLN(ln.dist4fre,ln.dist4nd,ln.mdt,4,.ln) quit:ER 
			set ln.dist4fre="*"
			}
		}
	quit 

vbu28 // Trigger BU_DLCAF - Before update late charge assessment flg

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Set action date if flag gets set
	if ln.dlcaf,ln.lcad="" set ln.lcad.journal=0,ln.lcad=%SystemDate
	
	// Clear action date if flag gets removed
	if 'ln.dlcaf,ln.lcad'="" set ln.lcad.journal=0,ln.lcad=""
	quit
	

vbu29 // Trigger BU_EMPLBEN - Before Update of employer benefit flag

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
	*/

	type public Boolean ER

	// Employer Code is required when Employer Benefit Plan is Yes
	if (ln.emplben=1) , (ln.emplno="") do Runtime.setErrXBAD("LN",198) quit:ER 
	
	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:ln.type")

	// Employer Benefit flag must be consistent with the Product Type
	if (proddftl.emplben=1) , (ln.emplben'=1) do Runtime.setErrMSG("LN",3639) quit:ER 

	quit 

vbu30 // Trigger BU_ICPA - Before update int calc principal adjmnts

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Determine new BALINT based on a change to ICPA
	NOTE:  Modifications to ICPA must be considered here and BALINT^UAVB
	If ICPA is set on then setting balint,data is modified
	to include CRLMT by adding . S data("CRLMT")=LN.CRLMT.M
	*/

								/*
								---- Revision History ------------------------------------------------
	04/10/03 - CARROLLJ - 51349
		   Modified the call to BALINT^LNFUNCS to only pass the ln 
		   object and removed the use of the data array.

								----------------------------------------------------------------------
								*/

	if ln.icpa'="" do {
		new balint
		set balint=$$BALINT^LNFUNCS(.ln)
		if ln.balint'=balint set ln.balint.journal=0,ln.balint=balint
		}
	quit

vbu31 // Trigger BU_ICPF - Before Update ICPF and DIST1AF

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Trace the changes to the LN.ICPF or LN.DIST1AF data items.  If the value of
	LN.ICPF changes and LN.APRMTDH is equal to 2 then the trigger will call
	LNAPR2 procedure to recalculate the APR.
	*/
	
	new EXIT 
	set EXIT=0
	if (ln.icpf.oldVal'=ln.icpf),(ln.aprmthd=2) do { quit:ER 
		new XDISAPR
		set XDISAPR=$$^LNAPR2(ln.irn,ln.icpf,ln.dist1af)
		set ln.disapr=XDISAPR
		set EXIT=1
		}
	
	if EXIT=1 quit 
	
	if (ln.dist1af.oldVal'=ln.dist1af),(ln.aprmthd=2) do { quit:ER 
		new XDISAPR
		set XDISAPR=$$^LNAPR2(ln.irn,ln.icpf,ln.dist1af)
		set ln.disapr=XDISAPR
		}
	
	quit

vbu32 // Trigger BU_INTINFO - Before Update Interest Information

	type public RecordLN ln
	do ln.setAuditFlag(1)

	/*

	   IMPORTANT: Any changes made to this trigger should take into account
	   that it is accessed when the Back-dated Interest Rate Maintenance 
	   function (in PFW) is run, in which special processing takes place, 
	   based on %EffectiveDate (see call to EFDIRN^LNPTS2B call below).

	---- Revision History ------------------------------------------------
	
	04/25/07 - KUMARB - CR 26550
		   Modified trigger to restrict effective dated rate 
		   maintenance at the account level for segmented loans.
	
	01/05/07 - KUMARB - CR24680
		   Modified to set NULL for Last Change Date (LN.ICHLD) and
		   Interest Next Change Date (LN.ICHND) fields if Segments
		   Allowed (LN.SEGMENTS) is selected, and the Interest Change
		   Frequency (LN.INTFRE) is defined.
		   Also removed the defaulting of (LN.IRN) for accounts with
		   index (LN.INDEX) defined.
	
	10/30/06 - KELLYP - CR 23817
		   Modified to only set LN.INTOFFDT when LN.INTOFF is not null.
		   This prevents a problem where INTOFFDT was set when ICHND
		   was manually changed but INTOFF did not have a value, which 
		   led to problems on the next interest change date.
	
	04/15/05 - SmithCD - CR 15305
		   . Corrected defaulting of ln.ichnd
		   . Removed several parameters in the call to EFDIRN^LNPTS2B, 
		     which are no longer needed
		   . Cleaned up code to conform to current PSL standards
		   . Retrofitted the following change from p01:
		           07/10/03 - MALHOTRAV - CR4903
																			Added TREXD and TRATE to the column list that invokes this
																			trigger. This will prevent the user from making an effective
																			dated change to any of these columns and will return
																			appropriate error message.

	02/23/05 - KELLYP - CR 13662
		Changed %G reference to .get() to prevent an undefined error.
		Also removed pre-2003 revision history.

	01/28/04 - CARROLLJ - CR 7997
		Modified call to CTL^UINDX to pass correct parameters.

	*/
	
	type public Boolean ER

	// Set IRN/EIRN if SAN Processing
	if ln.iacf = 2 do { quit:ER
		if ln.irn.oldVal '= ln.irn do { quit:ER
			if ln.irn.isNull() set ln.irn = $$EIRN^PROCSAN(.ln, ln.eirn, ln.iacf, ln.dist1af)
			else  set ln.eirn = $$IRN^PROCSAN(.ln, ln.irn, ln.iacf, ln.dist1af)
			}
		if ln.eirn.oldVal '= ln.eirn do { quit:ER
			if ln.eirn.isNull() set ln.eirn = $$IRN^PROCSAN(.ln, ln.irn, ln.iacf, ln.dist1af)
			else  set ln.irn = $$EIRN^PROCSAN(.ln, ln.eirn, ln.iacf, ln.dist1af)
			}
		}

	if 'ln.intoff.isNull(), 'ln.index.isNull() do { quit:ER
		/* Default Next Interest Change Date - Interest offset 
		   processing

		   If Interest Change Frequency and payment frequency have not 
		   changed, do not change Interest Change Next Date
		*/
		if ln.intfre.oldVal = ln.intfre, ln.dist1fre.oldVal = ln.dist1fre quit

		type Date DT

		set DT = $$NXDT^BCHVRCHG(%SystemDate, ln.dist1nd, ln.intfre, ln.intoff) quit:ER
		set ln.ichnd = DT + ln.intoff
		}

	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do { quit:ER
			
			// Account-level effective dated rate maintenance not allowed for segmented loan accounts
			if ('(%EffectiveDate.get()).isNull()), (%EffectiveDate < %SystemDate) do Runtime.setErrMSG("LN", 6881) quit:ER
			
			if ('ln.intfre.isNull()) do { 
				set ln.ichld = ""
				set ln.ichnd = ""
				}
			}
	#ENDIF
	
	if ln.index.isNull() do { quit:ER
		// No index defined - clear interest-related fields
		set ln.ichnd = ""
		set ln.ichld = ""
		set ln.intmat = ""
		set ln.intspr = ""
		set ln.rndmtd = ""
		}
	else  if 'ln.segments,(ln.ichnd.isNull()),('ln.intfre.isNull()) do { quit:ER
		// Default Next Interest Change Date - no Interest Offset 
		// processing
		type Date ICHND

		set ICHND = ln.odd
		for  set ICHND = ICHND.nextFreqDate(ln.intfre) quit:ICHND '< %SystemDate ! (ER)

		set ln.ichnd = ICHND
		}
 	
	if %EffectiveDate.get(), %EffectiveDate < %SystemDate do { quit:ER
		type String index
		type Number irn

		// Cannot use add-on/discount loans
		if ln.iam do Runtime.setErrMSG("LN", 481) quit

		// Account closed
		if ln.stat do Runtime.setErrMSG("LN", 55) quit

		// Must be the same as or after teaser rate expiration date 
		// of ~p1
		if %EffectiveDate < ln.trexd do Runtime.setErrMSG("LN", 1800, ln.trexd.toString()) quit

		// Must be the same as or after the disbursement date of ~p1
		if %EffectiveDate < ln.odd do Runtime.setErrMSG("LN", 1822, ln.odd.toString()) quit

		// Must be after the history purge date of ~p1
		if %EffectiveDate '> ln.hisctf do Runtime.setErrMSG("LN", 1801, ln.hisctf.toString()) quit

		do { quit:ER
			type Number BASEAMT, RATE, RRATE, SRATE, URATE

			// Reset the interest rate if the spread or rounding
			// method was changed
	
			if 'ln.segments,('ln.index.isNull()) do { quit:ER
				type String PAR()
				
				if 'ln.cntdr set BASEAMT = ln.amtreq
				else  set BASEAMT = ln.balint
				
				set PAR("RNDFC") = 1
				
				do CTL^UINDX(.ln, %EffectiveDate, BASEAMT, .PAR()) quit:ER
				set ln.irn = RATE
				}
	
			/*
			Call routine to calculate and post accrual adjustments 
			and return current irn, index, etc. values in ln object
			*/
			do EFDIRN^LNPTS2B(.ln) quit:ER
			}
		}

	/*
	Set Avg Int Recalc Flag if PCM interest component is 2 (Fixed Avg Int)
	whenever IRN is changed
	*/
	if (ln.irn.oldVal '= ln.irn), '(ln.air.oldVal '= ln.air), ln.air '= 1, ln.pcmval.extract(2) = 2 set ln.air = 1
	
	// Calculate interest change next and last dates if necessary
	if 'ln.index.isNull(), ln.index.oldVal.isNull(), 'ln.intfre.isNull() do { quit:ER
		type String CTL
		type Date ICHLD

		if ln.intoff > 0 set CTL=0
		else  set CTL = 1

		if ln.ichnd.isNull() set ln.ichnd = $$FRSTDATE^ACNFUNCS(%SystemDate, ln.intfre, CTL, ln.intoff, , , , ln.intoffcl) quit:ER

		if ln.ichld.isNull() do { quit:ER
			set ICHLD = ln.ichnd.nextFreqDate(ln.intfre, , 1) quit:ER
			if ICHLD '< ln.amodt set ln.ichld = ICHLD
			}
		}

	// Calculate interest change last date if NULL and ICHND is defined
	if ln.ichnd, ln.ichld.isNull() do { quit:ER
		type Date jd

		if ln.odd = %SystemDate set ln.ichld = ln.odd quit

		/*
		Int/Div Change - Last Date should not be prior to Original
		Disbursement Date and should not be in the future
		*/
		set jd = ln.ichnd
		for  set jd = jd.nextFreqDate(ln.intfre, , 1) quit:ER ! ((jd '> ln.odd) ! (jd < %SystemDate))
		if jd < ln.odd set ln.ichld = ln.odd
		else  set ln.ichld = jd
		}

	// Recalculate APR if IRN is changed
	if (ln.irn.oldVal '= ln.irn), (ln.aprmthd = 2) set ln.disapr = $$^LNAPR2(ln.irn, ln.icpf, ln.dist1af) quit:ER

	// If old interest change next date, move to new date updating ^PCBD 
	// global
	if (ln.ichnd.oldVal '= ln.ichnd) ! (ln.intoff.oldVal '= ln.intoff) do {
		if ln.ichnd.oldVal do {
			type Date ICHND
			type Number LNCID
			
			set ICHND = ln.ichnd.oldVal
			set LNCID = ln.cid
			
			do Db.delete("LNVRCHG", "ICHND=:ICHND AND CID=:LNCID")
			}
		// Calculate new value for Payment Change Analysis Offset Date
		set ln.intoffdt.journal = 0
		if 'ln.ichnd set ln.intoffdt = ""
		else  if 'ln.intoff.isNull() set ln.intoffdt = ln.ichnd - ln.intoff
		}
	
	// Change to column ~p1 not allowed
	if (ln.intoffdt.oldVal '= ln.intoffdt), ('ln.isChanged("INTOFFDT", "SYSTEM")) do Runtime.setErrMSG("LN", 412, "LN.INTOFFDT") quit:ER

	quit

vbu33 // Trigger BU_IPL - Before update interest paid life

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Add-on loans only
	if $E(ln.iam)=1 set ln.balint=ln.balint+(ln.ipl-ln.ipl.oldVal)
	quit
	

vbu34 // Trigger BU_IROPT - Before Update IROPT POPULATE DICO

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	----Revision History---------------------------------------------------

	08/22/07 - Chhabris - CR28684
		   Added XIROPT=5:"BD" in the $select() statement. New
	   	   interest resolution option was added,5 - Capitalize at
	   	   the billing date.

	09/24/99 - JERUCHIMC - 35021
		   Handle case of XIROPT=""
	

	Synchronize values between DICO & IROPT so that DICO might eventually be
	obsoleted.
	*/

	
	set XIROPT=ln.iropt
	set ln.dico.journal=0,ln.dico=$S(XIROPT="":"",XIROPT=0:"",XIROPT=1:"BL",XIROPT=2:"FR",XIROPT=3:"PC",XIROPT=4:"SP",XIROPT=5:"BD")
	quit
	

vbu35 // Trigger BU_IUN - Before update interest unearned (orig)

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Skip discount loans
	if $E(ln.iam)'=2 set ln.balint=ln.balint-(ln.iun-ln.iun.oldVal)
	quit
	

vbu36 // Trigger BU_MDT - Before Update Maturity Date.

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	--- Revision History --------------------------------------------------

	03/02/06 - TITOVE - CR 19733
		   Added quit for special fee type "*" and also a new
		   error message 7106.

	03/30/05 - KinI - 14385
		   Cleaned up to comply with DBI standards. 

	03/22/02 - PONGRACZD - 43877
		   Added Error Message Check for LN.PIACM and LN.PCM.  PIACM
		   can only be set to "Y" when the PCM contains a P&I element.

	06/10/99 - ALBINK - 33586
		   Modified code to determine if booking fees were already
		   filed for the account or the effective date.
	
	03/25/99 - KUCHEROVSKYA - 32401
		   Modified calls to DFP^PROCLN to use LN.TYPE and LN.CRCD as
		   parameters rather than TYPE and CRCD.
	
	01/22/99 - ALBINK - 30896
		   Added code to check the LNFEEP.AMTH rather than
		   LNFEEP.CFWA to determine if the fee is at booking.
	
	01/14/99 - MAGERAM - 30948
		   Added code to check for change in LN.DTNT to assess
		   booking fees.
	
	12/11/98 - ALBINK - 31114
		   Added code in order to assess and file booking fees on a
		   note date modification.
	*/

	type public Boolean ER
	type String PCMVAL	

	set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)

	// PIACM only set to "Y" with a PCM containing a P&I element
	if (ln.piacm=1) , '(PCMVAL.extract(1)) do Runtime.setErrXBAD("LN","PIACM-PCM") quit:ER

	// Assess booking fees on note date modification 
	if (ln.dtnt.oldVal '= ln.dtnt) do { quit:ER 

 		type String XFEETYP

		type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:ln.cid") quit:ER 
		
		while rs.next() do { quit:ER
			set XFEETYP=rs.getCol(1)

			// If fee on the account
			if 'XFEETYP.isNull(),(XFEETYP '= "*") do { quit

				type RecordLNFEE lnfee=Db.getRecord("LNFEE","CID=:ln.cid,FEETYP=:XFEETYP")				

				// If this is a linked fee quit - linked fees are not needed, only the primary fee should be used.
				if lnfee.lfee=1 quit 

				type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP=:XFEETYP", 1)

				// Invalid fee plan ~p1
				if 'lnfeep.getMode() do Runtime.setErrMSG("LNFEEP",7106,XFEETYP) quit

				// If the assessment method is at booking
				if lnfeep.amth=0 do {
					// Booking fees already filed for ~p1
					if ln.dtnt < %SystemDate do Runtime.setErrMSG("LN",3469,ln.cid) quit:ER

					// Update Next Fee Assessment Date
					set lnfee.asnd=ln.dtnt
					do lnfee.save()

					}
				}
			}
		}
	
	if ln.mdt'="" quit

	// New method to calculate maturity date using tools in PROCLN.M,
	// which is the Loan Procedure.

	if ln.trm="" quit 
	
	// First, we need to calculate DFP (date of first payment)
	
	type Date DFP,LPD,ZAMODT
	set DFP=""

	set BLOFF=ln.bloff 
	set DIST1ND=ln.dist1nd
	set DFP=$$DFP^PROCLN(ln.type,ln.crcd,ln.odd,ln.dist1fre,DIST1ND,DFP,BLOFF)
	
	// Next, calculate LPD (last payment date)
	set LPD="" set ZAMODT=$$AMODT^PROCLN(ln.type,ln.crcd,ln.odd,ln.dist1fre,DFP,.LPD)
	
	// Finally, calculate maturity date
	set ln.mdt=$$MDT^PROCLN(ln.dtnt,ln.odd,,ln.trm,ln.busopt,ln.nbdc,LPD,PCMVAL,ln.dist1fre) quit:ER
	
	quit 

	

vbu37 // Trigger BU_MT900 - Before Update trigger for column MT900

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if ln.mt900=1,ln.mt900a.isNull() do { quit:ER

		type RecordCIF cif=Db.getRecord("CIF","ACN=:ln.acn")
		
		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt900a.isNull() do Runtime.setErrMSG("LN","4029") quit:ER
		}

	quit

vbu38 // Trigger BU_MT910 - Before Update trigger for column MT910.

	type public RecordLN ln
	do ln.setAuditFlag(1)
								/*
								---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if ln.mt910=1,ln.mt910a.isNull() do { quit:ER

		type RecordCIF cif=Db.getRecord("CIF","ACN=:ln.acn")
		
		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt910a.isNull() do Runtime.setErrMSG("LN","4029") quit:ER
		}

	quit

vbu39 // Trigger BU_NAI - Before Update of Non-Accrual Indicator

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------	
	
	06/05/06 - GIRIDHAL - CR 21207
	This trigger sets Non-Accrual placement date to systemdate when the 
	non accrual indicator is equal to 1.
								 
	----------------------------------------------------------------------
	*/
	type public Boolean ER

	// Future-dated request invalid
	if ln.naplmtdt > %SystemDate do Runtime.setErrMSG("LN",1152) quit:ER

	if ln.naplmtdt.oldVal = ln.naplmtdt,ln.nai = 1 set ln.naplmtdt = %SystemDate
	quit

vbu40 // Trigger BU_PAS_PAP - Before update payment string or path

	type public RecordLN ln
	do ln.setAuditFlag(1)
	;---- Revision History--------------------------------------------------------
	;
	; 01/28/04 - CARROLLJ - CR7997
 ;	      Modified call to LNCNVST to pass ln object.
	;
	; 3/21/2000 - VERTLIBA - 39649
	;             Corrected setting of ln.ppdcat3 that was missing and
	;             ln.ppdcat2 was used twice instead.
	;
	;-----------------------------------------------------------------------------
	// Calculate payment string information
	if ln.pas'="",ln.pap'="" do {
		new npc,pmtdist,pmtdistf,ppdcat
		set pmtdist=ln.pmtdist 
		set pmtdistf=ln.pmtdistf
		do ^LNCNVST(.ln,ln.cid,ln.pas,ln.pap,.pmtdist,.pmtdistf,.npc,.ppdcat) quit:ER 
		set ln.pmtdist.journal=0,ln.pmtdist=pmtdist 
		set ln.pmtdistf.journal=0,ln.pmtdistf=pmtdistf 
		set ln.npc.journal=0,ln.npc=npc
		set ln.ppdcat1.journal=0,ln.ppdcat1=ppdcat(1) 
		set ln.ppdcat2.journal=0,ln.ppdcat2=ppdcat(2)
		set ln.ppdcat3.journal=0,ln.ppdcat3=ppdcat(3)	;abv 
		set ln.ppdcat4.journal=0,ln.ppdcat4=ppdcat(4)
		set ln.ppdcat5.journal=0,ln.ppdcat5=ppdcat(5) 
		set ln.ppdcat6.journal=0,ln.ppdcat6=ppdcat(6)
		set ln.ppdcat7.journal=0,ln.ppdcat7=ppdcat(7) 
		set ln.ppdcat8.journal=0,ln.ppdcat8=ppdcat(8)
		set ln.ppdcat9.journal=0,ln.ppdcat9=ppdcat(9) 
		set ln.ppdcat10.journal=0,ln.ppdcat10=ppdcat(10)
		}
	quit

vbu41 // Trigger BU_PCFRE - Before update payment change frequency

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	
	11/17/00 - CHEUNGA - 42650
																			Added LN.INDEX'="" to prevent null subscript error
																			occurring when index is removed during Account
																			modification.
	
	07/21/99 - LAMY - 33254
		   The following code will make sure that PCHND is updated
		   when PCFRE is changed.
	*/

	
	if (ln.pcfre.oldVal'=ln.pcfre),(ln.dist1fre.oldVal'=ln.dist1fre),(ln.index'="") do {
		set FRE=ln.pcfre
		set D=$$NXDT^BCHVRCHG(%SystemDate,ln.dist1nd,ln.pcfre,ln.pcoff) 
		set JD=D+ln.pcoff
		set ln.pchnd=JD
		}
	quit

vbu42 // Trigger BU_PCHND_RAND - BU pmt or re-amort change next date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
								---------------- Revision History -----------------------
								08/08/01 - SANTOSL - 45848
																			Modified this section to verify if PCHND
																			and CID data item from LNPTCHG table is
																			defined to avoid message of "Record not
																			on file".
								----------------------------------------------------------
								*/
								// If old change date, move to new date
	if (ln.pchnd.oldVal'=ln.pchnd),ln.pchnd.oldVal do {
		new lnptchg
		type RecordLNPTCHG lnptchg=Class.new("RecordLNPTCHG")
																set PCHND=ln.pchnd
		set CID=ln.cid	
		if ln.pchnd="" do Db.delete("LNPTCHG","PCHND=:PCHND AND CID=:CID") quit
		if '(ln.pchnd&ln.piind) quit
		if Db.isDefined("LNPTCHG","PCHND,CID") do {
			set lnptchg=Db.getRecord("LNPTCHG","PCHND,CID")
		}
		set lnptchg.pchnd=ln.pchnd
	        set lnptchg.cid=CID
		do lnptchg.save()
		}
	
	// If old re-amortization date, move to new date
	if (ln.rand.oldVal'=ln.rand),ln.rand.oldVal do {
		new lnrachg
		set RAND=ln.rand.oldVal
		set CID=ln.cid
		if ln.rand="" do Db.delete("LNRACHG","RAND=:RAND AND CID=:CID") quit
		if '(ln.rand&ln.piind) quit
		type RecordLNRACHG lnrachg=Db.getRecord("LNRACHG","RAND,CID")
		set lnrachg.rand=ln.rand
		do lnrachg.save()
		}
	
	// Calculate new value for Payment Change Offset Date
	if (ln.pchnd.oldVal'=ln.pchnd)!(ln.pcoff.oldVal'=ln.pcoff) do {
		if 'ln.pchnd set ln.pcoffdt.journal=0,ln.pcoffdt=""
		else  set ln.pcoffdt.journal=0,ln.pcoffdt=ln.pchnd-ln.pcoff
		}
	
	// Calculate new value for Re-amortization Offset Date
	if (ln.rand.oldVal'=ln.rand)!(ln.pcoff.oldVal'=ln.pcoff) do {
		if 'ln.rand set ln.randoff.journal=0,ln.randoff=""
		else  set ln.randoff.journal=0,ln.randoff=ln.rand-ln.pcoff
		}
	quit

vbu43 // Trigger BU_PCOFFDT - Before update pmt change offset date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("PCOFFDT","SYSTEM") do Runtime.setErrMSG("LN",412,"LN.PCOFFDT") quit:ER 
	quit
	

vbu44 // Trigger BU_PMTDIST - Update PPDCAT*

	type public RecordLN ln
	do ln.setAuditFlag(1)
	;---- Revision History -----------------------------------------------
	;
	; 01/28/04 - CARROLLJ - CR7997
 ;	      Modified call to LNCNVST to pass ln object.
	;
	; 08/21/00 - AGARWALS - 41477
 ;	      Corrected code. Data items should be set from the local array
 ;	      after the LNCNVST call and not visa versa, as was mistakenly
 ;	      being done.
	;
	; 03/04/00 - RANALLIC - 36989
 ;	      Create Trgger BU_PMTDIST - Update PPDCAT* to update
 ;	      LN(65) when adding Escrow to an existing loan.
 ;	      When updating a loan in PFW for escrow LN(65)
 ;	      was not being updated.  Could not process a payment
 ;	      received a Timeout error.
	;
	;
	;
	;----------------------------------------------------------------------
	new npc,pmtdist,pmtdistf,ppdcat
	set pmtdist=ln.pmtdist,pmtdistf=ln.pmtdistf
	do ^LNCNVST(.ln,ln.cid,ln.pas,ln.pap,.pmtdist,.pmtdistf,.npc,.ppdcat) quit:ER
	set ln.pmtdist=pmtdist
	set ln.pmtdistf=pmtdistf
	set ln.npc=npc
	set ln.ppdcat1=ppdcat(1)
	set ln.ppdcat2=ppdcat(2)
	set ln.ppdcat3=ppdcat(3)
	set ln.ppdcat4=ppdcat(4)
	set ln.ppdcat5=ppdcat(5)
	set ln.ppdcat6=ppdcat(6)
	set ln.ppdcat7=ppdcat(7)
	set ln.ppdcat8=ppdcat(8)
	set ln.ppdcat9=ppdcat(9)
	set ln.ppdcat10=ppdcat(10)
	quit

vbu45 // Trigger BU_PMTGRC - Before update payment grace period

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History--------------------------------------------------------
	07/09/03 - CARROLLJ - 51349
		   Changed call to LNBLDB to call BCHLNBLDB because Routine LNBLDB was 
		   obsoleted.

	04/09/99 - SKLYUTD - 31585
		   Do not need to reset LCAD if PMTGRC is changed before first
		   payment date.
	*/

	// Reset LCAD if PMTGRC changes
	if (ln.pmtgrc'=""),(ln.bldt'<ln.dfp) do {
		new LCAD,lcefd
		set lcefd=ln.bldt+ln.bloff
		if ln.bloff="1P" set lcefd=$$NJD^UFRE(ln.bldt,ln.dist1fre) quit:ER
		do LCAD^BCHLNLD(lcefd,ln.lcbo,ln.pmtgrc,ln.dist1fre,1)
		if LCAD'>%SystemDate set LCAD=%SystemDate
		if ln.lcad'=LCAD set ln.lcad=LCAD
		}
	quit

vbu46 // Trigger BU_PMTPI_PMTTRS - Before update payment components

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ---------------------------------------------------------
	
	09/07/00 - KELLYP - 41749:001
		   Fixed RECNOFL error that was occuring during escrow creation
		   with 'Db.isDefined on LNCPN.

 	08/28/00 - APPLEYARDM - 41624
		   Roll forward ARQ 39584: Modified trigger to update LNCPN.TPT
		   when escrow is added to account. This fixes problem where 
		   escrow amount was not being added to LNCPN.TPT when LN is 
		   created through PFW.

	*/

	// Set payment to include P&I plus escrow amount
	if ln.piind,ln.pmt'=ln.pmtpi+ln.pmttrs set ln.pmt=ln.pmtpi+ln.pmttrs

	// Update LNCPN if LN.PMT '= LNCPN.TPT

	new XPND,XPMET,XCID,XTPT
	set XPND=%SystemDate,XPMET=3,XCID=ln.cid
	
	if 'Db.isDefined("LNCPN","XPND,XPMET,XCID") quit

	new lncpn
	type RecordLNCPN lncpn
	set lncpn=Db.getRecord("LNCPN","PND=:XPND,PMET=:XPMET,CID=:XCID")

	if lncpn.tpt="" quit		//Nothing to update
	if lncpn.tpt=ln.pmt quit	//Updated already

	set XTPT=ln.pmttrs+ln.pmtpi	
	do Db.update("LNCPN","TPT=:XTPT","PND=:XPND AND PMET=:XPMET AND CID=:XCID")
	quit

vbu47 // Trigger BU_PPFREQ - Before update Prepmt Pen Determ Freq

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Prepayment Penalty processing
	if ln.ppfreq'="" do { quit:ER 
		if ln.ppld="",ln.dist1fre'="" set ln.ppld=$$NJD^UFRE(ln.dfp,ln.dist1fre) quit:ER 
		if ln.ppld'="" do {
			new NJD
			set NJD=$$NJD^UFRE(ln.ppld,ln.ppfreq) quit:ER 
			if NJD'=ln.ppnd set ln.ppnd=NJD
			}
		}
	quit

vbu48 // Trigger BU_PROV - Before update of Provision fields

	type public RecordLN ln
	do ln.setAuditFlag(1)
								/*
								---- Revision History ------------------------------------------------
	
								04/19/05 - TITOVE - CR 15089
																			Modified as part of DBI2 project.
	
								*/

	type public Number ER

	// Data required in Data Item ~p1
	if ln.racovr.isNull(),(ln.provoamt!(ln.provopct)) do Runtime.setErrMSG("LN",7531,"LN.RACOVR") quit:ER 

	// Ovr provision amount and ovr provision percentage not allowed
	if ln.provoamt,ln.provopct do Runtime.setErrMSG("LN",2759) quit:ER 

	quit
	

vbu49 // Trigger BU_RANDOFF - Before update re-amort offset date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("RANDOFF","SYSTEM") do Runtime.setErrMSG("LN",412,"ln.randoff") quit:ER 
	quit
	

vbu50 // Trigger BU_RENCD_TRACN - Before update RENCD or TRACN

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/* 05/10/05 - Carol Scott - CR 15816
		Remove the crcd parameter from the call to LNFUNCS.
		It only requires the type parameter.
	*/
							 
								// Transfer account not allowed for this maturity option.
	if ln.tracn'="",ln.rencd=0!(ln.rencd=4) set ln.tracn=""

	// Maturity option requires Transfer Account.
	if ln.tracn="" do { quit:ER 
		if ln.rencd=1!(ln.rencd=2)!(ln.rencd=3) do Runtime.setErrXBAD("LN",110) quit 

		// Fixed Bullet Product Option Requires Transfer Acct
		if $$FBP^LNFUNCS(ln.type)=2 do Runtime.setErrXBAD("LN",154) quit:ER 
		}
	quit
	

vbu51 // Trigger BU_REVF_TDR - Before update rev flag or tot disb amt

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Must change revolving flag and credit limit seperately
	if (ln.revf.oldVal'=ln.revf),(ln.crlmt.oldVal'=ln.crlmt) do Runtime.setErrSTBLER("LN","REVCR") quit:ER 
	
	// Calculate new UDBAL value
	if 'ln.aruf do {
		if 'ln.revf set ln.udbal.journal=0,ln.udbal=ln.crlmt-ln.tdr
		else  set ln.udbal.journal=0,ln.udbal=ln.crlmt-ln.bal
		}
	quit
	

vbu52 // Trigger BU_SCHND - Before update trigger for LN.SCHND

	type public RecordLN ln
	do ln.setAuditFlag(1)
	new BNDT
	set BNDT=ln.schnd-ln.bloff
	if ln.bloff="1P" set BNDT=ln.schld
	set ln.bndt=BNDT
	quit
	

vbu53 // Trigger BU_SGNCRD - Set SGNCRDCHGDT when Sign Card Values Ch

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	09/28/01 - myersk - 47550 QAR 1
		   Created this trigger to correctly populate LN.SGNCRDCHGDT
	*/
								set ln.sgncrdchgdt=%SystemDate
	quit

vbu54 // Trigger BU_STAT - Before Update STAT

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	----Revision History ----------------------------------------------------
	
	05/16/06 - SmithCD - CR 20855
		   Modified "Deferred fee balance is equal to $~p1" error to 
		   report the amount.

	03/13/06 - KinI - CR 20021
		Modified to add the third parameter "1" when retrieving 
		LNCYCPTS record.

	03/09/06 - KELLYP - CR 19958
		Modified to remove the third parameter from the call to 
		REMOVE^PROCEFT.  Also removed pre-2003 revision history.
	
	08/25/05 - KELLYP - CR 16684
		Modified XCID reference in ln.stat=4 section to prevent an
		undefined error (should have been using ln.cid instead).
	
	08/02/05 - KUMARB - CR16684
		Modified the Check for open accounts linked to commitments
		to select from LN table.

	03/30/05 - KinI - 14385
		Cleaned up to comply with DBI standards. 
	*/
	
	type public Boolean ER=0
	
	if ln.stat=4 do { quit:ER
		
		// Account already closed
		if ln.stat.oldVal=4 do Runtime.setErrMSG("LN",51) quit 

		// Unable to close - balance = ~p1
		if $$^SCARND(ln.bal,0,"","",2) do Runtime.setErrMSG("LN",2784,ln.bal) quit 

		// Unable to close - accrual = ~p1
		if $$^SCARND(ln.acr,0,"","",2) do Runtime.setErrMSG("LN",2783,ln.acr) quit 
	
		// Loan-specific balance checks

		type String data,PTS
		type Number Z
	
		set Z=$$^SCARND(ln.lchg,0,ln.cid)
		// Late charge balance = $~p1
		if (Z) do Runtime.setErrMSG("LN",1595,Z) quit 
	
		set Z=$$^SCARND(ln.udbal,0,ln.cid)
		// Undisbursed balance = $~p1
		if (Z) , (ln.aruf) do Runtime.setErrMSG("LN",2813,Z) quit  
	
		set Z=$$^SCARND(ln.mcnd,0,ln.cid)
		// Miscellaneous charge balance = $~p1
		if (Z) do Runtime.setErrMSG("LN",1746,Z) quit  
	
		set Z=$$^SCARND(ln.iun-ln.ipl,0,ln.cid)
		// Uncollected interest balance = $~p1
		if (Z) , (ln.iam) do Runtime.setErrMSG("LN",2810,Z) quit   
	
		set Z=$$^SCARND(ln.crlmt)
		// Linked loan credit limit ~p1
		if (Z) , (ln.ccl) do Runtime.setErrMSG("LN",8243,Z) quit  
	
		set Z=$$^SCARND(ln.unapf,0,ln.cid)
		// Unapplied funds balance = ~p1
		if (Z) , (ln.ccl) do Runtime.setErrMSG("LN",2809,Z) quit   
	
		do { quit:ER 
			/*
			Check the value of [LN]TEB.  If it has a value then we 
			must reject so the user may close the escrow accounts.  
			If it is zero, then one of two conditions exist: 
			1) the escrow accounts are closed; or 
			2) the sum of the escrow account balances total zero.  
			Check each escrow.
			*/
			type String row
			type Number I

			// Escrow accounts have balances
			if $$^SCARND(ln.teb,0,ln.cid) do Runtime.setErrMSG("LN",1004) quit 
	
			type ResultSet rs=Db.select("PE01DA,PE02DA,PE03DA,PE04DA,PE05DA,PE06DA,PE07DA,PE08DA,PE09DA,PE10DA,PE11DA,PE12DA,PE13DA,PE14DA,PE15DA,PE16DA,PE17DA,PE18DA,PE19DA,PE20DA","LNBIL0","CID=:ln.cid") 
	    		if 'rs.next() quit
	    		set row = rs.getRow()

			for I = 1:1:20 set data = row.piece($C(9),I) if 'data.isNull() do { quit:ER 
				
				type Number ECID=data
				
				type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")

				// Escrow accounts have balances
				if $$^SCARND(dep.bal,0,2) do Runtime.setErrMSG("LN",1004) quit 

				// Close the escrow account if it is open
				if dep.stat'=4 set dep.stat=4 do dep.save() 
				}
			}
	
		// Check for open accounts linked to commitments
		type ResultSet rs=Db.select("STAT","LN","CCL=:ln.cid AND STAT=4")
		if 'rs.isEmpty() do Runtime.setErrMSG("LN",2786) quit:ER
	
		// Check for deferred interest
		set PTS="PTS"
		type RecordLNCYCPTS lncycpts=Db.getRecord("LNCYCPTS","CID=:ln.cid,TYP=:PTS",1)
		 
		set Z=(lncycpts.amt-lncycpts.caltd-lncycpts.npda).roundCur(ln.crcd)

		// Deferred fee balance is equal to $~p1
		if Z do Runtime.setErrMSG("LN",786,Z) quit 


		// Loan record is ok so update BAL,ACR and DTC
		set ln.bal.journal=0,ln.bal=0
		set ln.acr.journal=0,ln.acr=0
		if ln.dtc'=%SystemDate set ln.dtc=%SystemDate
		
		// Delete standing (collection/payment) orders upon loan payoff
		do REMOVE^PROCEFT(ln.cid,%SystemDate)
		}
		
	if ln.stat.oldVal=4 do {
	
		type String data
		
		if ln.dtc'="" set ln.dtc=""
		if ln.acs'=(%SystemDate-1) set ln.acs=%SystemDate-1

		// Update status of escrow accounts
		type ResultSet rs=Db.select("PE01DA,PE02DA,PE03DA,PE04DA,PE05DA,PE06DA,PE07DA,PE08DA,PE09DA,PE10DA,PE11DA,PE12DA,PE13DA,PE14DA,PE15DA,PE16DA,PE17DA,PE18DA,PE19DA,PE20DA","LNBIL0","CID=:ln.cid") 
		if 'rs.next() quit
	    	set row = rs.getRow()

		for I = 1:1:20 set data = row.piece($C(9),I) if 'data.isNull() do { quit:ER 
					
			type Number ECID=data	
			type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")					
			
			// Escrow accounts have balances
			// Open the escrow account if it is closed
			if dep.stat=4 set dep.stat=0 do dep.save()
			}
			
		if ER quit 
		
		// Interest change next date and last date
		if ln.intfre'="" do {					
			
			if ln.ichnd '< %SystemDate quit 
			
			type Date OV=ln.ichnd
			
			for  set OV=$$NJD^UFRE(OV,ln.intfre) quit:OV'<%SystemDate!(ER) 

			if 'ER , (ln.ichnd '= OV) set ln.ichnd=OV
			set OV=$$NJD^UFRE(OV,ln.intfre,,1)
			
			if 'ER , (ln.ichld '= OV) set ln.ichld=OV
			}
			
		if ER set ER=0      // Frequency error, allow integs to show it

		do LOAN^UOPEN(.ln)  // Re-Open an Account

		if ER quit 
				
		type Number XCID,XTKS
		type Date ARND
		type String FRE 
		
		set XCID=CID  // CID is returned by ^LNPTS called from ^UOPEN
	
		// Bring any tickler's with a frequency up to date
		type ResultSet rs=Db.select("TKS,ARND,ARF,EXPD","TIKLACN","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next() do { 
			set ARND=rs.getCol(2)
			
			if ARND>%SystemDate quit 

			if ARND>rs.getCol(4) quit 

			set FRE=rs.getCol(3)
			set XTKS=rs.getCol(1)

			for  set ARND=$$NJD^UFRE(ARND,FRE) quit:ER!(ARND>%SystemDate) 
			if ER quit
			 
			type RecordTIKLACN tiklacn=Db.getRecord("TIKLACN","CID=:XCID,TKS=:XTKS",1)
			set tiklacn.arnd=ARND	      // Next Occurrence
			
			do tiklacn.save()	
			}
			
		if ER set ER=0                        // Frequency error
		}
		
	quit

vbu55 // Trigger BU_TOLCHK - Before Update Tolerance Check Trigger

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
   	 ---- Revision History--------------------------------------------------
	
 		03/31/05 - KinI - 14385
 			Added error message text comment.
	
		08/15/00 - ROYTENBERGE - 40990
			New trigger has been created to display an error 
			message when PAYTOL and PAYTOLP columns are populated 
			at the same time.
	*/

	// Cannot define a fixed tolerance and a tolerance percentage together
	if ln.paytol'="",ln.paytolp'="" do Runtime.setErrMSG("LN",4482) quit:ER

	quit

vbu56 // Trigger BU_TYPE - Before update type

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
								---- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 
	*/

	type public Boolean ER

	// Be sure new type is still loan class

	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:ln.type")

	// Product type is not defined for this currency
	if proddftl.cls="" do Runtime.setErrMSG("LN",2250) quit:ER 

	// Product class or group does not match product type
	if proddftl.cls'="L" do Runtime.setErrMSG("LN",8472) quit:ER 
	
	// If type changes, change group automatically, if appropriate
	if ln.grp'=proddftl.grp set ln.grp=proddftl.grp
	
	quit
	

vbu57 // Trigger BU_UDBAL - Before update unadvanced balance

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Undisbursed balance cannot be file-maintained on loans using undisbursed
	processing
	*/
	if ln.aruf do Runtime.setErrSTBLER("LN","FMUDBAL") quit:ER 
	quit
	

vbu58 // Trigger BU_WDLMTP - Before Update Withdrawal Limit Process

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*-----Revision History--------------------------------------------
	12/15/00 - RAJARAMD - 42288
		   Modified trigger to add code if LN.PBLSTDT is not defined,
		   and if LN.PBFRE is defined , the current system processing
		   date (TJD) will be defaulted into the LN.PBLSTDT
		   Modified the trigger to add code if LN.ADJCOL is enabled ,
		   the LN.COLLIM will be recalculated as the sum of
		   LNCOL.PLDGAMT for all the loan collateral records securing
		   the loan.
		   Modified the trigger to add code if LN.COLLIMPR is enabled,
		   this trigger will default the lesser of the LN.CRLMT and
		   the LN.COLLIM into the LN.WDLMT.

	*/
	// Check for Loan Withdrawal Limit Processing
	if 'ln.revf,ln.wdlmtp,ln.wdlmt'="" set ln.wdlmt=ln.crlmt

	if ln.pbfre do {
		if ln.pblstdt="" set ln.pblstdt=%SystemDate
		if ln.pbnxtdt="" set ln.pbnxtdt=$$NJD^UFRE(ln.pblstdt,ln.pbfre) quit:ER
		}

	if ln.adjcol do { quit:ER
		new rs,xcollim,totamt,XCID
		set XCID=ln.cid
		set totamt=0
		type ResultSet rs=Db.select("PLDGAMT","LNCOL","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next() do {
				set xcollim=rs.getCol(1)
				set totamt=totamt+xcollim
				}
		set ln.collim=totamt
		}

	if ln.collimpr do { quit:ER
		if (ln.crlmt<ln.collim) set ln.wdlmt=ln.crlmt
		else  set ln.wdlmt=ln.collim
		}
	quit


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordLN ln

	if (%O = 2) do vload

	if vobj(ln,1).exists() do {

		if ln.acctname.length()>25 set vRM = $$^MSG(1076,25) do vdderr("ACCTNAME", vRM) quit
		if ln.title1.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TITLE1", vRM) quit
		if ln.title2.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TITLE2", vRM) quit
		if ln.title3.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TITLE3", vRM) quit
		if ln.title4.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TITLE4", vRM) quit
	}

	if vobj(ln,49).exists() do {

		set X = ln.anpp if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("ANPP", vRM) quit
		if '("01"[ln.ARUF) set vRM=$$^MSG(742,"L") do vdderr("ARUF", vRM) quit
		if '("01"[ln.CPF) set vRM=$$^MSG(742,"L") do vdderr("CPF", vRM) quit
		if ln.custnot.length()>10 set vRM = $$^MSG(1076,10) do vdderr("CUSTNOT", vRM) quit
		set X = ln.ddra if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("DDRA", vRM) quit
		set X = ln.ddrd if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DDRD", vRM) quit
		if ln.iacm.length()>2 set vRM = $$^MSG(1076,2) do vdderr("IACM", vRM) quit
		set X = ln.iam if 'X.isNull(),'Db.isDefined("STBLIAM","X") set vRM = $$^MSG(1485,X) do vdderr("IAM", vRM) quit
		set X = ln.icm if 'X.isNull(),'Db.isDefined("STBLICM","X") set vRM = $$^MSG(1485,X) do vdderr("ICM", vRM) quit
		set X = ln.idp if 'X.isNull(),'Db.isDefined("STBLIDP","X") set vRM = $$^MSG(1485,X) do vdderr("IDP", vRM) quit
		set X = ln.incdr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INCDR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.irb if 'X.isNull(),'Db.isDefined("STBLGRPI","X") set vRM = $$^MSG(1485,X) do vdderr("IRB", vRM) quit
		if '("01"[ln.IRCB) set vRM=$$^MSG(742,"L") do vdderr("IRCB", vRM) quit
		set X = ln.maxdrct if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("MAXDRCT", vRM) quit
		set X = ln.minacr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MINACR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mindr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MINDR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.minopt if 'X.isNull(),'Db.isDefined("STBLMINOPT","X") set vRM = $$^MSG(1485,X) do vdderr("MINOPT", vRM) quit
		if '("01"[ln.NEGACRPO) set vRM=$$^MSG(742,"L") do vdderr("NEGACRPO", vRM) quit
		set X = ln.negipo if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("NEGIPO", vRM) quit
		set X = ln.odio if 'X.isNull(),'Db.isDefined("STBLODIO","X") set vRM = $$^MSG(1485,X) do vdderr("ODIO", vRM) quit
		set X = ln.odo if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("ODO", vRM) quit
		if ln.pap.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PAP", vRM) quit
		set X = ln.pas if 'X.isNull(),'Db.isDefined("LNPAS2","X") set vRM = $$^MSG(1485,X) do vdderr("PAS", vRM) quit
		if ln.pcm.length()>3 set vRM = $$^MSG(1076,3) do vdderr("PCM", vRM) quit
		if ln.pdag.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PDAG", vRM) quit
		set X = ln.pmtdelqr if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PMTDELQR", vRM) quit
		if ln.pmtgrc.length()>6 set vRM = $$^MSG(1076,6) do vdderr("PMTGRC", vRM) quit
		set X = ln.pmtmin if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMTMIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.popt.length()>6 set vRM = $$^MSG(1076,6) do vdderr("POPT", vRM) quit
		set X = ln.ppf if 'X.isNull(),'Db.isDefined("STBLPPF","X") set vRM = $$^MSG(1485,X) do vdderr("PPF", vRM) quit
		set X = ln.pvo if 'X.isNull(),'Db.isDefined("STBLPVO","X") set vRM = $$^MSG(1485,X) do vdderr("PVO", vRM) quit
		set X = ln.sbwamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SBWAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.scc.length()>3 set vRM = $$^MSG(1076,3) do vdderr("SCC", vRM) quit
		if '("01"[ln.SIBF) set vRM=$$^MSG(742,"L") do vdderr("SIBF", vRM) quit
		set X = ln.trb if 'X.isNull(),'Db.isDefined("STBLDC","X") set vRM = $$^MSG(1485,X) do vdderr("TRB", vRM) quit
	}

	if vobj(ln,50).exists() do {

		set X = ln.acngrp if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("ACNGRP", vRM) quit
		if '("01"[ln.ANLSYS) set vRM=$$^MSG(742,"L") do vdderr("ANLSYS", vRM) quit
		set X = ln.aomcode if 'X.isNull(),'Db.isDefined("STBLCINTMET","X") set vRM = $$^MSG(1485,X) do vdderr("AOMCODE", vRM) quit
		if ln.atn.length()>50 set vRM = $$^MSG(1076,50) do vdderr("ATN", vRM) quit
		set X = ln.cc if 'X.isNull(),'Db.isDefined("UTBLCCNTR","X") set vRM = $$^MSG(1485,X) do vdderr("CC", vRM) quit
		set X = ln.ccode if 'X.isNull(),'Db.isDefined("UTBLCC","X") set vRM = $$^MSG(1485,X) do vdderr("CCODE", vRM) quit
		set X = ln.cls if 'X.isNull(),'Db.isDefined("STBLCLS","X") set vRM = $$^MSG(1485,X) do vdderr("CLS", vRM) quit
		if '("01"[ln.COMM) set vRM=$$^MSG(742,"L") do vdderr("COMM", vRM) quit
		if ln.crcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("CRCD", vRM) quit
		if '("01"[ln.CUSTOM1) set vRM=$$^MSG(742,"L") do vdderr("CUSTOM1", vRM) quit
		if '("01"[ln.CUSTOM2) set vRM=$$^MSG(742,"L") do vdderr("CUSTOM2", vRM) quit
		if '("01"[ln.CUSTOM3) set vRM=$$^MSG(742,"L") do vdderr("CUSTOM3", vRM) quit
		if '("01"[ln.EMPLBEN) set vRM=$$^MSG(742,"L") do vdderr("EMPLBEN", vRM) quit
		set X = ln.emplno if 'X.isNull(),'Db.isDefined("UTBLEMPLOYER","X") set vRM = $$^MSG(1485,X) do vdderr("EMPLNO", vRM) quit
		if ln.feepln.length()>5 set vRM = $$^MSG(1076,5) do vdderr("FEEPLN", vRM) quit
		set X = ln.fldstaff if 'X.isNull(),'Db.isDefined("UTBLFLDSTAFF","X") set vRM = $$^MSG(1485,X) do vdderr("FLDSTAFF", vRM) quit
		set X = ln.glsc if 'X.isNull(),'Db.isDefined("UTBLGLSC","X") set vRM = $$^MSG(1485,X) do vdderr("GLSC", vRM) quit
		set X = ln.grp if 'X.isNull(),'Db.isDefined("STBLGRP","CLS=""L"",GRP=:X") set vRM = $$^MSG(1485,X) do vdderr("GRP", vRM) quit
		if '("01"[ln.HIGHVOL) set vRM=$$^MSG(742,"L") do vdderr("HIGHVOL", vRM) quit
		set X = ln.lfpc if 'X.isNull(),'Db.isDefined("STBLLFSC1","X") set vRM = $$^MSG(1485,X) do vdderr("LFPC", vRM) quit
		if ln.lfsc.length()>6 set vRM = $$^MSG(1076,6) do vdderr("LFSC", vRM) quit
		if ln.lnm.length()>20 set vRM = $$^MSG(1076,20) do vdderr("LNM", vRM) quit
		set X = ln.mf if 'X.isNull(),'Db.isDefined("UTBLMF","X") set vRM = $$^MSG(1485,X) do vdderr("MF", vRM) quit
		set X = ln.pers if 'X.isNull(),'Db.isDefined("STBLPERS","X") set vRM = $$^MSG(1485,X) do vdderr("PERS", vRM) quit
		if '("01"[ln.REGCC) set vRM=$$^MSG(742,"L") do vdderr("REGCC", vRM) quit
		set X = ln.regccexc if 'X.isNull(),'Db.isDefined("STBLREGCCX","X") set vRM = $$^MSG(1485,X) do vdderr("REGCCEXC", vRM) quit
		set X = ln.regccexp if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("REGCCEXP", vRM) quit
		set X = ln.regd if 'X.isNull(),'Db.isDefined("STBLREGD1","X") set vRM = $$^MSG(1485,X) do vdderr("REGD", vRM) quit
		set X = ln.secgrp if 'X.isNull(),'Db.isDefined("UTBLSECGRP","X") set vRM = $$^MSG(1485,X) do vdderr("SECGRP", vRM) quit
		set X = ln.subcd if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("SUBCD", vRM) quit
		set X = ln.type if 'X.isNull(),'Db.isDefined("PRODDFTL","X") set vRM = $$^MSG(1485,X) do vdderr("TYPE", vRM) quit
	}

	if vobj(ln,51).exists() do {

		if '("01"[ln.ADF) set vRM=$$^MSG(742,"L") do vdderr("ADF", vRM) quit
		set X = ln.bal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.balcol if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BALCOL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.balint if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BALINT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ccl if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("CCL", vRM) quit
		set X = ln.ccld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CCLD", vRM) quit
		set X = ln.chkhld if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CHKHLD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cntcr if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("CNTCR", vRM) quit
		set X = ln.cntdr if 'X.isNull(),X'?1.10N,X'?1"-"1.9N set vRM=$$^MSG(742,"N") do vdderr("CNTDR", vRM) quit
		set X = ln.coa if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.donrsk if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DONRSK"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.ENTF) set vRM=$$^MSG(742,"L") do vdderr("ENTF", vRM) quit
		set X = ln.flttbl if 'X.isNull(),'Db.isDefined("UTBLRTTBL","X") set vRM = $$^MSG(1485,X) do vdderr("FLTTBL", vRM) quit
		set X = ln.fmld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("FMLD", vRM) quit
		set X = ln.habl1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.HABL1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.habl2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.HABL2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.hldtbl if 'X.isNull(),'Db.isDefined("UTBLRTTBL","X") set vRM = $$^MSG(1485,X) do vdderr("HLDTBL", vRM) quit
		set X = ln.icpa if 'X.isNull(),'Db.isDefined("UTBLICPA","X") set vRM = $$^MSG(1485,X) do vdderr("ICPA", vRM) quit
		set X = ln.lnsa if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("LNSA", vRM) quit
		set X = ln.lpdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LPDT", vRM) quit
		set X = ln.odd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ODD", vRM) quit
		if '("01"[ln.PBI) set vRM=$$^MSG(742,"L") do vdderr("PBI", vRM) quit
		if '("01"[ln.PHLD) set vRM=$$^MSG(742,"L") do vdderr("PHLD", vRM) quit
		set X = ln.rec if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.REC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.REVF) set vRM=$$^MSG(742,"L") do vdderr("REVF", vRM) quit
		if '("01"[ln.RFLG) set vRM=$$^MSG(742,"L") do vdderr("RFLG", vRM) quit
		set X = ln.rskopt if 'X.isNull(),'Db.isDefined("STBLRSKOPT","X") set vRM = $$^MSG(1485,X) do vdderr("RSKOPT", vRM) quit
		set X = ln.stat if 'X.isNull(),'Db.isDefined("STBLSTATL","X") set vRM = $$^MSG(1485,X) do vdderr("STAT", vRM) quit
		set X = ln.stfnet if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.STFNET"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.stp.length()>20 set vRM = $$^MSG(1076,20) do vdderr("STP", vRM) quit
		set X = ln.stp2 if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("STP2", vRM) quit
		set X = ln.stp3 if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("STP3", vRM) quit
		set X = ln.stp4 if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("STP4", vRM) quit
		set X = ln.stp5 if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("STP5", vRM) quit
		set X = ln.teb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TEB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("TLD", vRM) quit
		set X = ln.udbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.UDBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,52).exists() do {

		set X = ln.amodt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("AMODT", vRM) quit
		set X = ln.boo if 'X.isNull(),'Db.isDefined("UTBLBRCD","X") set vRM = $$^MSG(1485,X) do vdderr("BOO", vRM) quit
		if ln.convacn.length()>40 set vRM = $$^MSG(1076,40) do vdderr("CONVACN", vRM) quit
		set X = ln.convdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CONVDT", vRM) quit
		set X = ln.dfp if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DFP", vRM) quit
		set X = ln.dtc if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DTC", vRM) quit
		set X = ln.dtnt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DTNT", vRM) quit
		set X = ln.fma if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("FMA", vRM) quit
		set X = ln.fmo if 'X.isNull(),'Db.isDefined("STBLFMO","X") set vRM = $$^MSG(1485,X) do vdderr("FMO", vRM) quit
		set X = ln.hisctf if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("HISCTF", vRM) quit
		set X = ln.iro if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IRO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.maxbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MAXBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.maxfta if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MAXFTA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.maxftd if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("MAXFTD", vRM) quit
		set X = ln.mincl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MINCL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.odt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ODT", vRM) quit
		set X = ln.off if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFF", vRM) quit
		set X = ln.off2 if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFF2", vRM) quit
		set X = ln.off3 if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFF3", vRM) quit
		set X = ln.off4 if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFF4", vRM) quit
		set X = ln.off5 if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFF5", vRM) quit
		set X = ln.onp if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("ONP", vRM) quit
		set X = ln.pmtorg if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMTORG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.refnum.length()>12 set vRM = $$^MSG(1076,12) do vdderr("REFNUM", vRM) quit
		set X = ln.rescd if 'X.isNull(),'Db.isDefined("UTBLRESCD","X") set vRM = $$^MSG(1485,X) do vdderr("RESCD", vRM) quit
		if '("01"[ln.TRUNC) set vRM=$$^MSG(742,"L") do vdderr("TRUNC", vRM) quit
	}

	if vobj(ln,53).exists() do {

		if '("01"[ln.AIPR) set vRM=$$^MSG(742,"L") do vdderr("AIPR", vRM) quit
		set X = ln.ambas if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("AMBAS", vRM) quit
		set X = ln.amtreq if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,1,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.AMTREQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.busopt if 'X.isNull(),'Db.isDefined("STBLBUSOPT","X") set vRM = $$^MSG(1485,X) do vdderr("BUSOPT", vRM) quit
		set X = ln.clmd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CLMD", vRM) quit
		set X = ln.clps if 'X.isNull(),'Db.isDefined("STBLCLPS","X") set vRM = $$^MSG(1485,X) do vdderr("CLPS", vRM) quit
		set X = ln.cnvprd if 'X.isNull(),'Db.isDefined("PRODDFTL","X") set vRM = $$^MSG(1485,X) do vdderr("CNVPRD", vRM) quit
		set X = ln.crlmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CRLMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ero if 'X.isNull(),'Db.isDefined("STBLERO","X") set vRM = $$^MSG(1485,X) do vdderr("ERO", vRM) quit
		if '("01"[ln.IPD) set vRM=$$^MSG(742,"L") do vdderr("IPD", vRM) quit
		set X = ln.lrd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LRD", vRM) quit
		set X = ln.lriab if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LRIAB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lripb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LRIPB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lrpb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LRPB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("MDT", vRM) quit
		set X = ln.nbdc if 'X.isNull(),'Db.isDefined("UTBLNBD","X") set vRM = $$^MSG(1485,X) do vdderr("NBDC", vRM) quit
		set X = ln.nbf if 'X.isNull(),'Db.isDefined("STBLLBF","X") set vRM = $$^MSG(1485,X) do vdderr("NBF", vRM) quit
		set X = ln.nobf if 'X.isNull(),'Db.isDefined("STBLLBF","X") set vRM = $$^MSG(1485,X) do vdderr("NOBF", vRM) quit
		set X = ln.oltp if 'X.isNull() set vRM = $$VAL^DBSVER("N",9,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.OLTP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.org if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ORG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.ptrm.length()>8 set vRM = $$^MSG(1076,8) do vdderr("PTRM", vRM) quit
		if ln.rencd.length()>8 set vRM = $$^MSG(1076,8) do vdderr("RENCD", vRM) quit
		set X = ln.rro if 'X.isNull(),'Db.isDefined("STBLRRO","X") set vRM = $$^MSG(1485,X) do vdderr("RRO", vRM) quit
		if '("01"[ln.SWPEL) set vRM=$$^MSG(742,"L") do vdderr("SWPEL", vRM) quit
		set X = ln.tdr if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TDR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tracn if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("TRACN", vRM) quit
		if ln.trm.length()>8 set vRM = $$^MSG(1076,8) do vdderr("TRM", vRM) quit
	}

	if vobj(ln,54).exists() do {

		set X = ln.acr if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acs if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ACS", vRM) quit
		set X = ln.copy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.coytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.daa if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DAA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intdef if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTDEF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ipl if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IPL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.IPLCF) set vRM=$$^MSG(742,"L") do vdderr("IPLCF", vRM) quit
		set X = ln.ipnd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IPND"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ipy if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.iun if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IUN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.iytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.NAI) set vRM=$$^MSG(742,"L") do vdderr("NAI", vRM) quit
		set X = ln.negacr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NEGACR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.negacrun if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NEGACRUN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.negipl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NEGIPL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.negipy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NEGIPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.negiytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NEGIYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.prefint if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PREFINT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.probal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PROBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.proind if 'X.isNull(),'Db.isDefined("INDEX","X") set vRM = $$^MSG(1485,X) do vdderr("PROIND", vRM) quit
		set X = ln.recpy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RECPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.recytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RECYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.refint if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.REFINT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.trate if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.trexd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("TREXD", vRM) quit
	}

	if vobj(ln,55).exists() do {

		set X = ln.cbfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]CBFRE",0) if 'vRM.get().isNull() do vdderr("CBFRE", vRM) quit
		set X = ln.cbmet if 'X.isNull(),'Db.isDefined("STBLCBMET","X") set vRM = $$^MSG(1485,X) do vdderr("CBMET", vRM) quit
		set X = ln.cboff if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("CBOFF", vRM) quit
		set X = ln.cbond if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CBOND", vRM) quit
		set X = ln.cbpld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CBPLD", vRM) quit
		set X = ln.cbpnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CBPND", vRM) quit
		set X = ln.dafpy if 'X.isNull() set vRM = $$VAL^DBSVER("N",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DAFPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dafyd if 'X.isNull() set vRM = $$VAL^DBSVER("N",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DAFYD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.darcexpd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DARCEXPD", vRM) quit
		set X = ln.darcls if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DARCLS", vRM) quit
		set X = ln.darcovr if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DARCOVR", vRM) quit
		if '("01"[ln.DLCAF) set vRM=$$^MSG(742,"L") do vdderr("DLCAF", vRM) quit
		set X = ln.drbl if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DRBL", vRM) quit
		set X = ln.extamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.EXTAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.extldt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EXTLDT", vRM) quit
		set X = ln.exttot if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("EXTTOT", vRM) quit
		set X = ln.fisbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FISBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.fisint if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FISINT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.flca if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FLCA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lchg if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LCHG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lcla if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LCLA", vRM) quit
		set X = ln.ndafpy if 'X.isNull() set vRM = $$VAL^DBSVER("N",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NDAFPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ndafyd if 'X.isNull() set vRM = $$VAL^DBSVER("N",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NDAFYD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.suspect if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("SUSPECT", vRM) quit
		set X = ln.unapf if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.UNAPF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.WOFF) set vRM=$$^MSG(742,"L") do vdderr("WOFF", vRM) quit
	}

	if vobj(ln,56).exists() do {

		set X = ln.adtar if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("ADTAR", vRM) quit
		set X = ln.alpdue if 'X.isNull(),'Db.isDefined("STBLALPDUE","X") set vRM = $$^MSG(1485,X) do vdderr("ALPDUE", vRM) quit
		set X = ln.alpmin if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ALPMIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.ALPRTY) set vRM=$$^MSG(742,"L") do vdderr("ALPRTY", vRM) quit
		set X = ln.auptcid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("AUPTCID", vRM) quit
		if '("01"[ln.CCBIND) set vRM=$$^MSG(742,"L") do vdderr("CCBIND", vRM) quit
		set X = ln.cfreq if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]CFREQ",0) if 'vRM.get().isNull() do vdderr("CFREQ", vRM) quit
		set X = ln.cmrate if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CMRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cmrindx if 'X.isNull(),'Db.isDefined("INDEX","X") set vRM = $$^MSG(1485,X) do vdderr("CMRINDX", vRM) quit
		set X = ln.cncal if 'X.isNull(),'Db.isDefined("UTBLNBD","X") set vRM = $$^MSG(1485,X) do vdderr("CNCAL", vRM) quit
		set X = ln.cnoff if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CNOFF", vRM) quit
		set X = ln.cnvdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CNVDT", vRM) quit
		if '("01"[ln.FPIND) set vRM=$$^MSG(742,"L") do vdderr("FPIND", vRM) quit
		set X = ln.pamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppacp if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPACP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppal if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppdpl if 'X.isNull(),'Db.isDefined("UTBLPPDPL","X") set vRM = $$^MSG(1485,X) do vdderr("PPDPL", vRM) quit
		set X = ln.ppfreq if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]PPFREQ",0) if 'vRM.get().isNull() do vdderr("PPFREQ", vRM) quit
		set X = ln.ppld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PPLD", vRM) quit
		set X = ln.ppnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PPND", vRM) quit
		set X = ln.ppnopl if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("PPNOPL", vRM) quit
		set X = ln.ppnopp if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("PPNOPP", vRM) quit
		if '("01"[ln.RCBIND) set vRM=$$^MSG(742,"L") do vdderr("RCBIND", vRM) quit
		set X = ln.rdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("RDT", vRM) quit
		if '("01"[ln.RFMO) set vRM=$$^MSG(742,"L") do vdderr("RFMO", vRM) quit
		set X = ln.rfreq if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]RFREQ",0) if 'vRM.get().isNull() do vdderr("RFREQ", vRM) quit
		set X = ln.rncal if 'X.isNull(),'Db.isDefined("UTBLNBD","X") set vRM = $$^MSG(1485,X) do vdderr("RNCAL", vRM) quit
		if '("01"[ln.RNFLG) set vRM=$$^MSG(742,"L") do vdderr("RNFLG", vRM) quit
		set X = ln.rnoff if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("RNOFF", vRM) quit
		if '("01"[ln.RPMO) set vRM=$$^MSG(742,"L") do vdderr("RPMO", vRM) quit
		set X = ln.rrmo if 'X.isNull(),'Db.isDefined("UTBLRRMO","X") set vRM = $$^MSG(1485,X) do vdderr("RRMO", vRM) quit
		if '("01"[ln.SRCBIND) set vRM=$$^MSG(742,"L") do vdderr("SRCBIND", vRM) quit
		set X = ln.srcdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SRCDT", vRM) quit
		set X = ln.strate if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.STRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.strcal if 'X.isNull(),'Db.isDefined("UTBLNBD","X") set vRM = $$^MSG(1485,X) do vdderr("STRCAL", vRM) quit
		set X = ln.strindx if 'X.isNull(),'Db.isDefined("INDEX","X") set vRM = $$^MSG(1485,X) do vdderr("STRINDX", vRM) quit
		set X = ln.stroff if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("STROFF", vRM) quit
		set X = ln.uppen if 'X.isNull(),'Db.isDefined("UTBLLNPPN","X") set vRM = $$^MSG(1485,X) do vdderr("UPPEN", vRM) quit
	}

	if vobj(ln,57).exists() do {

		if '("01"[ln.AIR) set vRM=$$^MSG(742,"L") do vdderr("AIR", vRM) quit
		set X = ln.aniriv if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ANIRIV"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.anirld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ANIRLD", vRM) quit
		set X = ln.anirnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ANIRND", vRM) quit
		set X = ln.aniro if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ANIRO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.diaa if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIAA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.diald if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIALD", vRM) quit
		set X = ln.diand if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIAND", vRM) quit
		set X = ln.dic if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dimxb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIMXB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dimxl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIMXL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dimxy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIMXY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dirfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]DIRFRE",0) if 'vRM.get().isNull() do vdderr("DIRFRE", vRM) quit
		set X = ln.dirld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIRLD", vRM) quit
		set X = ln.dirnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIRND", vRM) quit
		set X = ln.ditgacn if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("DITGACN", vRM) quit
		set X = ln.diu if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIU"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.eirn if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.EIRN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.eod if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EOD", vRM) quit
		if '("01"[ln.FLAT) set vRM=$$^MSG(742,"L") do vdderr("FLAT", vRM) quit
		set X = ln.iacf if 'X.isNull(),'Db.isDefined("STBLIACF","X") set vRM = $$^MSG(1485,X) do vdderr("IACF", vRM) quit
		set X = ln.ichld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ICHLD", vRM) quit
		set X = ln.ichnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ICHND", vRM) quit
		set X = ln.icpf if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]ICPF",0) if 'vRM.get().isNull() do vdderr("ICPF", vRM) quit
		set X = ln.idefly if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IDEFLY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.idf if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,8) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IDF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intdefpty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTDEFPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intdeftytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTDEFTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmn if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmno if 'X.isNull(),'Db.isDefined("STBLINTMNO","X") set vRM = $$^MSG(1485,X) do vdderr("INTMNO", vRM) quit
		set X = ln.intmx if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMX"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intramt1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTRAMT1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intramt2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTRAMT2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intramt3 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTRAMT3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intrexp1 if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("INTREXP1", vRM) quit
		set X = ln.intrexp2 if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("INTREXP2", vRM) quit
		set X = ln.intrexp3 if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("INTREXP3", vRM) quit
		set X = ln.intrrat1 if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTRRAT1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intrrat2 if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTRRAT2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intrrat3 if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTRRAT3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.invl if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INVL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.irf if 'X.isNull(),'Db.isDefined("STBLIRF","X") set vRM = $$^MSG(1485,X) do vdderr("IRF", vRM) quit
		set X = ln.irn if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IRN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.irsexm if 'X.isNull(),'Db.isDefined("STBLIRSEXM","X") set vRM = $$^MSG(1485,X) do vdderr("IRSEXM", vRM) quit
		set X = ln.nalpb if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NALPB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.namxb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NAMXB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.narl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NARL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.RPIDC) set vRM=$$^MSG(742,"L") do vdderr("RPIDC", vRM) quit
		set X = ln.sch if 'X.isNull(),'Db.isDefined("UTBLRATE","X") set vRM = $$^MSG(1485,X) do vdderr("SCH", vRM) quit
	}

	if vobj(ln,58).exists() do {

		set X = ln.anld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ANLD", vRM) quit
		set X = ln.anoff if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("ANOFF", vRM) quit
		set X = ln.anoffdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ANOFFDT", vRM) quit
		set X = ln.apcnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("APCND", vRM) quit
		if '("01"[ln.AUO) set vRM=$$^MSG(742,"L") do vdderr("AUO", vRM) quit
		set X = ln.aytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.AYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cues if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CUES"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cuin if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CUIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cupr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CUPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dico if 'X.isNull(),'Db.isDefined("STBLDICO","X") set vRM = $$^MSG(1485,X) do vdderr("DICO", vRM) quit
		set X = ln.dicytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DICYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.DRF) set vRM=$$^MSG(742,"L") do vdderr("DRF", vRM) quit
		if '("01"[ln.EACIP) set vRM=$$^MSG(742,"L") do vdderr("EACIP", vRM) quit
		if '("01"[ln.FPAF) set vRM=$$^MSG(742,"L") do vdderr("FPAF", vRM) quit
		set X = ln.fpc01 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC01", vRM) quit
		set X = ln.fpc02 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC02", vRM) quit
		set X = ln.fpc03 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC03", vRM) quit
		set X = ln.fpc04 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC04", vRM) quit
		set X = ln.fpc05 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC05", vRM) quit
		set X = ln.fpc06 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC06", vRM) quit
		set X = ln.fpc07 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC07", vRM) quit
		set X = ln.fpc08 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC08", vRM) quit
		set X = ln.fpc09 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC09", vRM) quit
		set X = ln.fpc10 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC10", vRM) quit
		set X = ln.fpc11 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC11", vRM) quit
		set X = ln.fpc12 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPC12", vRM) quit
		if '("01"[ln.INTCAP) set vRM=$$^MSG(742,"L") do vdderr("INTCAP", vRM) quit
		set X = ln.ispytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ISPYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.PFLG) set vRM=$$^MSG(742,"L") do vdderr("PFLG", vRM) quit
		set X = ln.pmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmtpi if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMTPI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmttrs if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMTTRS"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.poamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.POAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppa if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.PPFLG) set vRM=$$^MSG(742,"L") do vdderr("PPFLG", vRM) quit
		set X = ln.pvar if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PVAR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.rnd.length()>6 set vRM = $$^MSG(1076,6) do vdderr("RND", vRM) quit
		set X = ln.ropt if 'X.isNull(),'Db.isDefined("STBLROPT","X") set vRM = $$^MSG(1485,X) do vdderr("ROPT", vRM) quit
		set X = ln.schbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SCHBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.schld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SCHLD", vRM) quit
		set X = ln.schnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SCHND", vRM) quit
		set X = ln.schnum if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("SCHNUM", vRM) quit
		set X = ln.schseq if 'X.isNull() set vRM = $$VAL^DBSVER("N",13,0,,,,,8) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SCHSEQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tdue if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TDUE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tflg if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("TFLG", vRM) quit
		set X = ln.unes if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.UNES"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.unin if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.UNIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.unpr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.UNPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,60).exists() do {

		set X = ln.anptld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ANPTLD", vRM) quit
		set X = ln.anptnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ANPTND", vRM) quit
		set X = ln.anpto if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ANPTO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.caf if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CAF", vRM) quit
		set X = ln.cntc if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CNTC", vRM) quit
		if ln.compirn.length()>10 set vRM = $$^MSG(1076,10) do vdderr("COMPIRN", vRM) quit
		set X = ln.ichm if 'X.isNull(),'Db.isDefined("STBLICHM","X") set vRM = $$^MSG(1485,X) do vdderr("ICHM", vRM) quit
		set X = ln.index if 'X.isNull(),'Db.isDefined("INDEX","X") set vRM = $$^MSG(1485,X) do vdderr("INDEX", vRM) quit
		if ln.index1.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX1", vRM) quit
		if ln.index10.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX10", vRM) quit
		if ln.index2.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX2", vRM) quit
		if ln.index3.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX3", vRM) quit
		if ln.index4.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX4", vRM) quit
		if ln.index5.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX5", vRM) quit
		if ln.index6.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX6", vRM) quit
		if ln.index7.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX7", vRM) quit
		if ln.index8.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX8", vRM) quit
		if ln.index9.length()>20 set vRM = $$^MSG(1076,20) do vdderr("INDEX9", vRM) quit
		set X = ln.indo if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INDO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]INTFRE",0) if 'vRM.get().isNull() do vdderr("INTFRE", vRM) quit
		set X = ln.intmat if 'X.isNull(),'Db.isDefined("UTBLMATATT","X") set vRM = $$^MSG(1485,X) do vdderr("INTMAT", vRM) quit
		set X = ln.intmndc if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMNDC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmnic if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMNIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmxdc if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMXDC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmxdy if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMXDY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmxic if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMXIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intmxiy if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTMXIY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.intoff if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("INTOFF", vRM) quit
		set X = ln.intoffcl if 'X.isNull(),'Db.isDefined("UTBLNBD","X") set vRM = $$^MSG(1485,X) do vdderr("INTOFFCL", vRM) quit
		set X = ln.intoffdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("INTOFFDT", vRM) quit
		if ln.intspr.length()>9 set vRM = $$^MSG(1076,9) do vdderr("INTSPR", vRM) quit
		set X = ln.ipf if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]IPF",0) if 'vRM.get().isNull() do vdderr("IPF", vRM) quit
		set X = ln.numch if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("NUMCH", vRM) quit
		set X = ln.pcfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]PCFRE",0) if 'vRM.get().isNull() do vdderr("PCFRE", vRM) quit
		set X = ln.pchld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PCHLD", vRM) quit
		set X = ln.pchm if 'X.isNull(),'Db.isDefined("STBLPCHM","X") set vRM = $$^MSG(1485,X) do vdderr("PCHM", vRM) quit
		set X = ln.pchnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PCHND", vRM) quit
		set X = ln.pcoff if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PCOFF", vRM) quit
		set X = ln.pcoffdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PCOFFDT", vRM) quit
		if '("01"[ln.PIACM) set vRM=$$^MSG(742,"L") do vdderr("PIACM", vRM) quit
		set X = ln.pmnddc if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMNDDC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmndic if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMNDIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxddc if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXDDC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxddl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXDDL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxddy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXDDY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxdic if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXDIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxdil if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXDIL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxdiy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXDIY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxpdc if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXPDC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxpdl if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXPDL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxpdy if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXPDY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxpic if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXPIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxpil if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXPIL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmxpiy if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PMXPIY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ppinc if 'X.isNull() set vRM = $$VAL^DBSVER("$",8,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPINC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.prcb if 'X.isNull(),'Db.isDefined("STBLPRCB","X") set vRM = $$^MSG(1485,X) do vdderr("PRCB", vRM) quit
		set X = ln.rafre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]RAFRE",0) if 'vRM.get().isNull() do vdderr("RAFRE", vRM) quit
		set X = ln.rald if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("RALD", vRM) quit
		set X = ln.rand if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("RAND", vRM) quit
		set X = ln.randoff if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("RANDOFF", vRM) quit
		if ln.rndmtd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("RNDMTD", vRM) quit
		if ln.trmmx.length()>8 set vRM = $$^MSG(1076,8) do vdderr("TRMMX", vRM) quit
	}

	if vobj(ln,61).exists() do {

		set X = ln.chkcnt if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CHKCNT", vRM) quit
		if '("01"[ln.CHKEURO) set vRM=$$^MSG(742,"L") do vdderr("CHKEURO", vRM) quit
		if '("01"[ln.CHKISS) set vRM=$$^MSG(742,"L") do vdderr("CHKISS", vRM) quit
		set X = ln.chkout if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("CHKOUT", vRM) quit
		set X = ln.chks if 'X.isNull(),'Db.isDefined("UTBLCHKS","X") set vRM = $$^MSG(1485,X) do vdderr("CHKS", vRM) quit
		set X = ln.fltd1 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FLTD1", vRM) quit
		set X = ln.fltd2 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FLTD2", vRM) quit
		set X = ln.fltd3 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FLTD3", vRM) quit
		set X = ln.fltd4 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FLTD4", vRM) quit
		set X = ln.fltd5 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FLTD5", vRM) quit
		set X = ln.fltp1 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("FLTP1", vRM) quit
		set X = ln.fltp2 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("FLTP2", vRM) quit
		set X = ln.fltp3 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("FLTP3", vRM) quit
		set X = ln.fltp4 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("FLTP4", vRM) quit
		set X = ln.fltp5 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("FLTP5", vRM) quit
		set X = ln.hldd1 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("HLDD1", vRM) quit
		set X = ln.hldd2 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("HLDD2", vRM) quit
		set X = ln.hldd3 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("HLDD3", vRM) quit
		set X = ln.hldd4 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("HLDD4", vRM) quit
		set X = ln.hldd5 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("HLDD5", vRM) quit
		set X = ln.hldp1 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("HLDP1", vRM) quit
		set X = ln.hldp2 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("HLDP2", vRM) quit
		set X = ln.hldp3 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("HLDP3", vRM) quit
		set X = ln.hldp4 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("HLDP4", vRM) quit
		set X = ln.hldp5 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("HLDP5", vRM) quit
	}

	if vobj(ln,62).exists() do {

		if '("01"[ln.ACTIBPAY) set vRM=$$^MSG(742,"L") do vdderr("ACTIBPAY", vRM) quit
		if '("01"[ln.DSCHPR) set vRM=$$^MSG(742,"L") do vdderr("DSCHPR", vRM) quit
		if '("01"[ln.EFTDD) set vRM=$$^MSG(742,"L") do vdderr("EFTDD", vRM) quit
		if '("01"[ln.EFTDEB) set vRM=$$^MSG(742,"L") do vdderr("EFTDEB", vRM) quit
		if '("01"[ln.EFTREQ) set vRM=$$^MSG(742,"L") do vdderr("EFTREQ", vRM) quit
		set X = ln.lcadl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LCADL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lcan if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("LCAN", vRM) quit
		set X = ln.lcanl if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("LCANL", vRM) quit
		set X = ln.lcanlf if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("LCANLF", vRM) quit
		set X = ln.lcldl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LCLDL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lclnl if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("LCLNL", vRM) quit
		set X = ln.papl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAPL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.papy if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.paytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.sdta if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("SDTA", vRM) quit
		if '("01"[ln.SMET) set vRM=$$^MSG(742,"L") do vdderr("SMET", vRM) quit
		if ln.stmdscd.length()>30 set vRM = $$^MSG(1076,30) do vdderr("STMDSCD", vRM) quit
	}

	if vobj(ln,64).exists() do {

		set X = ln.baola if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BAOLA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dist1af if 'X.isNull() set vRM = $$VAL^DBSVER("N",9,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DIST1AF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dist1fre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]DIST1FRE",0) if 'vRM.get().isNull() do vdderr("DIST1FRE", vRM) quit
		set X = ln.dist1ld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST1LD", vRM) quit
		set X = ln.dist1nd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST1ND", vRM) quit
		set X = ln.dist2fre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]DIST2FRE",0) if 'vRM.get().isNull() do vdderr("DIST2FRE", vRM) quit
		set X = ln.dist2ld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST2LD", vRM) quit
		set X = ln.dist2nd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST2ND", vRM) quit
		set X = ln.dist3fre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]DIST3FRE",0) if 'vRM.get().isNull() do vdderr("DIST3FRE", vRM) quit
		set X = ln.dist3ld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST3LD", vRM) quit
		set X = ln.dist3nd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST3ND", vRM) quit
		set X = ln.dist4fre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]DIST4FRE",0) if 'vRM.get().isNull() do vdderr("DIST4FRE", vRM) quit
		set X = ln.dist4ld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST4LD", vRM) quit
		set X = ln.dist4nd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DIST4ND", vRM) quit
		set X = ln.dpmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DPMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dseq if 'X.isNull() set vRM = $$VAL^DBSVER("N",13,0,,,,,8) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DSEQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.EPA) set vRM=$$^MSG(742,"L") do vdderr("EPA", vRM) quit
		set X = ln.inta if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ladt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LADT", vRM) quit
		set X = ln.lcad if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LCAD", vRM) quit
		set X = ln.lcbo if 'X.isNull(),'Db.isDefined("STBLLCBO","X") set vRM = $$^MSG(1485,X) do vdderr("LCBO", vRM) quit
		set X = ln.lcefd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LCEFD", vRM) quit
		if '("01"[ln.LCHGNOTO) set vRM=$$^MSG(742,"L") do vdderr("LCHGNOTO", vRM) quit
		set X = ln.limit if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("LIMIT", vRM) quit
		if '("01"[ln.MDF) set vRM=$$^MSG(742,"L") do vdderr("MDF", vRM) quit
		set X = ln.olimit if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("OLIMIT", vRM) quit
		set X = ln.oseq if 'X.isNull() set vRM = $$VAL^DBSVER("N",13,0,,,,,8) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.OSEQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.PAF) set vRM=$$^MSG(742,"L") do vdderr("PAF", vRM) quit
		if ln.pmtdist.length()>120 set vRM = $$^MSG(1076,120) do vdderr("PMTDIST", vRM) quit
		if ln.pmtdistf.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PMTDISTF", vRM) quit
		set X = ln.tba if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TBA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,65).exists() do {

		if ln.ckc.length()>12 set vRM = $$^MSG(1076,12) do vdderr("CKC", vRM) quit
		set X = ln.cktyp if 'X.isNull(),'Db.isDefined("UTBLCHKS","X") set vRM = $$^MSG(1485,X) do vdderr("CKTYP", vRM) quit
		set X = ln.cod if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("COD", vRM) quit
		set X = ln.nock if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("NOCK", vRM) quit
		set X = ln.npc if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("NPC", vRM) quit
		if ln.ppdcat1.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT1", vRM) quit
		if ln.ppdcat10.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT10", vRM) quit
		if ln.ppdcat2.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT2", vRM) quit
		if ln.ppdcat3.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT3", vRM) quit
		if ln.ppdcat4.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT4", vRM) quit
		if ln.ppdcat5.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT5", vRM) quit
		if ln.ppdcat6.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT6", vRM) quit
		if ln.ppdcat7.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT7", vRM) quit
		if ln.ppdcat8.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT8", vRM) quit
		if ln.ppdcat9.length()>80 set vRM = $$^MSG(1076,80) do vdderr("PPDCAT9", vRM) quit
		if ln.scn.length()>12 set vRM = $$^MSG(1076,12) do vdderr("SCN", vRM) quit
	}

	if vobj(ln,66).exists() do {

		set X = ln.aoamtorg if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.AOAMTORG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.aprapp if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.APRAPP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.aprapp1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.APRAPP1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.aprmthd if 'X.isNull(),'Db.isDefined("STBLAPRMTHD","X") set vRM = $$^MSG(1485,X) do vdderr("APRMTHD", vRM) quit
		set X = ln.comfa if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COMFA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.comfp if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COMFP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.disamf if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISAMF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.disapr if 'X.isNull() set vRM = $$VAL^DBSVER("N",9,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISAPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dismip if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISMIP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dispmp if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISPMP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.disppi if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISPPI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.disppid if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DISPPID", vRM) quit
		set X = ln.distint if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISTINT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.distip if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISTIP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.distpmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISTPMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lvr if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("LVR", vRM) quit
		set X = ln.lvv if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("LVV", vRM) quit
		set X = ln.nfamtorg if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NFAMTORG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.nfplnorg.length()>6 set vRM = $$^MSG(1076,6) do vdderr("NFPLNORG", vRM) quit
		set X = ln.orgfa if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ORGFA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.orgfp if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ORGFP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa10a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA10A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa10f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA10F", vRM) quit
		set X = ln.pa10t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA10T", vRM) quit
		set X = ln.pa11a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA11A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa11f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA11F", vRM) quit
		set X = ln.pa11t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA11T", vRM) quit
		set X = ln.pa12a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA12A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa12f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA12F", vRM) quit
		set X = ln.pa12t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA12T", vRM) quit
		set X = ln.pa13a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA13A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa13f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA13F", vRM) quit
		set X = ln.pa13t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA13T", vRM) quit
		set X = ln.pa14a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA14A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa14f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA14F", vRM) quit
		set X = ln.pa14t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA14T", vRM) quit
		set X = ln.pa15a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA15A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa15f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA15F", vRM) quit
		set X = ln.pa15t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA15T", vRM) quit
		set X = ln.pa1a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA1A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa1f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA1F", vRM) quit
		set X = ln.pa1t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA1T", vRM) quit
		set X = ln.pa2a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA2A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa2f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA2F", vRM) quit
		set X = ln.pa2t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA2T", vRM) quit
		set X = ln.pa3a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA3A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa3f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA3F", vRM) quit
		set X = ln.pa3t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA3T", vRM) quit
		set X = ln.pa4a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA4A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa4f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA4F", vRM) quit
		set X = ln.pa4t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA4T", vRM) quit
		set X = ln.pa5a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA5A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa5f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA5F", vRM) quit
		set X = ln.pa5t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA5T", vRM) quit
		set X = ln.pa6a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA6A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa6f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA6F", vRM) quit
		set X = ln.pa6t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA6T", vRM) quit
		set X = ln.pa7a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA7A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa7f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA7F", vRM) quit
		set X = ln.pa7t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA7T", vRM) quit
		set X = ln.pa8a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA8A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa8f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA8F", vRM) quit
		set X = ln.pa8t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA8T", vRM) quit
		set X = ln.pa9a if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PA9A"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pa9f if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA9F", vRM) quit
		set X = ln.pa9t if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PA9T", vRM) quit
		set X = ln.rlvp if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("RLVP", vRM) quit
	}

	if vobj(ln,67).exists() do {

		set X = ln.ddbal1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal10 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL10"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal11 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL11"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal12 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL12"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal3 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal4 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL4"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal5 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL5"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal6 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL6"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal7 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL7"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal8 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL8"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbal9 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBAL9"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ddbalcur if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DDBALCUR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,68).exists() do {

		set X = ln.mebal1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal10 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL10"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal11 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL11"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal12 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL12"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal3 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal4 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL4"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal5 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL5"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal6 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL6"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal7 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL7"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal8 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL8"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mebal9 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MEBAL9"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef10 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF10"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef3 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef4 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF4"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef5 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF5"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef6 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF6"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef7 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF7"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef8 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF8"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.usrdef9 if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.USRDEF9"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,70).exists() do {

		if '("01"[ln.CMSFLG) set vRM=$$^MSG(742,"L") do vdderr("CMSFLG", vRM) quit
		if '("01"[ln.DIP) set vRM=$$^MSG(742,"L") do vdderr("DIP", vRM) quit
		if '("01"[ln.DLRP) set vRM=$$^MSG(742,"L") do vdderr("DLRP", vRM) quit
		if '("01"[ln.HIP) set vRM=$$^MSG(742,"L") do vdderr("HIP", vRM) quit
		if '("01"[ln.LIP) set vRM=$$^MSG(742,"L") do vdderr("LIP", vRM) quit
		if '("01"[ln.MSCP) set vRM=$$^MSG(742,"L") do vdderr("MSCP", vRM) quit
		if '("01"[ln.PTSP) set vRM=$$^MSG(742,"L") do vdderr("PTSP", vRM) quit
	}

	if vobj(ln,71).exists() do {

		set X = ln.eppendat if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EPPENDAT", vRM) quit
		set X = ln.eppenmet if 'X.isNull(),'Db.isDefined("UTBLLNPPN","X") set vRM = $$^MSG(1485,X) do vdderr("EPPENMET", vRM) quit
		set X = ln.opchg if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.OPCHG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.payacm if 'X.isNull(),'Db.isDefined("STBLAACM","X") set vRM = $$^MSG(1485,X) do vdderr("PAYACM", vRM) quit
		set X = ln.paylkamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAYLKAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.paylkfrm if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PAYLKFRM", vRM) quit
		set X = ln.paylkto if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PAYLKTO", vRM) quit
		if '("01"[ln.PLDF) set vRM=$$^MSG(742,"L") do vdderr("PLDF", vRM) quit
		set X = ln.ppo if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("PPO", vRM) quit
	}

	if vobj(ln,73).exists() do {

		set X = ln.bilinflcalin if 'X.isNull(),'Db.isDefined("UTBLBILINFLT","X") set vRM = $$^MSG(1485,X) do vdderr("BILINFLCALIN", vRM) quit
	}

	if vobj(ln,75).exists() do {

		set X = ln.feegrpo if 'X.isNull(),'Db.isDefined("UTBLLNFEEGRP","X") set vRM = $$^MSG(1485,X) do vdderr("FEEGRPO", vRM) quit
		set X = ln.lnfeegl if 'X.isNull(),'Db.isDefined("GLAD","X") set vRM = $$^MSG(1485,X) do vdderr("LNFEEGL", vRM) quit
		set X = ln.lnfeeta if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("LNFEETA", vRM) quit
	}

	if vobj(ln,80).exists() do {

		if '("01"[ln.ADJCRLMT) set vRM=$$^MSG(742,"L") do vdderr("ADJCRLMT", vRM) quit
		if ln.colcd.length()>6 set vRM = $$^MSG(1076,6) do vdderr("COLCD", vRM) quit
		set X = ln.coll if 'X.isNull(),X'?1.9N,X'?1"-"1.8N set vRM=$$^MSG(742,"N") do vdderr("COLL", vRM) quit
		set X = ln.fclf if 'X.isNull(),'Db.isDefined("STBLFCLF","X") set vRM = $$^MSG(1485,X) do vdderr("FCLF", vRM) quit
		set X = ln.fclp if 'X.isNull(),'Db.isDefined("STBLFCLP","X") set vRM = $$^MSG(1485,X) do vdderr("FCLP", vRM) quit
		set X = ln.fcpt if 'X.isNull(),'Db.isDefined("STBLFCPT","X") set vRM = $$^MSG(1485,X) do vdderr("FCPT", vRM) quit
		set X = ln.minrate if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MINRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,85).exists() do {

		if '("01"[ln.AFLG) set vRM=$$^MSG(742,"L") do vdderr("AFLG", vRM) quit
		set X = ln.anfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]ANFRE",0) if 'vRM.get().isNull() do vdderr("ANFRE", vRM) quit
		set X = ln.apcld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("APCLD", vRM) quit
		if '("01"[ln.CONCAL) set vRM=$$^MSG(742,"L") do vdderr("CONCAL", vRM) quit
		set X = ln.ocadt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("OCADT", vRM) quit
		if '("01"[ln.OCAF) set vRM=$$^MSG(742,"L") do vdderr("OCAF", vRM) quit
	}

	if vobj(ln,98).exists() do {

		if ln.corre.length()>12 set vRM = $$^MSG(1076,12) do vdderr("CORRE", vRM) quit
		if ln.correacn.length()>35 set vRM = $$^MSG(1076,35) do vdderr("CORREACN", vRM) quit
	}

	if vobj(ln,99).exists() do {

		set X = ln.acn if 'X.isNull(),'Db.isDefined("CIF","X") set vRM = $$^MSG(1485,X) do vdderr("ACN", vRM) quit
		if ln.acnrelc.length()>2 set vRM = $$^MSG(1076,2) do vdderr("ACNRELC", vRM) quit
		if ln.aplid.length()>25 set vRM = $$^MSG(1076,25) do vdderr("APLID", vRM) quit
	}

	if vobj(ln,101).exists() do {

		set X = ln.bldt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("BLDT", vRM) quit
		if ln.bloff.length()>3 set vRM = $$^MSG(1076,3) do vdderr("BLOFF", vRM) quit
		if '("01"[ln.BMET) set vRM=$$^MSG(742,"L") do vdderr("BMET", vRM) quit
		set X = ln.bndt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("BNDT", vRM) quit
		if '("01"[ln.BPOCL) set vRM=$$^MSG(742,"L") do vdderr("BPOCL", vRM) quit
		set X = ln.bseq if 'X.isNull() set vRM = $$VAL^DBSVER("N",13,0,,,,,8) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BSEQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cdepamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CDEPAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dpdo if 'X.isNull(),'Db.isDefined("STBLDPPO","X") set vRM = $$^MSG(1485,X) do vdderr("DPDO", vRM) quit
		set X = ln.dppo if 'X.isNull(),'Db.isDefined("STBLDPPO","X") set vRM = $$^MSG(1485,X) do vdderr("DPPO", vRM) quit
		if '("01"[ln.DXSI) set vRM=$$^MSG(742,"L") do vdderr("DXSI", vRM) quit
		set X = ln.fia if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FIA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.fpa if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FPA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lairdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LAIRDT", vRM) quit
		set X = ln.lbdd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LBDD", vRM) quit
		set X = ln.mfcb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MFCB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mpo if 'X.isNull(),'Db.isDefined("STBLLMPO","X") set vRM = $$^MSG(1485,X) do vdderr("MPO", vRM) quit
		set X = ln.mppf if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MPPF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pbpor if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PBPOR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.PEBA) set vRM=$$^MSG(742,"L") do vdderr("PEBA", vRM) quit
		set X = ln.ppb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PPB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ptbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PTBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.PTF) set vRM=$$^MSG(742,"L") do vdderr("PTF", vRM) quit
		set X = ln.rpp if 'X.isNull(),'Db.isDefined("UTBLRPP","X") set vRM = $$^MSG(1485,X) do vdderr("RPP", vRM) quit
		set X = ln.subamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SUBAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.subld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SUBLD", vRM) quit
		set X = ln.subnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SUBND", vRM) quit
		set X = ln.subpln if 'X.isNull(),'Db.isDefined("UTBLLNSUB","X") set vRM = $$^MSG(1485,X) do vdderr("SUBPLN", vRM) quit
		set X = ln.subrat if 'X.isNull() set vRM = $$VAL^DBSVER("N",9,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SUBRAT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,102).exists() do {

		set X = ln.apld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("APLD", vRM) quit
		set X = ln.apn if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("APN", vRM) quit
		set X = ln.aptamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.APTAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.cnvstat.length()>1 set vRM = $$^MSG(1076,1) do vdderr("CNVSTAT", vRM) quit
		if '("01"[ln.DIRDEF) set vRM=$$^MSG(742,"L") do vdderr("DIRDEF", vRM) quit
		set X = ln.idpf if 'X.isNull(),'Db.isDefined("STBLIDPF","X") set vRM = $$^MSG(1485,X) do vdderr("IDPF", vRM) quit
		if ln.igrc.length()>8 set vRM = $$^MSG(1076,8) do vdderr("IGRC", vRM) quit
		if ln.purcd.length()>6 set vRM = $$^MSG(1076,6) do vdderr("PURCD", vRM) quit
		set X = ln.relcid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("RELCID", vRM) quit
		set X = ln.slbl if 'X.isNull(),'Db.isDefined("STBLSLBL","X") set vRM = $$^MSG(1485,X) do vdderr("SLBL", vRM) quit
		set X = ln.sldfd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SLDFD", vRM) quit
		set X = ln.sldnum if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("SLDNUM", vRM) quit
		set X = ln.sldrsn if 'X.isNull(),'Db.isDefined("UTBLSLDRSN","X") set vRM = $$^MSG(1485,X) do vdderr("SLDRSN", vRM) quit
		set X = ln.sldtd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SLDTD", vRM) quit
		if ln.sldtrm.length()>8 set vRM = $$^MSG(1076,8) do vdderr("SLDTRM", vRM) quit
		if ln.subt.length()>5 set vRM = $$^MSG(1076,5) do vdderr("SUBT", vRM) quit
	}

	if vobj(ln,107).exists() do {

		set X = ln.colcdte if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("COLCDTE", vRM) quit
		set X = ln.pcollst if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("PCOLLST", vRM) quit
		set X = ln.promamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PROMAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.prombrd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PROMBRD", vRM) quit
		set X = ln.prommd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PROMMD", vRM) quit
		set X = ln.promsd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PROMSD", vRM) quit
	}

	if vobj(ln,111).exists() do {

		set X = ln.abdm if 'X.isNull(),'Db.isDefined("UTBLABDM","X") set vRM = $$^MSG(1485,X) do vdderr("ABDM", vRM) quit
		set X = ln.acfx1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACFX1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acfx2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACFX2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acfx3 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACFX3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acfx4 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACFX4"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acfx5 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACFX5"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acpc1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",6,0,,,0,100,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACPC1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acpc2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",6,0,,,0,100,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACPC2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acpc3 if 'X.isNull() set vRM = $$VAL^DBSVER("$",6,0,,,0,100,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACPC3"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acpc4 if 'X.isNull() set vRM = $$VAL^DBSVER("$",6,0,,,0,100,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACPC4"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acpc5 if 'X.isNull() set vRM = $$VAL^DBSVER("$",6,0,,,0,100,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACPC5"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.ASSUMF) set vRM=$$^MSG(742,"L") do vdderr("ASSUMF", vRM) quit
		set X = ln.calacls if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CALACLS", vRM) quit
		if ln.case.length()>13 set vRM = $$^MSG(1076,13) do vdderr("CASE", vRM) quit
		if ln.cbc.length()>2 set vRM = $$^MSG(1076,2) do vdderr("CBC", vRM) quit
		set X = ln.cbdoo if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CBDOO", vRM) quit
		set X = ln.cbst if 'X.isNull(),'Db.isDefined("UTBLCBST","X") set vRM = $$^MSG(1485,X) do vdderr("CBST", vRM) quit
		set X = ln.crepscc if 'X.isNull(),'Db.isDefined("UTBLCREPSCC","X") set vRM = $$^MSG(1485,X) do vdderr("CREPSCC", vRM) quit
		set X = ln.dlr if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DLR", vRM) quit
		set X = ln.ecoa if 'X.isNull(),'Db.isDefined("UTBLECOA","X") set vRM = $$^MSG(1485,X) do vdderr("ECOA", vRM) quit
		set X = ln.fppa if 'X.isNull(),X'?1.17N,X'?1"-"1.16N set vRM=$$^MSG(742,"N") do vdderr("FPPA", vRM) quit
		set X = ln.fppi if 'X.isNull(),'Db.isDefined("UTBLFPI","X") set vRM = $$^MSG(1485,X) do vdderr("FPPI", vRM) quit
		set X = ln.modcd if 'X.isNull(),'Db.isDefined("UTBLLNMC","X") set vRM = $$^MSG(1485,X) do vdderr("MODCD", vRM) quit
		set X = ln.moddt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("MODDT", vRM) quit
		set X = ln.plf if 'X.isNull(),'Db.isDefined("STBLLNTDR","X") set vRM = $$^MSG(1485,X) do vdderr("PLF", vRM) quit
		set X = ln.pntspd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PNTSPD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pntspds if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PNTSPDS"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.provbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PROVBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.provcat if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PROVCAT", vRM) quit
		set X = ln.provexpd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PROVEXPD", vRM) quit
		set X = ln.provoamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PROVOAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.provopct if 'X.isNull() set vRM = $$VAL^DBSVER("N",9,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PROVOPCT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.rac if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("RAC", vRM) quit
		set X = ln.racna if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("RACNA", vRM) quit
		set X = ln.racovr if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("RACOVR", vRM) quit
		if '("01"[ln.RECCD) set vRM=$$^MSG(742,"L") do vdderr("RECCD", vRM) quit
	}

	if vobj(ln,112).exists() do {

		set X = ln.coloff if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("COLOFF", vRM) quit
		if ln.crsc.length()>3 set vRM = $$^MSG(1076,3) do vdderr("CRSC", vRM) quit
		set X = ln.dlfp if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DLFP", vRM) quit
		set X = ln.dp1 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP1", vRM) quit
		set X = ln.dp2 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP2", vRM) quit
		set X = ln.dp3 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP3", vRM) quit
		set X = ln.dp4 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP4", vRM) quit
		set X = ln.dp5 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP5", vRM) quit
		set X = ln.dp6 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP6", vRM) quit
		set X = ln.dp7 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DP7", vRM) quit
		set X = ln.fcld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("FCLD", vRM) quit
		set X = ln.fpp01 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP01", vRM) quit
		set X = ln.fpp02 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP02", vRM) quit
		set X = ln.fpp03 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP03", vRM) quit
		set X = ln.fpp04 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP04", vRM) quit
		set X = ln.fpp05 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP05", vRM) quit
		set X = ln.fpp06 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP06", vRM) quit
		set X = ln.fpp07 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP07", vRM) quit
		set X = ln.fpp08 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP08", vRM) quit
		set X = ln.fpp09 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP09", vRM) quit
		set X = ln.fpp10 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP10", vRM) quit
		set X = ln.fpp11 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP11", vRM) quit
		set X = ln.fpp12 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FPP12", vRM) quit
		set X = ln.not1dt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("NOT1DT", vRM) quit
		set X = ln.not2dt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("NOT2DT", vRM) quit
		set X = ln.not3dt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("NOT3DT", vRM) quit
		set X = ln.not4dt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("NOT4DT", vRM) quit
		set X = ln.not5dt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("NOT5DT", vRM) quit
		set X = ln.old if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("OLD", vRM) quit
	}

	if vobj(ln,113).exists() do {

		set X = ln.aupbr if 'X.isNull() set vRM = $$VAL^DBSVER("$",6,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.AUPBR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dy1 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY1", vRM) quit
		set X = ln.dy2 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY2", vRM) quit
		set X = ln.dy3 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY3", vRM) quit
		set X = ln.dy4 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY4", vRM) quit
		set X = ln.dy5 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY5", vRM) quit
		set X = ln.dy6 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY6", vRM) quit
		set X = ln.dy7 if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DY7", vRM) quit
	}

	if vobj(ln,114).exists() do {

		set X = ln.cusha if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CUSHA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cushf if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,9) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CUSHF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cusho if 'X.isNull(),'Db.isDefined("STBLCUSHO","X") set vRM = $$^MSG(1485,X) do vdderr("CUSHO", vRM) quit
		set X = ln.ddmg if 'X.isNull(),'Db.isDefined("STBLTRDD","X") set vRM = $$^MSG(1485,X) do vdderr("DDMG", vRM) quit
		set X = ln.ddml if 'X.isNull(),'Db.isDefined("STBLTRDD","X") set vRM = $$^MSG(1485,X) do vdderr("DDML", vRM) quit
		set X = ln.dfda if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DFDA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ieasgf if 'X.isNull(),'Db.isDefined("STBLSTMT","X") set vRM = $$^MSG(1485,X) do vdderr("IEASGF", vRM) quit
		set X = ln.oda if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ODA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.odmg if 'X.isNull(),'Db.isDefined("STBLODM","X") set vRM = $$^MSG(1485,X) do vdderr("ODMG", vRM) quit
		set X = ln.odml if 'X.isNull(),'Db.isDefined("STBLODM","X") set vRM = $$^MSG(1485,X) do vdderr("ODML", vRM) quit
		set X = ln.sda if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SDA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.sdmg if 'X.isNull(),'Db.isDefined("STBLTRDD","X") set vRM = $$^MSG(1485,X) do vdderr("SDMG", vRM) quit
		set X = ln.sdml if 'X.isNull(),'Db.isDefined("STBLTRDD","X") set vRM = $$^MSG(1485,X) do vdderr("SDML", vRM) quit
		set X = ln.sdo if 'X.isNull(),'Db.isDefined("STBLSDO","X") set vRM = $$^MSG(1485,X) do vdderr("SDO", vRM) quit
	}

	if vobj(ln,115).exists() do {

		set X = ln.dl1 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL1", vRM) quit
		set X = ln.dl2 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL2", vRM) quit
		set X = ln.dl3 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL3", vRM) quit
		set X = ln.dl4 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL4", vRM) quit
		set X = ln.dl5 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL5", vRM) quit
		set X = ln.dl6 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL6", vRM) quit
		set X = ln.dl7 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DL7", vRM) quit
	}

	if vobj(ln,300).exists() do {

		set X = ln.pbkbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PBKBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pbkld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PBKLD", vRM) quit
		set X = ln.pbklin if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("PBKLIN", vRM) quit
		set X = ln.pbkseq if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("PBKSEQ", vRM) quit
		set X = ln.pbksn if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("PBKSN", vRM) quit
	}

	if vobj(ln,426).exists() do {

		set X = ln.retfcpy if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RETFCPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.retfcytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RETFCYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.retfwpy if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RETFWPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.retfwytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RETFWYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.retmxfee if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RETMXFEE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,429).exists() do {

		set X = ln.lmtatm if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LMTATM"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lmtcjd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LMTCJD", vRM) quit
		set X = ln.lmtpos if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LMTPOS"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,430).exists() do {

		set X = ln.eurbatch if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("EURBATCH", vRM) quit
		set X = ln.eurcnvd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EURCNVD", vRM) quit
		set X = ln.eurcvinbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.EURCVINBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.eurefd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EUREFD", vRM) quit
		set X = ln.eureqdat if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EUREQDAT", vRM) quit
		set X = ln.eurevdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EUREVDT", vRM) quit
		set X = ln.eurstat if 'X.isNull(),'Db.isDefined("STBLEURSTAT","X") set vRM = $$^MSG(1485,X) do vdderr("EURSTAT", vRM) quit
		set X = ln.eurudrq if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("EURUDRQ", vRM) quit
		if ln.orgcrcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("ORGCRCD", vRM) quit
		if ln.orgindex.length()>20 set vRM = $$^MSG(1076,20) do vdderr("ORGINDEX", vRM) quit
		set X = ln.orgsch if 'X.isNull(),'Db.isDefined("UTBLRATE","X") set vRM = $$^MSG(1485,X) do vdderr("ORGSCH", vRM) quit
	}

	if vobj(ln,431).exists() do {

		set X = ln.ballamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BALLAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cbt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CBT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.costyp if 'X.isNull(),'Db.isDefined("UTBLECOSTOP","X") set vRM = $$^MSG(1485,X) do vdderr("COSTYP", vRM) quit
		set X = ln.dbt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DBT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mbldelq if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MBLDELQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.nbtck if 'X.isNull(),'Db.isDefined("UTBLCHKS","X") set vRM = $$^MSG(1485,X) do vdderr("NBTCK", vRM) quit
		set X = ln.nbtr if 'X.isNull(),'Db.isDefined("STBLNEGBTR","X") set vRM = $$^MSG(1485,X) do vdderr("NBTR", vRM) quit
		set X = ln.ntropt if 'X.isNull(),'Db.isDefined("STBLNEGBOPT","X") set vRM = $$^MSG(1485,X) do vdderr("NTROPT", vRM) quit
		if '("01"[ln.PAYEFT) set vRM=$$^MSG(742,"L") do vdderr("PAYEFT", vRM) quit
		set X = ln.rfp if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("RFP", vRM) quit
		set X = ln.sfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]SFRE",0) if 'vRM.get().isNull() do vdderr("SFRE", vRM) quit
		set X = ln.trcid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("TRCID", vRM) quit
		set X = ln.troffd if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("TROFFD", vRM) quit
	}

	if vobj(ln,432).exists() do {

		set X = ln.cnvtyp if 'X.isNull(),'Db.isDefined("STBLCNVTYP","X") set vRM = $$^MSG(1485,X) do vdderr("CNVTYP", vRM) quit
		if '("01"[ln.COLLQUE) set vRM=$$^MSG(742,"L") do vdderr("COLLQUE", vRM) quit
		set X = ln.collst if 'X.isNull(),'Db.isDefined("UTBLCOLLST","X") set vRM = $$^MSG(1485,X) do vdderr("COLLST", vRM) quit
		set X = ln.comppy if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COMPPY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.compytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COMPYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ipty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.itytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ITYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.penpty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PENPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pentytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PENTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.restyp if 'X.isNull(),'Db.isDefined("STBLRESTYP","X") set vRM = $$^MSG(1485,X) do vdderr("RESTYP", vRM) quit
		set X = ln.wrkdte if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("WRKDTE", vRM) quit
	}

	if vobj(ln,433).exists() do {

		set X = ln.alprtyd if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("ALPRTYD", vRM) quit
		if '("01"[ln.AVCRLMT) set vRM=$$^MSG(742,"L") do vdderr("AVCRLMT", vRM) quit
		if '("01"[ln.CINTBNP) set vRM=$$^MSG(742,"L") do vdderr("CINTBNP", vRM) quit
		set X = ln.dpa if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("DPA", vRM) quit
		if '("01"[ln.ICAP) set vRM=$$^MSG(742,"L") do vdderr("ICAP", vRM) quit
		set X = ln.iropt if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("IROPT", vRM) quit
		if ln.lpspdag.length()>8 set vRM = $$^MSG(1076,8) do vdderr("LPSPDAG", vRM) quit
		set X = ln.paytol if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAYTOL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.paytolp if 'X.isNull() set vRM = $$VAL^DBSVER("N",6,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PAYTOLP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pmtrdfac if 'X.isNull(),X'?1.5N,X'?1"-"1.4N set vRM=$$^MSG(742,"N") do vdderr("PMTRDFAC", vRM) quit
		set X = ln.reldepacct if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("RELDEPACCT", vRM) quit
		set X = ln.toldue if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TOLDUE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.wdamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.WDAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.wdfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]WDFRE",0) if 'vRM.get().isNull() do vdderr("WDFRE", vRM) quit
		set X = ln.wdld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("WDLD", vRM) quit
		set X = ln.wdlmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.WDLMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.WDLMTP) set vRM=$$^MSG(742,"L") do vdderr("WDLMTP", vRM) quit
		set X = ln.wdnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("WDND", vRM) quit
	}

	if vobj(ln,435).exists() do {

		if '("01"[ln.ADDLCHG) set vRM=$$^MSG(742,"L") do vdderr("ADDLCHG", vRM) quit
		set X = ln.aldchk if 'X.isNull(),'Db.isDefined("UTBLCHKS","X") set vRM = $$^MSG(1485,X) do vdderr("ALDCHK", vRM) quit
		set X = ln.aldext if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("ALDEXT", vRM) quit
		set X = ln.aldm if 'X.isNull(),'Db.isDefined("STBLALDM","X") set vRM = $$^MSG(1485,X) do vdderr("ALDM", vRM) quit
		if ln.aldp.length()>20 set vRM = $$^MSG(1076,20) do vdderr("ALDP", vRM) quit
		set X = ln.amtworpi if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.AMTWORPI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.appnum if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("APPNUM", vRM) quit
		set X = ln.blkprinnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("BLKPRINND", vRM) quit
		set X = ln.blkprinpan if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.BLKPRINPAN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.disbchk if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("DISBCHK", vRM) quit
		if '("01"[ln.GENPRN) set vRM=$$^MSG(742,"L") do vdderr("GENPRN", vRM) quit
		set X = ln.idgp if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("IDGP", vRM) quit
		set X = ln.inspr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INSPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.perno if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("PERNO", vRM) quit
		set X = ln.refpr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.REFPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.rpiprem if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RPIPREM"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.rpirate if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RPIRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.rpireb if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.RPIREB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,438).exists() do {

		if '("01"[ln.MT900) set vRM=$$^MSG(742,"L") do vdderr("MT900", vRM) quit
		set X = ln.mt900a if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("MT900A", vRM) quit
		set X = ln.mt900thr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MT900THR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.MT910) set vRM=$$^MSG(742,"L") do vdderr("MT910", vRM) quit
		set X = ln.mt910a if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("MT910A", vRM) quit
		set X = ln.mt910thr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MT910THR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,440).exists() do {

		set X = ln.acoint if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACOINT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acolchg if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACOLCHG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acomfee if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACOMFEE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.acoprin if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ACOPRIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.COF) set vRM=$$^MSG(742,"L") do vdderr("COF", vRM) quit
		if ln.cogs.length()>4 set vRM = $$^MSG(1076,4) do vdderr("COGS", vRM) quit
		set X = ln.com if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("COM", vRM) quit
		set X = ln.cot if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("COT", vRM) quit
		set X = ln.dtco if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DTCO", vRM) quit
		set X = ln.intrec if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.INTREC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.lchgrec if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.LCHGREC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mfeerec if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MFEEREC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.prinrec if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PRINREC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,443).exists() do {

		set X = ln.dafpty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DAFPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.daftytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DAFTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.efrpty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.EFRPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.efrtytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.EFRTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.feepty if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FEEPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.feetytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.FEETYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ndafpty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NDAFPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ndaftytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NDAFTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pntspdsty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PNTSPDSTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pntstytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PNTSTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.refintpty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.REFINTPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.refinttytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.REFINTTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,445).exists() do {

		if '("01"[ln.REFFLG) set vRM=$$^MSG(742,"L") do vdderr("REFFLG", vRM) quit
		set X = ln.tcrl if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TCRL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tcrp if 'X.isNull() set vRM = $$VAL^DBSVER("N",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TCRP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tcsa if 'X.isNull() set vRM = $$VAL^DBSVER("N",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TCSA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.tcsl if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TCSL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.wspouscif if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("WSPOUSCIF", vRM) quit
		set X = ln.wspousdob if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("WSPOUSDOB", vRM) quit
		if '("01"[ln.WSPOUSFL) set vRM=$$^MSG(742,"L") do vdderr("WSPOUSFL", vRM) quit
		if ln.wspousnm.length()>40 set vRM = $$^MSG(1076,40) do vdderr("WSPOUSNM", vRM) quit
	}

	if vobj(ln,447).exists() do {

		set X = ln.copty if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COPTY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cotytd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COTYTD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cvcid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("CVCID", vRM) quit
		set X = ln.efdsub if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EFDSUB", vRM) quit
		if '("01"[ln.PAOI) set vRM=$$^MSG(742,"L") do vdderr("PAOI", vRM) quit
		set X = ln.pcidstat if 'X.isNull(),'Db.isDefined("STBLPCIDSTAT","X") set vRM = $$^MSG(1485,X) do vdderr("PCIDSTAT", vRM) quit
	}

	if vobj(ln,448).exists() do {

		set X = ln.npiaab if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.NPIAAB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.OSGNCRDC) set vRM=$$^MSG(742,"L") do vdderr("OSGNCRDC", vRM) quit
		set X = ln.psgncrdr if 'X.isNull(),'Db.isDefined("STBLPSGNCRDR","X") set vRM = $$^MSG(1485,X) do vdderr("PSGNCRDR", vRM) quit
		set X = ln.sgncrd if 'X.isNull(),'Db.isDefined("STBLSGNCRD","X") set vRM = $$^MSG(1485,X) do vdderr("SGNCRD", vRM) quit
		set X = ln.sgncrdchgdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SGNCRDCHGDT", vRM) quit
	}

	if vobj(ln,449).exists() do {

		if '("01"[ln.CBF) set vRM=$$^MSG(742,"L") do vdderr("CBF", vRM) quit
		if '("01"[ln.CDF) set vRM=$$^MSG(742,"L") do vdderr("CDF", vRM) quit
		set X = ln.iramto if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.IRAMTO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ircid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("IRCID", vRM) quit
		if '("01"[ln.IRP) set vRM=$$^MSG(742,"L") do vdderr("IRP", vRM) quit
		set X = ln.maxaggr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MAXAGGR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if ln.paytrnst.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PAYTRNST", vRM) quit
		set X = ln.pramt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PRAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pramtcid if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("PRAMTCID", vRM) quit
		set X = ln.prcntap if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PRCNTAP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.prcntcid if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("PRCNTCID", vRM) quit
	}

	if vobj(ln,451).exists() do {

		set X = ln.rcalcm if 'X.isNull(),'Db.isDefined("STBLAOAMO","X") set vRM = $$^MSG(1485,X) do vdderr("RCALCM", vRM) quit
		set X = ln.vatfeedue if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.VATFEEDUE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.vatfeepd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.VATFEEPD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.vatintdue if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.VATINTDUE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.vatintopt if 'X.isNull(),'Db.isDefined("STBLVATINTL","X") set vRM = $$^MSG(1485,X) do vdderr("VATINTOPT", vRM) quit
		set X = ln.vatintpd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.VATINTPD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.vatlchgdue if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.VATLCHGDUE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.vatlchgpd if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.VATLCHGPD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,452).exists() do {

		if ln.rsintspr.length()>9 set vRM = $$^MSG(1076,9) do vdderr("RSINTSPR", vRM) quit
		if ln.rsrndmtd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("RSRNDMTD", vRM) quit
	}

	if vobj(ln,453).exists() do {

		if '("01"[ln.AFFLN) set vRM=$$^MSG(742,"L") do vdderr("AFFLN", vRM) quit
		set X = ln.ansale if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ANSALE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.BCAPINT) set vRM=$$^MSG(742,"L") do vdderr("BCAPINT", vRM) quit
		if ln.cen.length()>7 set vRM = $$^MSG(1076,7) do vdderr("CEN", vRM) quit
		set X = ln.cracntcd if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CRACNTCD", vRM) quit
		set X = ln.crastcd if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("CRASTCD", vRM) quit
		set X = ln.msacd if 'X.isNull(),'Db.isDefined("UTBLMSA","X") set vRM = $$^MSG(1485,X) do vdderr("MSACD", vRM) quit
		set X = ln.rescls if 'X.isNull(),'Db.isDefined("STBLRESCLS","X") set vRM = $$^MSG(1485,X) do vdderr("RESCLS", vRM) quit
	}

	if vobj(ln,454).exists() do {

		set X = ln.precard if 'X.isNull(),X'?1.20N,X'?1"-"1.19N set vRM=$$^MSG(742,"N") do vdderr("PRECARD", vRM) quit
		if ln.prepin.length()>20 set vRM = $$^MSG(1076,20) do vdderr("PREPIN", vRM) quit
	}

	if vobj(ln,455).exists() do {

		set X = ln.co if 'X.isNull(),'Db.isDefined("UTBLCO","X") set vRM = $$^MSG(1485,X) do vdderr("CO", vRM) quit
		set X = ln.delqrsn if 'X.isNull(),'Db.isDefined("UTBLRFD","X") set vRM = $$^MSG(1485,X) do vdderr("DELQRSN", vRM) quit
	}

	if vobj(ln,456).exists() do {

		set X = ln.colexthrsh if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COLEXTHRSH"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.colextrdys if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("COLEXTRDYS", vRM) quit
		set X = ln.regeamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.REGEAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.stmtsrt if 'X.isNull(),'Db.isDefined("STBLSTMTSRT","X") set vRM = $$^MSG(1485,X) do vdderr("STMTSRT", vRM) quit
	}

	if vobj(ln,457).exists() do {

		set X = ln.anmth if 'X.isNull(),'Db.isDefined("UTBLANMTH","X") set vRM = $$^MSG(1485,X) do vdderr("ANMTH", vRM) quit
		if ln.currisk.length()>3 set vRM = $$^MSG(1076,3) do vdderr("CURRISK", vRM) quit
		set X = ln.curscor1 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CURSCOR1", vRM) quit
		set X = ln.curscor2 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("CURSCOR2", vRM) quit
		if ln.pririsk.length()>3 set vRM = $$^MSG(1076,3) do vdderr("PRIRISK", vRM) quit
		set X = ln.priscor1 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PRISCOR1", vRM) quit
		set X = ln.priscor2 if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PRISCOR2", vRM) quit
	}

	if vobj(ln,458).exists() do {

		set X = ln.clr if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("CLR", vRM) quit
		set X = ln.slc if 'X.isNull(),'Db.isDefined("STBLSBSLC","X") set vRM = $$^MSG(1485,X) do vdderr("SLC", vRM) quit
	}

	if vobj(ln,459).exists() do {

		set X = ln.cipy98e if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CIPY98E"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.sdate98e if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SDATE98E", vRM) quit
	}

	if vobj(ln,461).exists() do {

		if '("01"[ln.GENPRJREP) set vRM=$$^MSG(742,"L") do vdderr("GENPRJREP", vRM) quit
		if ln.maxptrm.length()>8 set vRM = $$^MSG(1076,8) do vdderr("MAXPTRM", vRM) quit
		if ln.minptrm.length()>8 set vRM = $$^MSG(1076,8) do vdderr("MINPTRM", vRM) quit
		set X = ln.numdtp if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("NUMDTP", vRM) quit
		set X = ln.pmro if 'X.isNull(),'Db.isDefined("STBLPMRO","X") set vRM = $$^MSG(1485,X) do vdderr("PMRO", vRM) quit
	}

	if vobj(ln,463).exists() do {

		set X = ln.maxo if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MAXO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.mino if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.MINO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.pcto if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PCTO"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,465).exists() do {

		if '("01"[ln.ADJCOL) set vRM=$$^MSG(742,"L") do vdderr("ADJCOL", vRM) quit
		set X = ln.collim if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.COLLIM"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.COLLIMPR) set vRM=$$^MSG(742,"L") do vdderr("COLLIMPR", vRM) quit
		if '("01"[ln.FSOVRDUE) set vRM=$$^MSG(742,"L") do vdderr("FSOVRDUE", vRM) quit
		if '("01"[ln.OOC) set vRM=$$^MSG(742,"L") do vdderr("OOC", vRM) quit
		set X = ln.pbfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LN]PBFRE",0) if 'vRM.get().isNull() do vdderr("PBFRE", vRM) quit
		set X = ln.pblstdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PBLSTDT", vRM) quit
		set X = ln.pbnxtdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PBNXTDT", vRM) quit
		if '("01"[ln.RACLC) set vRM=$$^MSG(742,"L") do vdderr("RACLC", vRM) quit
		if '("01"[ln.RACLF) set vRM=$$^MSG(742,"L") do vdderr("RACLF", vRM) quit
		if '("01"[ln.SECMTG) set vRM=$$^MSG(742,"L") do vdderr("SECMTG", vRM) quit
	}

	if vobj(ln,467).exists() do {

		set X = ln.psrlnbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.PSRLNBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.ssrlnbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.SSRLNBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,469).exists() do {

		set X = ln.altoff if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("ALTOFF", vRM) quit
		set X = ln.defltdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DEFLTDT", vRM) quit
		if '("01"[ln.DMNDLN) set vRM=$$^MSG(742,"L") do vdderr("DMNDLN", vRM) quit
		set X = ln.dtpmstch if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DTPMSTCH", vRM) quit
		set X = ln.jcode if 'X.isNull(),'Db.isDefined("UTBLJUD","X") set vRM = $$^MSG(1485,X) do vdderr("JCODE", vRM) quit
		set X = ln.jdgmfldt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("JDGMFLDT", vRM) quit
		set X = ln.lienfldt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LIENFLDT", vRM) quit
		set X = ln.naics if 'X.isNull(),'Db.isDefined("UTBLNAICS","X") set vRM = $$^MSG(1485,X) do vdderr("NAICS", vRM) quit
		set X = ln.naplmtdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("NAPLMTDT", vRM) quit
		set X = ln.nucollyr if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("NUCOLLYR", vRM) quit
		set X = ln.nucolytd if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("NUCOLYTD", vRM) quit
		if ln.trstrcno.length()>20 set vRM = $$^MSG(1076,20) do vdderr("TRSTRCNO", vRM) quit
	}

	if vobj(ln,471).exists() do {

		set X = ln.cpacr if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CPACR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cpbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CPBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dispamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.DISPAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.oneagoacr if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ONEAGOACR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.oneagobal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.ONEAGOBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[ln.SEGMENTS) set vRM=$$^MSG(742,"L") do vdderr("SEGMENTS", vRM) quit
		set X = ln.twoagoacr if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TWOAGOACR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.twoagobal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.TWOAGOBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(ln,500).exists() do {

		if ln.acycode.length()>15 set vRM = $$^MSG(1076,15) do vdderr("ACYCODE", vRM) quit
		if ln.agcode.length()>15 set vRM = $$^MSG(1076,15) do vdderr("AGCODE", vRM) quit
		if ln.agtypec.length()>15 set vRM = $$^MSG(1076,15) do vdderr("AGTYPEC", vRM) quit
		if ln.busadv.length()>15 set vRM = $$^MSG(1076,15) do vdderr("BUSADV", vRM) quit
		set X = ln.cptag if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CPTAG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cptbadv if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CPTBADV"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cptiae if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CPTIAE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.cptrefr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LN.CPTREFR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = ln.dcptag if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DCPTAG", vRM) quit
		set X = ln.dcptbadv if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DCPTBADV", vRM) quit
		set X = ln.dcptiae if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DCPTIAE", vRM) quit
		set X = ln.dcptrefr if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DCPTREFR", vRM) quit
		if ln.ilcode.length()>15 set vRM = $$^MSG(1076,15) do vdderr("ILCODE", vRM) quit
		if ln.refrep.length()>15 set vRM = $$^MSG(1076,15) do vdderr("REFREP", vRM) quit
		if ln.sofcode.length()>15 set vRM = $$^MSG(1076,15) do vdderr("SOFCODE", vRM) quit
		if ln.subscode.length()>15 set vRM = $$^MSG(1076,15) do vdderr("SUBSCODE", vRM) quit
	}
	set X = ln.cid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("CID", vRM) quit
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("LN","MSG",979,"LN."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VJOURNAL(RecordLN ln)	//LN Journal file entries

	type Public Date %EffectiveDate
	type Public String %TSRC,vpar,vx()
	type String TSRC,vdi,vdx()

	if %TSRC.get().isNull() set TSRC="O"
	else  set TSRC=%TSRC

	if %ProcessMode=0 do {
		if TSRC="B" do {
			if EFD.get() do {
				do vj6(.ln)	// Mode=I Tran=B EFD=E Seq=1 JRNID=DTJCL_I
				}
			else  do {
				do vj6(.ln)	// Mode=I Tran=B EFD=N Seq=1 JRNID=DTJCL_I
				do vj7(.ln)	// Mode=I Tran=B EFD=N Seq=1 JRNID=DTJNAACN_I
				do vj8(.ln)	// Mode=I Tran=B EFD=N Seq=1 JRNID=DTJNA_I
				do vj12(.ln)	// Mode=I Tran=B EFD=N Seq=1 JRNID=HIST_I
				do vj13(.ln)	// Mode=I Tran=B EFD=N Seq=1 JRNID=HIST_I_APPNUM
				}
			}
		else  if TSRC="F" do {
			do vj6(.ln)	// Mode=I Tran=F EFD=N,E Seq=1 JRNID=DTJCL_I
			}
		else  if TSRC="O" do {
			if EFD.get() do {
				do vj6(.ln)	// Mode=I Tran=O EFD=E Seq=1 JRNID=DTJCL_I
				}
			else  do {
				do vj6(.ln)	// Mode=I Tran=O EFD=N Seq=1 JRNID=DTJCL_I
				do vj7(.ln)	// Mode=I Tran=O EFD=N Seq=1 JRNID=DTJNAACN_I
				do vj8(.ln)	// Mode=I Tran=O EFD=N Seq=1 JRNID=DTJNA_I
				do vj12(.ln)	// Mode=I Tran=O EFD=N Seq=1 JRNID=HIST_I
				do vj13(.ln)	// Mode=I Tran=O EFD=N Seq=1 JRNID=HIST_I_APPNUM
				}
			}
		}
	else  if %ProcessMode=1 do {
		if TSRC="B" do {
			if EFD.get() do {
				do vj6(.ln)	// Mode=U Tran=B EFD=E Seq=1 JRNID=DTJCL_I
				do vj14(.ln)	// Mode=U Tran=B EFD=E Seq=1 JRNID=HIST_U
				}
			else  do {
				do vj6(.ln)	// Mode=U Tran=B EFD=N Seq=1 JRNID=DTJCL_I
				do vj14(.ln)	// Mode=U Tran=B EFD=N Seq=1 JRNID=HIST_U
				quit:'vx.data()
				if vx("STAT").exists() do vj3(.ln,"STAT")	// Mode=U Tran=B EFD=N Seq=1 JRNID=CMSRECCID
				if vx("STAT").exists() do vj9(.ln,"STAT")	// Mode=U Tran=B EFD=N Seq=1 JRNID=DTJNA_U
				if vx("TYPE").exists() do vj15(.ln,"TYPE")	// Mode=U Tran=B EFD=N Seq=1 JRNID=TYPE_FROM_U
				if vx("TYPE").exists() do vj16(.ln,"TYPE")	// Mode=U Tran=B EFD=N Seq=1 JRNID=TYPE_TO_U
				if vx("CRCD").exists() do vj4(.ln,"CRCD")	// Mode=U Tran=B EFD=N Seq=2 JRNID=CRCD_TO_U
				if vx("CRLMT").exists() do vj5(.ln,"CRLMT")	// Mode=U Tran=B EFD=N Seq=2 JRNID=CRLMT_U
				if vx("GLSC").exists() do vj10(.ln,"GLSC")	// Mode=U Tran=B EFD=N Seq=2 JRNID=GLSC_FROM_U
				if vx("GLSC").exists() do vj11(.ln,"GLSC")	// Mode=U Tran=B EFD=N Seq=2 JRNID=GLSC_TO_U
				if vx("CC").exists() do vj1(.ln,"CC")	// Mode=U Tran=B EFD=N Seq=3 JRNID=CC_FROM_U
				if vx("CC").exists() do vj2(.ln,"CC")	// Mode=U Tran=B EFD=N Seq=3 JRNID=CC_TO_U
				}
			}
		else  if TSRC="F" do {
			do vj6(.ln)	// Mode=U Tran=F EFD=N,E Seq=1 JRNID=DTJCL_I
			}
		else  if TSRC="O" do {
			if EFD.get() do {
				do vj6(.ln)	// Mode=U Tran=O EFD=E Seq=1 JRNID=DTJCL_I
				do vj14(.ln)	// Mode=U Tran=O EFD=E Seq=1 JRNID=HIST_U
				}
			else  do {
				do vj6(.ln)	// Mode=U Tran=O EFD=N Seq=1 JRNID=DTJCL_I
				do vj14(.ln)	// Mode=U Tran=O EFD=N Seq=1 JRNID=HIST_U
				quit:'vx.data()
				if vx("STAT").exists() do vj3(.ln,"STAT")	// Mode=U Tran=O EFD=N Seq=1 JRNID=CMSRECCID
				if vx("STAT").exists() do vj9(.ln,"STAT")	// Mode=U Tran=O EFD=N Seq=1 JRNID=DTJNA_U
				if vx("TYPE").exists() do vj15(.ln,"TYPE")	// Mode=U Tran=O EFD=N Seq=1 JRNID=TYPE_FROM_U
				if vx("TYPE").exists() do vj16(.ln,"TYPE")	// Mode=U Tran=O EFD=N Seq=1 JRNID=TYPE_TO_U
				if vx("CRCD").exists() do vj4(.ln,"CRCD")	// Mode=U Tran=O EFD=N Seq=2 JRNID=CRCD_TO_U
				if vx("CRLMT").exists() do vj5(.ln,"CRLMT")	// Mode=U Tran=O EFD=N Seq=2 JRNID=CRLMT_U
				if vx("GLSC").exists() do vj10(.ln,"GLSC")	// Mode=U Tran=O EFD=N Seq=2 JRNID=GLSC_FROM_U
				if vx("GLSC").exists() do vj11(.ln,"GLSC")	// Mode=U Tran=O EFD=N Seq=2 JRNID=GLSC_TO_U
				if vx("CC").exists() do vj1(.ln,"CC")	// Mode=U Tran=O EFD=N Seq=3 JRNID=CC_FROM_U
				if vx("CC").exists() do vj2(.ln,"CC")	// Mode=U Tran=O EFD=N Seq=3 JRNID=CC_TO_U
				}
			}
		}

	quit


vj1(RecordLN ln,String vdi)	// CC_FROM_U  Table DAYENDXFR  Cost Center Change - From Account Info

	type Public String TJD
	type String v1,vlastkey
	set v1=TJD
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.oldVal
	set dayendxfr.ccc=ln.cc.curVal
	set dayendxfr.cglsc=ln.glsc
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.ctype=ln.type
	set dayendxfr.deftot=$$DFRCSTR^LNFUNCS(ln.cid)
	set dayendxfr.feerem=$$FRCSTR^LNFUNCS(ln.cid)
	set dayendxfr.glsc=ln.glsc
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.ndfbal=$$NDFREC^LNFUNCS(ln.cid)
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=0

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj2(RecordLN ln,String vdi)	// CC_TO_U  Table DAYENDXFR  Cost Center Change - To Account Info

	type Public String TJD
	type String v1,vlastkey
	set v1=TJD
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.curVal
	set dayendxfr.ccc=ln.cc.oldVal
	set dayendxfr.cglsc=ln.glsc
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.ctype=ln.type
	set dayendxfr.deftot=$$DFRCSTR^LNFUNCS(ln.cid)
	set dayendxfr.feerem=$$FRCSTR^LNFUNCS(ln.cid)
	set dayendxfr.glsc=ln.glsc
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.ndfbal=$$NDFREC^LNFUNCS(ln.cid)
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=1

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj3(RecordLN ln,String vdi)	// CMSRECCID  Table CMSRECCID  Add CMSREC entry for mod. LN records

	if +ln.carduf=1
	else  quit

							//// Save this line for Public datatyping, if needed
	type String vlastkey
	set vlastkey=Db.nextVal("CMSRECCID","")
	type RecordCMSRECCID cmsreccid=Db.getRecord("CMSRECCID","SEQ=:vlastkey",1)
	set cmsreccid.cid=ln.cid
	set cmsreccid.cmsflg=ln.cmsflg

	do cmsreccid.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj4(RecordLN ln,String vdi)	// CRCD_TO_U  Table DAYENDXFR  Currency Code - To Account Info

							//// Save this line for Public datatyping, if needed
	type String v1,vlastkey
	set v1=ln.eurefd
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.oldVal
	set dayendxfr.ccc=ln.cc.oldVal
	set dayendxfr.ccrcd=ln.crcd.oldVal
	set dayendxfr.cglsc=ln.glsc.oldVal
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.crcd=ln.crcd.curVal
	set dayendxfr.ctype=ln.type.oldVal
	set dayendxfr.glsc=ln.glsc.oldVal
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type.oldVal
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=1

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj5(RecordLN ln,String vdi)	// CRLMT_U  Table DTJNA  Credit Limit Change - Act as new acct

	type String VQ1

	set VQ1=$$CRLMT^LNFUNCS(%SystemDate,ln.cls,ln.grp,ln.type,ln.cid)

	if VQ1="0"
	else  quit

	type Public String %IDENT,TJD
	type String v1,v2,v3,v4,vlastkey
	set v1=TJD
	set v2=ln.cls
	set v3=ln.grp
	set v4=ln.type
	set vlastkey=ln.cid
	type RecordDTJNA dtjna=Db.getRecord("DTJNA","TJD=:v1,CLS=:v2,GRP=:v3,TYP=:v4,CID=:vlastkey",1)
	set dtjna.ident=%IDENT
	set dtjna.newcrlmt=ln.crlmt.curVal
	set dtjna.oldcrlmt=ln.crlmt.oldVal

	do dtjna.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj6(RecordLN ln)	// DTJCL_I  Table DTJCL  Daily Closed Account Journal

	if +ln.stat=4
	else  quit

	type Public String TJD
	type String v1,v2,v3,v4,vlastkey
	set v1=TJD
	set v2=ln.cls
	set v3=ln.grp
	set v4=ln.type
	set vlastkey=ln.cid
	type RecordDTJCL dtjcl=Db.getRecord("DTJCL","TJD=:v1,CLS=:v2,GRP=:v3,TYP=:v4,CID=:vlastkey",1)

	do dtjcl.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj7(RecordLN ln)	// DTJNAACN_I  Table DTJNAACN  New Account Insert Journal

	type Public String TJD
	type String v1,v2,v3,v4,v5,vlastkey
	set v1=TJD
	set v2=ln.acn
	set v3=ln.cls
	set v4=ln.grp
	set v5=ln.type
	set vlastkey=ln.cid
	type RecordDTJNAACN dtjnaacn=Db.getRecord("DTJNAACN","SJD=:v1,ACN=:v2,CLS=:v3,GRP=:v4,TYPE=:v5,CID=:vlastkey",1)

	do dtjnaacn.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj8(RecordLN ln)	// DTJNA_I  Table DTJNA  Daily New Account Journal

	type Public String %IDENT,TJD
	type String v1,v2,v3,v4,vlastkey
	set v1=TJD
	set v2=ln.cls
	set v3=ln.grp
	set v4=ln.type
	set vlastkey=ln.cid
	type RecordDTJNA dtjna=Db.getRecord("DTJNA","TJD=:v1,CLS=:v2,GRP=:v3,TYP=:v4,CID=:vlastkey",1)
	set dtjna.ident=%IDENT

	do dtjna.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj9(RecordLN ln,String vdi)	// DTJNA_U  Table DTJNA  Daily New Account Journal

	if +ln.stat=0
	else  quit

	type Public String %IDENT,TJD
	type String v1,v2,v3,v4,vlastkey
	set v1=TJD
	set v2=ln.cls
	set v3=ln.grp
	set v4=ln.type
	set vlastkey=ln.cid
	type RecordDTJNA dtjna=Db.getRecord("DTJNA","TJD=:v1,CLS=:v2,GRP=:v3,TYP=:v4,CID=:vlastkey",1)
	set dtjna.ident=%IDENT
	set dtjna.reopn=1

	do dtjna.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj10(RecordLN ln,String vdi)	// GLSC_FROM_U  Table DAYENDXFR  GL Set Code Change - From Account Info

	type Public String TJD
	type String v1,vlastkey
	set v1=TJD
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.oldVal
	set dayendxfr.ccc=ln.cc.oldVal
	set dayendxfr.cglsc=ln.glsc.curVal
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.ctype=ln.type
	set dayendxfr.feerem=$$FRCSTR^LNFUNCS(ln.cid)
	set dayendxfr.glsc=ln.glsc.oldVal
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=0

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj11(RecordLN ln,String vdi)	// GLSC_TO_U  Table DAYENDXFR  GL Set Code Change - To Account Info

	type Public String TJD
	type String v1,vlastkey
	set v1=TJD
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.oldVal
	set dayendxfr.ccc=ln.cc.oldVal
	set dayendxfr.cglsc=ln.glsc.oldVal
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.ctype=ln.type
	set dayendxfr.feerem=$$FRCSTR^LNFUNCS(ln.cid)
	set dayendxfr.glsc=ln.glsc.curVal
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=1

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj12(RecordLN ln)	// HIST_I  Table HIST  History Entry for New Account

	type Public String %IDENT,%UID,TJD,TLO
	type String v1,vlastkey
	set v1=ln.cid
	set vlastkey=Db.nextVal("HIST","CID=:v1")
	type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
	set hist.brcd=ln.boo
	set hist.cdt=+$H
	set hist.ident=%IDENT
	set hist.tcmt=$$^MSG(6795)
	set hist.time=$P($H,",",2)
	set hist.tjd=TJD
	set hist.tlo=TLO
	set hist.uid=%UID

	do hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj13(RecordLN ln)	// HIST_I_APPNUM  Table HIST  Application Number - Insert

	type Public String EFD,%UID,TJD,TLO
	type String v1,vlastkey
	set v1=ln.cid
	set vlastkey=Db.nextVal("HIST","CID=:v1")
	type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
	set hist.brcd=ln.boo
	set hist.cdt=+$H
	set hist.efd=$G(EFD)
	set hist.tcmt=$$^MSG(3333,"[LN]APPNUM::"_ln.appnum)
	set hist.time=$P($H,",",2)
	set hist.tjd=TJD
	set hist.tlo=TLO
	set hist.uid=%UID

	do hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj14(RecordLN ln)	// HIST_U  Table HIST  History for File Maintenance

	type Public String vx()
	type String vdi
	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  if 'vx(vdi).piece("|",3) if vdi'="TLD" do {
		type Public String vx(),EFD,%IDENT,%UID,TJD,TLO,vfmtable
		type String v1,vlastkey

		type String vold,vnew,vfmtable

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)
		set vfmtable=vx(vdi).piece("|",11)

		set v1=ln.cid
		set vlastkey=Db.nextVal("HIST","CID=:v1")
		type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
		set hist.brcd=ln.boo
		set hist.cdt=+$H
		set hist.efd=$G(EFD)
		set hist.ident=%IDENT
		set hist.tcmt=$$TCMTFM^ACNFUNCS("","LN",vdi,vold,vnew,$G(EFD),,vfmtable)
		set hist.time=$P($H,",",2)
		set hist.tjd=TJD
		set hist.tlo=TLO
		set hist.uid=%UID

		do hist.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit


vj15(RecordLN ln,String vdi)	// TYPE_FROM_U  Table DAYENDXFR  Product Type Change - From Account Info

	type Public String TJD
	type String v1,vlastkey
	set v1=TJD
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.oldVal
	set dayendxfr.ccc=ln.cc.oldVal
	set dayendxfr.cglsc=ln.glsc.oldVal
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.ctype=ln.type.curVal
	set dayendxfr.glsc=ln.glsc.oldVal
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type.oldVal
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=0

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj16(RecordLN ln,String vdi)	// TYPE_TO_U  Table DAYENDXFR  Product Type Change - To Account Info

	type Public String TJD
	type String v1,vlastkey
	set v1=TJD
	set vlastkey=Db.nextVal("DAYENDXFR","TJD=:v1")
	type RecordDAYENDXFR dayendxfr=Db.getRecord("DAYENDXFR","TJD=:v1,SEQ=:vlastkey",1)
	set dayendxfr.acr=ln.acr
	set dayendxfr.cc=ln.cc.oldVal
	set dayendxfr.ccc=ln.cc.oldVal
	set dayendxfr.cglsc=ln.glsc.oldVal
	set dayendxfr.cid=ln.cid
	set dayendxfr.coa=ln.coa
	set dayendxfr.ctype=ln.type.oldVal
	set dayendxfr.glsc=ln.glsc.oldVal
	set dayendxfr.iunc=ln.iunt
	set dayendxfr.lchg=ln.lchg
	set dayendxfr.prn=ln.bal
	set dayendxfr.rec=ln.rec
	set dayendxfr.type=ln.type.curVal
	set dayendxfr.udbal=ln.udbalxfr
	set dayendxfr.unapf=ln.unapf
	set dayendxfr.xflg=1

	do dayendxfr.save("/NOVALFK/NOVALDD/NOVALRI")

	quit



public VINDEX(RecordLN ln) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		type String vf,vi,viMap,vxn
		set viMap=",CONVACN,~1~|,ANOFFDT,~2~|,BNDT,~3~|,COLEXTRDYS,~4~|,ICHND,~5~|,INDEX,~6~|,INTOFFDT,~7~|,CCL,~8~|,CCL,TRACN,~9~|,LNFEETA,~10~|,CVCID,~11~|,INTMAT,~12~|,MDT,~13~|,PAYLKTO,~14~|,PCHND,~15~|,PCOFFDT,~16~|,RANDOFF,~17~|,RDT,~18~|,SCHND,~19~|,SDTA,~20~|,SRCDT,~21~|,SUBPLN,~22~|,WDND,~23~|,CLS,ACN,~24~|,BOO,~25~|,CC,CLS,GRP,TYPE,~26~|,CLS,GRP,TYPE,~27~|,CLS,~28~|,CLS,GRP,TYPE,CRCD,~29~|,CLS,BOO,PROVCAT,"
		set viMap=viMap_"TYPE,~30~|"
		set vf=0
		set vxn=""
		for  set vxn=vx(vxn).order() quit:vxn=""  do {
			for  set vf=$F(viMap,(","_vxn_","),vf) quit:vf=0  do {
				set vi=viMap.extract(vf,999).piece("~",2)
				set viMap.piece("|",vi)=""
				do @("vi"_vi_"(.ln)")
			}
		}
	}
	do vi1(.ln)
	do vi2(.ln)
	do vi3(.ln)
	do vi4(.ln)
	do vi5(.ln)
	do vi6(.ln)
	do vi7(.ln)
	do vi8(.ln)
	do vi9(.ln)
	do vi10(.ln)
	do vi11(.ln)
	do vi12(.ln)
	do vi13(.ln)
	do vi14(.ln)
	do vi15(.ln)
	do vi16(.ln)
	do vi17(.ln)
	do vi18(.ln)
	do vi19(.ln)
	do vi20(.ln)
	do vi21(.ln)
	do vi22(.ln)
	do vi23(.ln)
	do vi24(.ln)
	do vi25(.ln)
	do vi26(.ln)
	do vi27(.ln)
	do vi28(.ln)
	do vi29(.ln)
	do vi30(.ln)

	quit
	

vi1(RecordLN ln) // Maintain ACONVACN index entries (Converted Account/Account)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.convacn
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCONVACN(v1,v2)) do vidxerr("ACONVACN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCONVACN(v1,v2)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CONVACN").exists() set v1=vx("CONVACN").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCONVACN(v1,v2)
	#ENDBYPASS
	quit

vi2(RecordLN ln) // Maintain ANOFF index entries (Payment Change Analysis Date )

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.anoffdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"ANOFF",v3)) do vidxerr("ANOFF")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"ANOFF",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("ANOFFDT").exists() set v1=vx("ANOFFDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"ANOFF",v3)
	#ENDBYPASS
	quit

vi3(RecordLN ln) // Maintain BNDT index entries (Billing - Next Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.bndt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"BNDT",v3)) do vidxerr("BNDT")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"BNDT",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("BNDT").exists() set v1=vx("BNDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"BNDT",v3)
	#ENDBYPASS
	quit

vi4(RecordLN ln) // Maintain COLEXTRDYS index entries (Collection Extract Days)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.colextrdys
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("COLEXTRDYS",v2,v3)) do vidxerr("COLEXTRDYS")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("COLEXTRDYS",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("COLEXTRDYS").exists() set v2=vx("COLEXTRDYS").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("COLEXTRDYS",v2,v3)
	#ENDBYPASS
	quit

vi5(RecordLN ln) // Maintain ICHND index entries (Loan Int Change Next Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.ichnd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"ICHND",v3)) do vidxerr("ICHND")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"ICHND",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("ICHND").exists() set v1=vx("ICHND").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"ICHND",v3)
	#ENDBYPASS
	quit

vi6(RecordLN ln) // Maintain INTINDEX index entries (Interest Index)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.index
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("INDEX",v2,v3)) do vidxerr("INTINDEX")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("INDEX",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("INDEX").exists() set v2=vx("INDEX").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("INDEX",v2,v3)
	#ENDBYPASS
	quit

vi7(RecordLN ln) // Maintain INTOFF index entries (Interest Review Offset Days)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.intoffdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"INTOFF",v3)) do vidxerr("INTOFF")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"INTOFF",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("INTOFFDT").exists() set v1=vx("INTOFFDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"INTOFF",v3)
	#ENDBYPASS
	quit

vi8(RecordLN ln) // Maintain LCOM index entries (Commitment Cross-reference)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.ccl
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("LCOM",v2,v3)) do vidxerr("LCOM")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("LCOM",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CCL").exists() set v2=vx("CCL").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("LCOM",v2,v3)
	#ENDBYPASS
	quit

vi9(RecordLN ln) // Maintain LCOMACN index entries (Loan Commitment Bullet XREF)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.ccl
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.tracn
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("LNKCOM",v2,v3,v4)) do vidxerr("LCOMACN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("LNKCOM",v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CCL").exists() set v2=vx("CCL").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("TRACN").exists() set v3=vx("TRACN").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("LNKCOM",v2,v3,v4)
	#ENDBYPASS
	quit

vi10(RecordLN ln) // Maintain LNFEETA index entries (Fee Target Account)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.lnfeeta
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("LNFEETA",v2,v3)) do vidxerr("LNFEETA")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("LNFEETA",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("LNFEETA").exists() set v2=vx("LNFEETA").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("LNFEETA",v2,v3)
	#ENDBYPASS
	quit

vi11(RecordLN ln) // Maintain LNSUB index entries (Loan Sub-Account)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.cvcid
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("LNSUB",v2,v3)) do vidxerr("LNSUB")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("LNSUB",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CVCID").exists() set v2=vx("CVCID").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("LNSUB",v2,v3)
	#ENDBYPASS
	quit

vi12(RecordLN ln) // Maintain MATRIX index entries (Interest Matrix Processing)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.intmat
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("MATATT",v2,v3)) do vidxerr("MATRIX")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("MATATT",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("INTMAT").exists() set v2=vx("INTMAT").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("MATATT",v2,v3)
	#ENDBYPASS
	quit

vi13(RecordLN ln) // Maintain MDT index entries (Account Maturity Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.mdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"MDT",v3)) do vidxerr("MDT")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"MDT",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("MDT").exists() set v1=vx("MDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"MDT",v3)
	#ENDBYPASS
	quit

vi14(RecordLN ln) // Maintain PAYLKTO index entries (Payoff - Lockout to Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.paylkto
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"POLO",v3)) do vidxerr("PAYLKTO")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"POLO",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PAYLKTO").exists() set v1=vx("PAYLKTO").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"POLO",v3)
	#ENDBYPASS
	quit

vi15(RecordLN ln) // Maintain PCHND index entries (P&I Payment Change Next Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.pchnd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"PCHND",v3)) do vidxerr("PCHND")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"PCHND",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PCHND").exists() set v1=vx("PCHND").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"PCHND",v3)
	#ENDBYPASS
	quit

vi16(RecordLN ln) // Maintain PCOFF index entries (P&I Payment Change Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.pcoffdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"PCOFF",v3)) do vidxerr("PCOFF")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"PCOFF",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PCOFFDT").exists() set v1=vx("PCOFFDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"PCOFF",v3)
	#ENDBYPASS
	quit

vi17(RecordLN ln) // Maintain RANDOFF index entries (Reamortization Offset)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.randoff
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"RAOFF",v3)) do vidxerr("RANDOFF")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"RAOFF",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("RANDOFF").exists() set v1=vx("RANDOFF").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"RAOFF",v3)
	#ENDBYPASS
	quit

vi18(RecordLN ln) // Maintain RDT index entries (Return Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.rdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"RETURN",v3)) do vidxerr("RDT")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"RETURN",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("RDT").exists() set v1=vx("RDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"RETURN",v3)
	#ENDBYPASS
	quit

vi19(RecordLN ln) // Maintain SCHND index entries (Scheduled Payment - Next Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.schnd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"SCH",v3)) do vidxerr("SCHND")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"SCH",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SCHND").exists() set v1=vx("SCHND").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"SCH",v3)
	#ENDBYPASS
	quit

vi20(RecordLN ln) // Maintain SDTA index entries (Scheduled Disbursement Target)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.sdta
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("SDTA",v2,v3)) do vidxerr("SDTA")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("SDTA",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SDTA").exists() set v2=vx("SDTA").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("SDTA",v2,v3)
	#ENDBYPASS
	quit

vi21(RecordLN ln) // Maintain SRCDT index entries (Strike Rate Compare Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.srcdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"SRCDT",v3)) do vidxerr("SRCDT")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"SRCDT",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SRCDT").exists() set v1=vx("SRCDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"SRCDT",v3)
	#ENDBYPASS
	quit

vi22(RecordLN ln) // Maintain SUBPLN index entries (Subsidy Plan)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.subpln
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("SUBPLN",v2,v3)) do vidxerr("SUBPLN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("SUBPLN",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SUBPLN").exists() set v2=vx("SUBPLN").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("SUBPLN",v2,v3)
	#ENDBYPASS
	quit

vi23(RecordLN ln) // Maintain WDND index entries (Loan Withdrawal Limit Next Da)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.wdnd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"LNWDL",v3)) do vidxerr("WDND")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"LNWDL",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("WDND").exists() set v1=vx("WDND").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"LNWDL",v3)
	#ENDBYPASS
	quit

vi24(RecordLN ln) // Maintain XACN index entries (Primary CIF/Account Index)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.cls
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = ln.acn
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XACN(v1,v2,v3)) do vidxerr("XACN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XACN(v1,v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CLS").exists() set v1=vx("CLS").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("ACN").exists() set v2=vx("ACN").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XACN(v1,v2,v3)
	#ENDBYPASS
	quit

vi25(RecordLN ln) // Maintain XBRCD index entries (Branch of Ownership/Account)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = +ln.boo
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("XBRCD",v2,v3)) do vidxerr("XBRCD")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("XBRCD",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("BOO").exists() set v2=vx("BOO").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("XBRCD",v2,v3)
	#ENDBYPASS
	quit

vi26(RecordLN ln) // Maintain XCC index entries (Cost Center Cross-Reference)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.cc
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = ln.cls
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.grp
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = ln.type
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCC(v1,v2,v3,v4,v5)) do vidxerr("XCC")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCC(v1,v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CC").exists() set v1=vx("CC").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("CLS").exists() set v2=vx("CLS").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("GRP").exists() set v3=vx("GRP").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()
	if vx("TYPE").exists() set v4=vx("TYPE").piece("|",1) set:v4.isNull() v4=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCC(v1,v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi27(RecordLN ln) // Maintain XCLS index entries (Class/Group/Type)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.cls
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = ln.grp
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.type
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCLS(v1,v2,v3,v4)) do vidxerr("XCLS")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCLS(v1,v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CLS").exists() set v1=vx("CLS").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("GRP").exists() set v2=vx("GRP").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("TYPE").exists() set v3=vx("TYPE").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCLS(v1,v2,v3,v4)
	#ENDBYPASS
	quit

vi28(RecordLN ln) // Maintain XCLSACN index entries (Class/Account)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.cls
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCLSACN(v1,v2)) do vidxerr("XCLSACN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCLSACN(v1,v2)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CLS").exists() set v1=vx("CLS").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCLSACN(v1,v2)
	#ENDBYPASS
	quit

vi29(RecordLN ln) // Maintain XCRCD index entries (Currency Code)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = ln.cls
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = ln.grp
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = ln.type
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = ln.crcd
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCRCD(v1,v2,v3,v4,v5)) do vidxerr("XCRCD")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCRCD(v1,v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CLS").exists() set v1=vx("CLS").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("GRP").exists() set v2=vx("GRP").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("TYPE").exists() set v3=vx("TYPE").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()
	if vx("CRCD").exists() set v4=vx("CRCD").piece("|",1) set:v4.isNull() v4=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCRCD(v1,v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi30(RecordLN ln) // Maintain XREFXLNR index entries (Provision Accounts)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = ln.cls
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = +ln.boo
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = ln.provcat
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = ln.type
	if v5.isNull() set v5=(PSL.maxCharValue-1).char()
	type String v6 = ln.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("PROVPOST",v2,v3,v4,v5,v6)) do vidxerr("XREFXLNR")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("PROVPOST",v2,v3,v4,v5,v6)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CLS").exists() set v2=vx("CLS").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("BOO").exists() set v3=vx("BOO").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()
	if vx("PROVCAT").exists() set v4=vx("PROVCAT").piece("|",1) set:v4.isNull() v4=(PSL.maxCharValue-1).char()
	if vx("TYPE").exists() set v5=vx("TYPE").piece("|",1) set:v5.isNull() v5=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("PROVPOST",v2,v3,v4,v5,v6)
	#ENDBYPASS
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("LN")

	while ds.next() do {
		type RecordLN ln=ds.getRecord("LN")
		if vlist.contains("VINDEX") do VINDEX(.ln) quit
		if vlist.contains("ACONVACN") do vi1(.ln)
		if vlist.contains("ANOFF") do vi2(.ln)
		if vlist.contains("BNDT") do vi3(.ln)
		if vlist.contains("COLEXTRDYS") do vi4(.ln)
		if vlist.contains("ICHND") do vi5(.ln)
		if vlist.contains("INTINDEX") do vi6(.ln)
		if vlist.contains("INTOFF") do vi7(.ln)
		if vlist.contains("LCOM") do vi8(.ln)
		if vlist.contains("LCOMACN") do vi9(.ln)
		if vlist.contains("LNFEETA") do vi10(.ln)
		if vlist.contains("LNSUB") do vi11(.ln)
		if vlist.contains("MATRIX") do vi12(.ln)
		if vlist.contains("MDT") do vi13(.ln)
		if vlist.contains("PAYLKTO") do vi14(.ln)
		if vlist.contains("PCHND") do vi15(.ln)
		if vlist.contains("PCOFF") do vi16(.ln)
		if vlist.contains("RANDOFF") do vi17(.ln)
		if vlist.contains("RDT") do vi18(.ln)
		if vlist.contains("SCHND") do vi19(.ln)
		if vlist.contains("SDTA") do vi20(.ln)
		if vlist.contains("SRCDT") do vi21(.ln)
		if vlist.contains("SUBPLN") do vi22(.ln)
		if vlist.contains("WDND") do vi23(.ln)
		if vlist.contains("XACN") do vi24(.ln)
		if vlist.contains("XBRCD") do vi25(.ln)
		if vlist.contains("XCC") do vi26(.ln)
		if vlist.contains("XCLS") do vi27(.ln)
		if vlist.contains("XCLSACN") do vi28(.ln)
		if vlist.contains("XCRCD") do vi29(.ln)
		if vlist.contains("XREFXLNR") do vi30(.ln)
	}

	quit


public VIDXBLD1(RecordLN ln, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.ln) quit
	if vlist.contains("ACONVACN") do vi1(.ln)
	if vlist.contains("ANOFF") do vi2(.ln)
	if vlist.contains("BNDT") do vi3(.ln)
	if vlist.contains("COLEXTRDYS") do vi4(.ln)
	if vlist.contains("ICHND") do vi5(.ln)
	if vlist.contains("INTINDEX") do vi6(.ln)
	if vlist.contains("INTOFF") do vi7(.ln)
	if vlist.contains("LCOM") do vi8(.ln)
	if vlist.contains("LCOMACN") do vi9(.ln)
	if vlist.contains("LNFEETA") do vi10(.ln)
	if vlist.contains("LNSUB") do vi11(.ln)
	if vlist.contains("MATRIX") do vi12(.ln)
	if vlist.contains("MDT") do vi13(.ln)
	if vlist.contains("PAYLKTO") do vi14(.ln)
	if vlist.contains("PCHND") do vi15(.ln)
	if vlist.contains("PCOFF") do vi16(.ln)
	if vlist.contains("RANDOFF") do vi17(.ln)
	if vlist.contains("RDT") do vi18(.ln)
	if vlist.contains("SCHND") do vi19(.ln)
	if vlist.contains("SDTA") do vi20(.ln)
	if vlist.contains("SRCDT") do vi21(.ln)
	if vlist.contains("SUBPLN") do vi22(.ln)
	if vlist.contains("WDND") do vi23(.ln)
	if vlist.contains("XACN") do vi24(.ln)
	if vlist.contains("XBRCD") do vi25(.ln)
	if vlist.contains("XCC") do vi26(.ln)
	if vlist.contains("XCLS") do vi27(.ln)
	if vlist.contains("XCLSACN") do vi28(.ln)
	if vlist.contains("XCRCD") do vi29(.ln)
	if vlist.contains("XREFXLNR") do vi30(.ln)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("LN","MSG",1225,"LN."_di)

	quit


vkchged // Access key changed

	type public RecordLN ln

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	set vux = vx("CID")
	set voldkey = vux.piece("|",1),vobj(ln,-3) = voldkey   // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	do vload                                               // Make sure all data is loaded locally
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do { quit:ER
		do VBU
		if vx("CID").exists() do vbu11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	}
	if vpar["/VALDD/" do vddver
	do vexec

	set vnewkey = vux.piece("|",2),vobj(ln,-3) = vnewkey   // Copy new keys into object
	type RecordLN vnewrec = ln.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("LN",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do {
		do VAU
		if vx("CID").exists() do vau18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	}

	set vobj(ln,-3) = vux.piece("|",1)                     // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

VCASDEL // Cascade delete logic

	type public RecordLN ln
	type public String vpar

	type String vERRMSG

	type ResultSet rs1=Db.select("CID","DAYENDLNNOT","CID=:ln.cid") // Restriction on delete
	if 'rs1.isEmpty() set vERRMSG = $$^MSG(8563,"DAYENDLNNOT(CID) -> LN(CID)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("LNAMOAO","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNAPCHG","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNBIL0","CID=:ln.cid",vpar)              // Cascade delete

	do Db.delete("LNBIL1","CID=:ln.cid",vpar)              // Cascade delete

	do Db.delete("LNCOL","CID=:ln.cid",vpar)               // Cascade delete

	type ResultSet rs7=Db.select("CID","LNCONVEST","CID=:ln.cid") // Restriction on delete
	if 'rs7.isEmpty() set vERRMSG = $$^MSG(8563,"LNCONVEST(CID) -> LN(CID)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("LNCPN","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNCYCDLD","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNCYCINS","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNCYCMSC","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNCYCPTS","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNDS1","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNFEE","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNFEED","CID=:ln.cid",vpar)              // Cascade delete

	do Db.delete("LNLCNOT","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNLS4","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNLS4B","CID=:ln.cid",vpar)              // Cascade delete

	type ResultSet rs19=Db.select("CID","LNLS4C","CID=:ln.cid") // Restriction on delete
	if 'rs19.isEmpty() set vERRMSG = $$^MSG(8563,"LNLS4C(CID) -> LN(CID)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("LNLS6","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNPL3","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNPP6","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNPTCHG","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNRACHG","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNSEG","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNVRCHG","CID=:ln.cid",vpar)             // Cascade delete

	type ResultSet rs27=Db.select("CID","DAYENDLNNOT","CID=:ln.cid") // Restriction on delete
	if 'rs27.isEmpty() set vERRMSG = $$^MSG(8563,"DAYENDLNNOT(CID) -> LN(CID)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("LNAMOAO","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNAPCHG","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNBIL0","CID=:ln.cid",vpar)              // Cascade delete

	do Db.delete("LNBIL1","CID=:ln.cid",vpar)              // Cascade delete

	do Db.delete("LNCOL","CID=:ln.cid",vpar)               // Cascade delete

	type ResultSet rs33=Db.select("CID","LNCONVEST","CID=:ln.cid") // Restriction on delete
	if 'rs33.isEmpty() set vERRMSG = $$^MSG(8563,"LNCONVEST(CID) -> LN(CID)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("LNCPN","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNCYCDLD","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNCYCINS","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNCYCMSC","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNCYCPTS","CID=:ln.cid",vpar)            // Cascade delete

	do Db.delete("LNDS1","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNFEE","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNFEED","CID=:ln.cid",vpar)              // Cascade delete

	do Db.delete("LNLCNOT","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNLS4","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNLS4B","CID=:ln.cid",vpar)              // Cascade delete

	type ResultSet rs45=Db.select("CID","LNLS4C","CID=:ln.cid") // Restriction on delete
	if 'rs45.isEmpty() set vERRMSG = $$^MSG(8563,"LNLS4C(CID) -> LN(CID)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("LNLS6","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNPL3","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNPP6","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNPTCHG","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNRACHG","CID=:ln.cid",vpar)             // Cascade delete

	do Db.delete("LNSEG","CID=:ln.cid",vpar)               // Cascade delete

	do Db.delete("LNVRCHG","CID=:ln.cid",vpar)             // Cascade delete

	quit

VIDXPGM()	quit "LNFILE"	// Location of index program

