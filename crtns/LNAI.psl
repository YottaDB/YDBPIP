LNAI		 /*
 ORIG: KELLYP - 04/03/2000
 DESC: Loan AFTER_INSERT Procedure
 
	---- Comments --------------------------------------------------------

    	This procedure is called from the AFTER_INSERT trigger of the LN filer
 	and all subsequent additions and/or modifications to this trigger should
	only be made within this procedure (and not to the original trigger).

	---- Revision History ------------------------------------------------

	07/10/07 - KumarSS - CR 28087
		   Modified to quit the IF block that validates the Date of
		   First Payment (DFP) of loan account, when no record is
		   found in LNBIL1 table.
		   This fix rectifies the issue that the Integrity Check by 
		   Group/Type (LNI003) function logs an '%PSL-E-RECNOFL' error.

	07/05/07 - VanithaK - CR28007
	           Modified the changes made for CR 27879 to include a test
		   case when Region code starts with zero.
	
    	07/03/07 - DHANALAKSHMI R - CR27573
		   Modified the section PROC to correct the settings of LCAD to
		   avoid the error message "Late Charge Action Date Invalid".

	06/28/07 - VanithaK - CR27879
	           Added validation for Branch of Ownership when bankid is 
	           defined.
	
	05/31/07 - KUMARB - CR 27163
		   Modified to check for errors related to Credit Card processing
		   if Segments Allowed (LN.SEGMENTS) is selected.
	
	05/30/07 - CHAITHRA - CR 26879
		   Modified PROC section for setting up linked fees.  Fees linked 
		   to the P or I payment elements should only be set up on the loan 
		   if the "Include Linked Fees" flag on the pmt string is enabled. 
		   Also modified code to set up as many linked fees as there are fee
		   plans linked to a payment element.  
	
	04/17/07 - VARGAJ - CR24940
		   The key structure for CHECK was changed to support the move from
		   globally unique check numbers to being unique at the account level.

	03/16/07 - PUTTASWH - CR 24945
		   Modified PROC section to validate for LN.VATINTOPT to 2
		   if data is present in LN.BILINFLCALIN for VAT processing. 
		   
	01/05/07 - KUMARB - CR24680
		   Modified section PROC to call INSERT^LNSEG if Segments
		   Allowed (LN.SEGMENTS) is selected and ProcessMode is not
		   in Verify Mode.
		   
		   Below Validations are added for segmented accounts
		 * Added code to return error message "Interest Offset 
		   Processing not allowed for segmented accounts" if 
		   Interest Review Offset Days (LN.INTOFF) is defined.
		 * Added code to return error message "Interest Determination
		   Point at payment not allowed for segmented accounts" if 
		   Interest Determination Point (LN.IDP) are selected.
		 * Added code to return error message "Promotional Rate
		   processing not allowed for segmented accounts" if
		   Promotional Index (LN.PROIND), Promotional Rate (LN.TRATE),
		   or Promotional Rate – Expiration Date (LN.TREXD) is defined.
	
	08/12/06 - PUTTASWH - CR 22992
		   Modified PROC section to pass the Late Charge Calendar
		   object to BD^UNBD function when incrementing the LCAD 
		   variable if ln.lcbo="N". 
		   
	08/30/06 - SANTHUMS - CR 22587
	           Modified PROC section to call BIL0ELE^BILFUNCS instead 
	           of PMTELEM^LNFUNCS to get the LNBIL0 control record 
	           and payment elements.
	           
	07/31/06 - KELLYP - CR 22048
		   Modified to eliminate PRECEDENCE warning.

	07/20/06 - Giridhal - CR 21207
		   Modified to default the county information for the seasonal 
		   address to the newly created accounts
		   
	05/24/06 - KinI - CR 21369
		   Modified to add .get() to ROLES() array to avoid undefined
		   when performing relationship code integrity check.
		   
	05/10/06 - KUMARB - CR 21107
		   Modified section PROC, in block "Check BNDT and payment record"
		   added conditional quit if processmode=0 and dist1fre="*" and 
		   PDD is null.
	
	03/15/06 - chhabris - CR19833
		   Removed the check for %Processmode=2 for the integrity check
		   for idp and iam as these will be thrown as a message instead
		   of integ errors.
	
	03/03/06 - chhabris- CR19807
		   Added integrity check for subsidized loans with ln.idp set 
		   as 1 and also ln.iam.
	
	01/17/06 - KELLYP - CR 19080
		   Modified the check on ln.maxaggr to check for (ln.maxaggr)
		   instead of ('ln.maxaggr.isNull()).  This prevents a problem
		   from occurring where the system defaults in a zero for this
		   column (because DBTBL1D.NULLIND is enabled) and the check
		   then determines that 0 is not null and 0 is less than the
		   credit limit, and returns error message # 4279 incorrectly.
	
	12/05/05 - Radhika - CR 16891
	           Removed the code that inserts records into EMPLNOT.TBL.
	
	11/18/05 - KELLYP - CR 18288
		   Modified the ln.ichnd "do" block to quit after checking for 
		   ICHND<TJD when not using interest offset processing 
		   (INTOFF="").  This prevents XBAD 76 from being returned when 
		   ICHND=TJD and INTOFF="" (ICHND can equal TJD as long as 
		   INTOFF="").
	
	10/14/05 - KELLYP - CR 17818
		   Modified relrs loop to fix a typo.  It was iterating through
		   relrs but incorrectly referenced rs.
	
	09/27/05 - RussellDS - CR17311
		   Modify buffer number assignment for EFD.

	08/18/05 - KELLYP - CR 16684
		   Modified second call to TTX^LNCL1 in this procedure to pass
		   the lnccl object instead of the ln object (wrong object was
		   being passed which caused integrity errors on the acct).
		   Also modified code for error message # 2036 which was 
		   causing PSL compilation errors.

	06/10/05 - KELLYP - CR 13662
		   Modified edit checks on INTMX and INTMN.  The previous checks 
		   were failing because the 'isNull checks were not encapsulated 
		   in parentheses.

	06/01/05 - KinI - 16153
		   Modified to remove GLFLTR^ACNFUNCS call as GL filter 
		   functionality has been obsoleted. Added new GL set code 
		   verification via GLCHK^ACNFUNCS to ensure that the class
		   and group of GLSC match the class and group of the loan.
		   Removed 'Db.isDefined check on UTBLGLSC table as 
		   GLCHK^ACNFUNCS returns the same error if the set code isn't 
		   defined.

	05/18/05 - KELLYP - CR 15268
		   Modified to populate the XSGNCRD table.  This table was 
		   formerly populated via the XSGNCRD index but needs to be
		   populated via the triggers since XSGNCRD needs to be treated
		   as a regular table because records need to be directly 
		   fetched from it.

	04/18/05 - KELLYP - CR 13662
		   Modified code around calls to TTX^LNCL1 to prevent a "record
		   already exists" error from occurring when creating a commitment.
		   The transactions spawned by LNCL1 update the ln record so the
		   record mode needs to be 1 (Modify) at that point.

	02/22/05 - KELLYP - CR 13662
		   Modified to retype a few variables correctly and added error
		   message text above several error messages that were missing it.

	02/17/05 - Kini - 13991	
		   Modified to replace UTBLGLSCX index table with UTBLGLSC
		   since UTBLGLSCX has been obsoleted.

	01/25/05 - KELLYP - CR 13662
		   Cleaned up procedure, modified to conform to current
		   PSL standards, and removed pre-2003 revision history.
		   Also consolidated Loan Cycled Item edit checks and 
		   moved several edit checks over from LNBI.

	05/26/04 - KELLYP - CR 8446
		   Fixed call to CTL^UINDX to pass PAR by reference instead 
		   of by value to avoid an undefined error (PAR is an array).

	1/21/04 - Spier CR 7985
		   Correct missing parenthesis error 
		   
	12/22/03 - spier - 7501
		   Added build for DAYENDRAND which is no longer an index.
		   Added build for DAYENDNEGAM which is no longer using an index
		   
	11/11/03 - CARROLLJ - 51630
		   Correct call to CTL^UINDX.

	05/15/03 - CARROLLJ - 51349
		   Modified call to LNCL1 to call linetag TTX instead of EXT.
		   Also removed code that checked %STFHOST to call into STFUTL
		   and moved the code to LNCL1.

	03/12/03 - Dan Russell - 51351
		   Remove reference to membership.  It is no longer supported
		   in V7.0.  Also modified call to BALINT^LNFUNCS to pass ln
		   object.

		   Removed old change history (pre 2002).

	01/27/03 - Spier 51423
		   Corrected syntax error on db.isdefined, missing 
		   quotes on keys           	
 */

 quit		// Dummy quit for compiler

public PROC(RecordLN ln)  // Entry point from AFTER_INSERT of LN filer

	type Public String ER,ET,RM

	type Number I
	type String LNBIL0,PCMVAL,PE,PMTELEM()
	
	set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)
		
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=ln.cid",1)
	if lnbil0.getMode() do {

		set LNBIL0=$$BIL0ELE^BILFUNCS(.lnbil0).translate($C(9),"|")
 
		for I=1:1:20 set PE=LNBIL0.piece("|",I) if 'PE.isNull() set PMTELEM(I)=PE.piece("#",1,2)
		}
	
	// Instantiate records needed throughout procedure
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")
	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:ln.type")
	type RecordCIF cif=Db.getRecord("CIF","ACN=:ln.acn")
 
	// Low Level Defaults
	if %ProcessMode=0 do { quit:ER

		type String END(),FILE

		type ResultSet rs=Db.select("DFTDEF","UTBLLLD")
		if rs.isEmpty() quit

		do START^LLDDEF(ln.cid)
		set FILE=""
		
		// Expired element in low level default table ~p1
		for  set FILE=END(FILE).order() quit:(FILE="")!(ER)  do Runtime.setErrXBAD("LN","LLD",FILE) quit:ER
		}
 
	// Check that ln.dpa is a deposit account
	if 'ln.dpa.isNull() do { quit:ER
		type RecordACN acndpa=Db.getRecord("ACN","CID=:ln.dpa")
		
		// Deposit payoff account must be a deposit account
		if acndpa.cls'="D" do Runtime.setErrXBAD("LN","LNDPA") quit:ER
		}

	// If opening date/disbursement date is 0, this is invalid date format.
	// Data type is defined as ~p1 (Date)
	if (ln.dtnt=0)!(ln.odd=0) do Runtime.setErrMSG("LN",742,$$^MSG(3789)) quit:ER
 
	// Product type ~p1 not available prior to ~p2
	type Date DTBEG
	set DTBEG=prodctl.dtbeg
	if ln.dtnt<prodctl.dtbeg do Runtime.setErrMSG("LN",2036,ln.type_"~"_DTBEG.toString()) quit:ER
	
	// Conversion Account Required for Non-PROFILE Institution Account.
	if prodctl.nonpa=1,ln.convacn.isNull() do Runtime.setErrMSG("LN",4896) quit:ER 

	// Invalid CIF
	if (%ProcessMode=2),'Db.isDefined("CIF","ln.acn") do Runtime.setErrXBAD("LN","INVLDCIF") quit:ER
 
	// Check that dates/frequencies correspond only if PCM 2 (Interest 
	// Calculation) is 1 (Standard Formula Using IRN).
	// "New payment change frequency inconsistent with interest change frequency."
	if PCMVAL.extract(),(PCMVAL.extract(2)=1),('ln.pcfre.isNull()),('ln.intfre.isNull()) do VER^LNUSFV(ln.ichnd,ln.intfre,,ln.pchnd,ln.pcfre,) quit:ER
 
	// Only perform a subset of integrity checks if the loan is closed
	if ln.stat=4 do { quit
	
		// Closed Loan with Accrual Balance
		if ln.acr do Runtime.setErrXBAD("LN",45,"ACR",ln.acr,0) quit:ER
 
		// Closed Loan with Undisbursed Balance
		if ln.aruf,ln.udbal do Runtime.setErrXBAD("LN",121,"UDBAL",ln.udbal,0) quit:ER
 
		// Closed Loan with Ledger Balance
		if ln.bal do Runtime.setErrXBAD("LN",44,"BAL",ln.bal,0) quit:ER
 
		// Closed Loan with Late Charge
		if ln.lchg do Runtime.setErrXBAD("LN",118,"LCHG",ln.lchg,0) quit:ER
 
		// Check PTS info
		type RecordLNCYCPTS lncycpts=Db.getRecord("LNCYCPTS","CID=:ln.cid,TYP='PTS'",1)
		if lncycpts.getMode() do { quit:ER
		
			if lncycpts.cntr'<lncycpts.term quit
			if lncycpts.caltd,lncycpts.amt=lncycpts.caltd quit
		
			// Closed Account with Non-Performing Fee Balance
			if lncycpts.npda do Runtime.setErrXBAD("LN",94) quit:ER

			// Closed Account with Deferred Fee Balance
			if lncycpts.amt'=lncycpts.caltd do Runtime.setErrXBAD("LN",93) quit:ER
			}
			
		// Get payment elements
		type Number ESCCID
		type String PE
 
		// Check to see if all escrow accounts are closed
		set PE=""
		for  set PE=PMTELEM(PE).order() quit:PE.isNull()  set ESCCID=PMTELEM(PE).piece("#",2) if ESCCID do { quit:ER
			type RecordACN acnesc=Db.getRecord("ACN","CID=:ESCCID")
			
			// Closed Loan with Open Escrow Account
			if acnesc.stat'=4 do Runtime.setErrXBAD("LN",152) quit:ER
			}
		}
		
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do { quit:ER
		
			// Interest Offset Processing not allowed for segmented accounts
			if 'ln.intoff.isNull() do Runtime.setErrMSG("LN",5339) quit:ER
		
			// Interest Determination Point at payment not allowed for segmented accounts
			if ln.idp do Runtime.setErrMSG("LN",6180) quit:ER
		
			// Promotional Rate processing not allowed for segmented accounts
			if (('ln.proind.isNull())!('ln.trate.isNull())!('ln.trexd.isNull())) do Runtime.setErrMSG("LN",6181) quit:ER
			
			// Revolving Credit indicator must be set for segmented accounts
			if 'ln.revf do Runtime.setErrMSG("LN",6204) quit:ER
			
			// Disbursement Schedule Processing not allowed for segmented accounts
			if ln.dschpr do Runtime.setErrMSG("LN",6205) quit:ER
			
			// Multiple Distributions not allowed for segmented accounts
			if ln.mdf do Runtime.setErrMSG("LN",6206) quit:ER
			
			// Average Interest Recalculation not allowed for segmented accounts
			if ln.air do Runtime.setErrMSG("LN",6207) quit:ER
			
			// Commitment Billing not allowed for segmented accounts
			if ln.cbf do Runtime.setErrMSG("LN",6208) quit:ER
			
			// Commitment Delinquency not allowed for segmented accounts
			if ln.cdf do Runtime.setErrMSG("LN",6209) quit:ER
			
			// Interest Reserve Processing not allowed for segmented accounts
			if ln.irp do Runtime.setErrMSG("LN",6210) quit:ER
			
			// Cannot Advance Due Dates with Late Charge Payments for segmented accounts
			if ln.addlchg do Runtime.setErrMSG("LN",6211) quit:ER
			
			// Advances to Reduce Undisbursed balances not allowed for segmented accounts
			if ln.aruf do Runtime.setErrMSG("LN",6212) quit:ER
			
			// Loan Budget Processing not allowed for segmented accounts
			if ln.entf do Runtime.setErrMSG("LN",6213) quit:ER
			
			// Interest cannot be Collected in Advance for segmented accounts
			if ln.icm>0 do Runtime.setErrMSG("LN",6214) quit:ER
			
			// Interest Amortization Method must be No Interest Add-On/Discount for segmented accounts
			if ln.iam>0 do Runtime.setErrMSG("LN",6215) quit:ER
			
			// Construction Loan Processing not allowed for segmented accounts
			if ln.clps>0 do Runtime.setErrMSG("LN",6216) quit:ER
			
			// Segmented accounts cannot be saleable
			if ln.slbl=0 do Runtime.setErrMSG("LN",6217) quit:ER
		
			// Insert Loan Account Segment if Segments Allowed flag is selected
			if %ProcessMode'=2 do INSERT^LNSEG(.ln, ln.dtnt, 1)
			}
	#ENDIF
 
	// Employer/Institution relationship - first account open notification
	if %ProcessMode=0,'ln.emplno.isNull() do { quit:ER

		type RecordUTBLEMPLOYER utblemp=Db.getRecord("UTBLEMPLOYER","EMPLNO=:ln.emplno")
		if utblemp.fcidd quit

		set utblemp.fcidd=%SystemDate
		do utblemp.save()
		}

	// ACR - Accrued Interest
	if %ProcessMode=2 do { quit:ER
	
		type Number TMPAMT
	
		set TMPAMT=ln.cuin+ln.unin

		// Billed/Unpaid Interest Exceeds Accrued Interest 		
		if 'ln.idp,'PCMVAL.extract(2),'PCMVAL.extract(4),TMPAMT,TMPAMT>$$^SCARND(ln.acr,0,ln.cid) do Runtime.setErrXBAD("LN",128,"ACR",ln.acr,TMPAMT) quit:ER
		}		

	/*
	 ACS - Accrual Processed Indicator Error
	 Should not be displayed for non-PROFILE accounts
	*/
	if %SystemDate-ln.acs>1,prodctl.nonpa'=1 do Runtime.setErrXBAD("LN","ACS") quit:ER
 
	// Auto ln pmt acct requird for int collectd on prin repayments
	if ln.aipr,ln.auptcid.isNull() do Runtime.setErrXBAD("LN",522) quit:ER
 
	// Auto ln pmt processing requires auto ln pmt acct
	if ln.alpdue,ln.auptcid.isNull() do Runtime.setErrXBAD("LN",523) quit:ER
 
 	// Late Chrg Max Ovr must be greater than Late Chrg Min Ovr
	if ln.maxo,(ln.maxo<ln.mino) do Runtime.setErrXBAD("LN","MAXGTMIN") quit:ER 
 
	/*
	 Auto Loan Payment Due Method must be greater than 0 when Auto Loan Payment
	 Account is defined
	*/
	if 'ln.alpdue,'ln.auptcid.isNull() do Runtime.setErrMSG("LN",3985) quit:ER
 
	// AMOUNT REQUESTED Outside Valid Range
	if (ln.amtreq<ln.mincl)!(ln.maxbal&(ln.amtreq>ln.maxbal)) do Runtime.setErrXBAD("LN",116) quit:ER

	// NEXT ANNUAL RATE REVIEW DATE in the Past
	if 'ln.anirnd.isNull(),ln.anirnd<%SystemDate do Runtime.setErrXBAD("LN",80) quit:ER
 
	// ESCROW PAYMENT CHANGE Date in the Past
	if ln.apcnd'="",ln.apcnd<%SystemDate do Runtime.setErrXBAD("LN",77) quit:ER
	
	// Maturity date must be after disbursement date
 	if ln.mdt,ln.mdt'>ln.odd do Runtime.setErrMSG("LN",1680) quit:ER

	// Maturity date must be later than opening date
	if ln.mdt,ln.mdt'>ln.odt do Runtime.setErrMSG("LN",1681) quit:ER     

	/*
	 ANFRE - Analysis Frequency - valid consistency of columns related to
	 analysis change in process
	*/
	if 'ln.anfre.isNull() do { quit:ER
		
		type Date APCLD
		set APCLD=""
		
		if ln.apcld.isNull(),ln.apcnd do { quit:ER
			type String FRE
			set FRE="-"_ln.anfre
			set APCLD=$$NJD^UFRE(ln.apcnd,FRE) quit:ER
			}
 
		/*
		Analysis change in process flag not set and there was an analysis
		posting at some time.  We're OK if offset date in future, or if in
		the past and last period preceeds last analysis date (in that case
		in offset period and haven't posted)
		*/

		// Analysis In-Proc Flag Not Set, Analysis Posted
		if 'ln.eacip,ln.anld,ln.anoffdt'>%SystemDate,ln.anld'<APCLD do Runtime.setErrXBAD("LN",509) quit:ER

		if ln.eacip do { quit:ER
		
			// OK if offset date in past and next analysis date in the future
			if ln.anoffdt'>%SystemDate,%SystemDate<ln.apcnd quit
 
			/*
			OK if analysis falls after the last analysis change date and before 
			the next offset date -- then we've done off-cycle analysis
			*/
			if ln.anld<ln.anoffdt,ln.anld>ln.apcld quit
 
			// Analysis Chng In-Proc Flag Set, Ln Not in Analysis
			do Runtime.setErrXBAD("LN",505) quit:ER
			}
		}
 
	// NEXT ANNUAL PMT REVIEW DATE in the Past
	if 'ln.anptnd.isNull(),ln.anptnd<%SystemDate do Runtime.setErrXBAD("LN",81) quit:ER
 
	// BALINT - Balance for Interest Calculation
	if 'ln.balint.isNull() do { quit:ER
		type Number BALINT
		set BALINT=$$BALINT^LNFUNCS(.ln)
 
		// Balance for Interest Calculation not supported
		if +ln.balint'=+BALINT do Runtime.setErrXBAD("LN",43,"BALINT",ln.balint,BALINT) quit:ER
		}

	// CHKPRD - Check Book Production File on Create
	if ('%ProcessMode=2),ln.chkeuro=1,ln.chkiss=1,ln.chkcnt>0 do { quit:ER
		type RecordUTBLCHKS utblchks = Db.getRecord("UTBLCHKS", "CHKS=:ln.chks",1)
		
		// Missing required field ~p1
		if utblchks.accntnum '= 1 do Runtime.setErrMSG("LN",6174,"UTBLCHKS.ACCNTNUM") quit:ER
		
		type RecordCHKPRD chkprd=Class.new("RecordCHKPRD")
		
		set chkprd.brcd=ln.boo
		set chkprd.tjd=%SystemDate
		set chkprd.cid=ln.cid
		set chkprd.chks=ln.chks
		set chkprd.seq=1
		set chkprd.chkcnt=ln.chkcnt
		set chkprd.uid=%UserID
		set chkprd.stat=0
		set chkprd.acn=ln.acn
		
		do chkprd.save()
		}

	// Penalty Balance Next Cutoff Date required
	if ln.pbfre,('ln.pbnxtdt) do Runtime.setErrMSG("LN",4650) quit:ER

	// Penalty Balance Review Frequency required
	if ln.pbnxtdt,('ln.pbfre) do Runtime.setErrMSG("LN",4649) quit:ER

	// Cannot use processing for both Collateral Credit Limit and Loan Withdrawal Limit
	if ln.collimpr,ln.wdlmtp do Runtime.setErrMSG("LN",4648) quit:ER
	
	// Adjust Collateral Credit Limit cannot be enabled if Collateral Credit Limit Processing is disabled
	if ln.adjcol,('ln.collimpr) do Runtime.setErrMSG("LN",4656) quit:ER

	// BLDT - Billing Last Date
	if 'ln.bldt.isNull() do { quit:ER
	
		type Date CBCD
	
		// Get last bill date from bill file to validate
		type ResultSet rs=Db.select("CBCD","LNBIL1","CID=:ln.cid","SCHSEQ DESC")
		if rs.isEmpty() quit
		if rs.next() set CBCD=rs.getCol(1)
 
		// Last bill sequence inconsistent with internal bill
		if 'CBCD.isNull(),CBCD<ln.bldt do Runtime.setErrXBAD("LN",2,"BLDT",ln.bldt,CBCD) quit:ER
		}
 
	// Next bill date precedes system processing date
	if ln.bndt,ln.bndt<%SystemDate do Runtime.setErrXBAD("LN",14,"BNDT",ln.bndt) quit:ER
 
	// NEXT COUPON PRODUCTION DATE in the Past
	if ln.cbmet=3,'ln.cbpnd.isNull(),ln.cbpnd<%SystemDate do Runtime.setErrXBAD("LN",82,"CBPND",ln.cbpnd) quit:ER
 
	// CCL - Commercial Commitment Link
	if 'ln.ccl.isNull() do { quit:ER
 
		// Cannot link account to itself
		if ln.ccl=ln.cid do Runtime.setErrMSG("LN",461) quit:ER
 
		type RecordLN lnccl=Db.getRecord("LN","CID=:ln.ccl",1)
		
		// Loan Linked to Invalid Commitment
		if 'lnccl.getMode() do Runtime.setErrXBAD("LN",163,"CCL",ln.ccl) quit:ER
		 
		// Account ~p1 is not coded for commitment processing
		if 'lnccl.cpf do Runtime.setErrMSG("LN",118,lnccl.cid) quit:ER
 
		// Loan Linked to Closed Commitment
		if lnccl.stat=4 do Runtime.setErrXBAD("LN",164,"CCL",lnccl.cid) quit:ER

		type String PARAM
		set PARAM=ln.cid_"~"_lnccl.cid
 
		// Credit limit for ~p1 exceeds undisbursed balance for ~p2 (Account Create)
		if %ProcessMode'=2,ln.trb,ln.crlmt>lnccl.avlbal do Runtime.setErrMSG("LN",650,PARAM) quit:ER
 
		// Credit limit for ~p1 exceeds undisbursed balance for ~p2 (Account Verification)
		if %ProcessMode=2,ln.trb,lnccl.avlbal<0 do Runtime.setErrMSG("LN",650,PARAM) quit:ER
 
		// Revolving commitments may not spawn sub-commitments
		if ln.cpf,lnccl.revf do Runtime.setErrMSG("LN",2423) quit:ER

		// Must use account of the same currency (~p1)
		if ln.crcd'=lnccl.crcd do Runtime.setErrMSG("LN",6052,ln.crcd) quit:ER
 
		type Number CLEVEL,XCCL
		set CLEVEL=1
		set XCCL=ln.ccl

		// Make sure no more than five levels of commitments
		for  quit:(CLEVEL>4)!(XCCL.isNull())  do { 
			type RecordLN ln=Db.getRecord("LN","CID=:XCCL")
			set XCCL=ln.ccl
			set CLEVEL=CLEVEL+1
			}
		 
		// Commitment heirarchy five levels or less
		if CLEVEL>4 do Runtime.setErrSTBLER("LN","CCL5") quit:ER

		// Commitment Billing flag must equal linked commitment
		if ln.cbf'=lnccl.cbf do Runtime.setErrMSG("LN","4284") quit:ER
		
		// Commitment Delinquency flag must equal linked commitment
		if ln.cdf'=lnccl.cdf do Runtime.setErrMSG("LN","4286") quit:ER

		// Interest Reserve Processing flag must be enabled on this acct
		if lnccl.irp,('ln.irp) do Runtime.setErrMSG("LN","4305") quit:ER
		
		// Loan's payment frequency must equal linked commitment's
		if ln.cbf,lnccl.dist1fre'=ln.dist1fre,'ln.dist1fre.isNull() do Runtime.setErrMSG("LN","4285") quit:ER
		
		// Cannot define Interest Reserve Account on both the commitment and linked loans
		if 'ln.ircid.isNull(),'lnccl.ircid.isNull() do Runtime.setErrMSG("LN","4290") quit:ER
		}

	// Credit Limit Less Than Minimum
	if ln.crlmt<ln.mincl do Runtime.setErrXBAD("LN",143,"MINCL",ln.mincl) quit:ER
 
	// Credit Limit Greater Than Maximum
	if ln.maxbal,ln.amtreq>ln.maxbal do Runtime.setErrXBAD("LN",144,"MAXBAL",ln.maxbal) quit:ER
 
	if ln.darcovr do { quit:ER
		// Delinquency reclassification processing not valid for product type ~p1
		if 'prodctl.darcpo do Runtime.setErrMSG("LN",1292,ln.type) quit:ER
 
		// Invalid table value ~p1
		if 'Db.isDefined("UTBLACC","ln.cls,ln.darcovr") do Runtime.setErrMSG("LN",1485,"UTBLACC.AC") quit:ER
		}

	/*
	DFP - Date of First Payment
	If not a commitment & amortizing & there is a bill sequence, check
	*/
	if 'ln.cpf,PCMVAL.extract(),ln.bseq do { quit:ER

		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:ln.cid,SCHSEQ=1",1)

		// Quit if no bill record is generated.
		if lnbil1.getMode()=0 quit

		// Invalid First Payment Date
		if lnbil1.cdpd,ln.dfp>lnbil1.cdpd do Runtime.setErrXBAD("LN",137,"DFP",ln.dfp,lnbil1.cdpd) quit:ER
		}

	/*
	DICO,DIRFRE,DIRND,DITGACN - Deferred Interest Resolution Option, Frequency,
	Next Date, & Target Account
	*/
	if 'ln.dico.isNull() do { quit:ER

		if 'ln.ditgacn.isNull() do { quit:ER
			
			type RecordLN ditgacn=Db.getRecord("LN","CID=:ln.ditgacn",1)
			
			// Capitalization Target Account Not Found
			if 'ditgacn.getMode() do Runtime.setErrXBAD("LN",145) quit:ER
 
			// Deferred Interest Target Account Closed
			if ditgacn.stat=4 do Runtime.setErrXBAD("LN",146) quit:ER
			}

		// Deferred Int Resolution Frequency Missing
		if ln.dico="FR",ln.dirfre.isNull() do Runtime.setErrXBAD("LN",147) quit:ER
		
		// Deferred Int Not Billed or Capitalized
		if ln.dico="BL",ln.dirnd<ln.bldt do Runtime.setErrXBAD("LN",148) quit:ER
 
		// Def Int Next Resolution Date Not Found
		if ln.dico="FR"!(ln.dico="BL"),ln.dirnd.isNull() do Runtime.setErrXBAD("LN",151) quit:ER
 
		// Def Int Next Res Date Precedes System Date
		if 'ln.dirnd.isNull(),ln.dirnd'>%SystemDate do Runtime.setErrXBAD("LN",150) quit:ER
		}

	/*
	 Only perform the following Loan Cycled Item checks during integrity checks 
	 since both files may not exist yet when inserting new loan record.
	*/
	if %ProcessMode=2 do { quit:ER

		// Disability Insurance Flag Inaccurate in Account
		if ln.dip,'Db.isDefined("LNCYCINS","ln.cid,'ID'") do Runtime.setErrXBAD("LN",95) quit:ER
		if 'ln.dip,Db.isDefined("LNCYCINS","ln.cid,'ID'") do Runtime.setErrXBAD("LN",95) quit:ER

		// Dealer Discount Flag Inaccurate in Account
		if ln.dlrp,'Db.isDefined("LNCYCDLD","ln.cid,'DLD'") do Runtime.setErrXBAD("LN",99) quit:ER
		if 'ln.dlrp,Db.isDefined("LNCYCDLD","ln.cid,'DLD'") do Runtime.setErrXBAD("LN",99) quit:ER

		// Accident/Health Insurance Flag Inaccurate in Account
		if ln.hip,'Db.isDefined("LNCYCINS","ln.cid,'IH'") do Runtime.setErrXBAD("LN",97) quit:ER
		if 'ln.hip,Db.isDefined("LNCYCINS","ln.cid,'IH'") do Runtime.setErrXBAD("LN",97) quit:ER

		// Life Insurance Flag Inaccurate in Account
		if ln.lip,'Db.isDefined("LNCYCINS","ln.cid,'IL'") do Runtime.setErrXBAD("LN",96) quit:ER
		if 'ln.lip,Db.isDefined("LNCYCINS","ln.cid,'IL'") do Runtime.setErrXBAD("LN",96) quit:ER

		// Misc Cycling Flag Inaccurate in Account
		if ln.mscp,'Db.isDefined("LNCYCMSC","ln.cid,'MSC'") do Runtime.setErrXBAD("LN",100) quit:ER
		if 'ln.mscp,Db.isDefined("LNCYCMSC","ln.cid,'MSC'") do Runtime.setErrXBAD("LN",100) quit:ER

		// Net deferred fee data does not exist
		if ln.ptsp,'Db.isDefined("LNCYCPTS","ln.cid,'PTS'") do Runtime.setErrXBAD("LN",36) quit:ER
		if 'ln.ptsp,Db.isDefined("LNCYCPTS","ln.cid,'PTS'") do Runtime.setErrXBAD("LN",36) quit:ER
		}
 
	// DIST1FRE - Distribution 1 Frequency
	if 'ln.dist1fre.isNull() do { quit:ER
	
		// Data required in data item ~p1
		if ln.pap.isNull() do Runtime.setErrMSG("LN",7531,"LN.PAP") quit:ER
		if ln.pas.isNull() do Runtime.setErrMSG("LN",7531,"LN.PAS") quit:ER
		if ln.pcm.isNull() do Runtime.setErrMSG("LN",7531,"LN.PCM") quit:ER
		if ln.pdag.isNull() do Runtime.setErrMSG("LN",7531,"LN.PDAG") quit:ER
		if ln.bloff'>0 do Runtime.setErrMSG("LN",7531,"LN.BLOFF") quit:ER
 
		// Payment elements may not be linked to master frequency of *
		if ln.dist1fre="*",("-"_ln.pmtdistf_"-")["-1-" do Runtime.setErrMSG("LN",1783) quit:ER
		}
 
	if ln.dist1fre="*" do { quit:ER

		// Invalid payment calc method for payment schedule processing
		if ln.pcm.isNull() do Runtime.setErrSTBLER("LN","PFRE*1") quit:ER
		if (PCMVAL.extract(3)'=3)!(PCMVAL.extract(2))!(PCMVAL.extract(5)) do Runtime.setErrSTBLER("LN","PFRE*1") quit:ER
 
		/*
		 First character of interest accrual method must not be "0" unless
		 interest calculation period frequency has a value.
		*/
		
		// Standard interest period method conflicts with payment schedule processing
		if '(ln.iacm.extract()),ln.icpf.isNull() do Runtime.setErrSTBLER("LN","PFRE*4") quit:ER

		// Pmt sched proc does not allow PIACM flag (Calculate P&I Based on IACM) to be Y
		if ln.piacm do Runtime.setErrSTBLER("LN","PFRE*5") quit:ER

		// Maturity date required for payment schedule processing
		if ln.mdt'>0 do Runtime.setErrSTBLER("LN","PFRE*2") quit:ER
		}

	// DIST2FRE,DIST2ND - Distribution 2 Frequency & Next Date
	if 'ln.dist2fre.isNull() do { quit:ER
 
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER
 
		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist2fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST2FRE") quit:ER
 
		// Requires "*" master payment frequency
		if ln.dist2fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER
 
		// ~P1 Must be a multiple of master payment frequency
		if ln.dist2fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist2fre) do Runtime.setErrMSG("LN",1795,"LN.DIST2FRE") quit:ER

		type Date NJD
		set NJD=""

		// Can't check date if in insert mode for * frequency since LNSP1 may not yet exist
		if %ProcessMode=2,ln.dist2fre="*" do { quit:NJD.isNull()
		 	type ResultSet rs=Db.select("PDD","LNPS1","CID=:ln.cid")
			if rs.isEmpty() quit
			if rs.next() set NJD=rs.getCol(1)
			}
 
		set NJD=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist2fre,2,ln.dist2nd,ln.bloff,%SystemDate)
 
		// Invalid Next 2nd Payment Date
		if 'NJD.isNull() do Runtime.setErrXBAD("LN",88,"DIST2ND",ln.dist2nd,NJD) quit:ER
		}
 
	// DIST3FRE,DIST3ND - Distribution 3 Frequency & Next Date
	if 'ln.dist3fre.isNull() do { quit:ER

		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER
 
		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist3fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST3FRE") quit:ER

		// Requires "*" master payment frequency
		if ln.dist3fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER
 
		// ~P1 Must be a multiple of master payment frequency
		if ln.dist3fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist3fre) do Runtime.setErrMSG("LN",1795,"LN.DIST3FRE") quit:ER

		// Can't check date if in insert mode for * frequency since LNSP1 may not yet exist
		if %ProcessMode=2,ln.dist3fre="*" do {

			type Date NJD
			set NJD=""
 
			// Check is not necessary if no elements are linked to this distribution
			if ln.pmtdistf'["3" quit

			type ResultSet rs=Db.select("PDD","LNPS1","CID=:ln.cid")
			if rs.isEmpty() quit
			if rs.next() set NJD=rs.getCol(1)
 
			if NJD.isNull() quit
			
			set NJD=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist3fre,3,ln.dist3nd,ln.bloff,%SystemDate)
			
			// Invalid Next 3rd Payment Date
			if 'NJD.isNull() do Runtime.setErrXBAD("LN",89,"DIST3ND",ln.dist3nd,NJD) quit:ER
			}
		}
 
	// DIST4FRE,DIST4ND - Distribution 4 Frequency & Next Date
	if 'ln.dist4fre.isNull() do { quit:ER

		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER
 
		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist4fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST4FRE") quit:ER
 
		// Requires "*" master payment frequency
		if ln.dist4fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER
 
		// ~P1 Must be a multiple of master payment frequency
		if ln.dist4fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist4fre) do Runtime.setErrMSG("LN",1795,"LN.DIST4FRE") quit:ER
 
		// Can't check date if in insert mode for * frequency since LNSP1 may not yet exist
		if %ProcessMode=2,ln.dist3fre="*" do {
 
	 		type Date NJD
			set NJD=""
 
			// Check is not necessary if no elements are linked to this distribution
			if ln.pmtdistf'["4" quit
			
			type ResultSet rs=Db.select("PDD","LNPS1","CID=:ln.cid")
			if rs.isEmpty() quit
			if rs.next() set NJD=rs.getCol(1)
 
			if NJD.isNull() quit
			
			set NJD=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist4fre,4,ln.dist4nd,ln.bloff,%SystemDate)
 
			// Invalid Next 4th Payment Date
			if 'NJD.isNull() do Runtime.setErrXBAD("LN",90,"DIST4ND",ln.dist4nd,NJD) quit:ER
			}
		}


	// Subsidized loans must have interest determined at billing
	if 'ln.subpln.isNull(),ln.idp do Runtime.setErrXBAD("LN",103) quit:ER

	// Subsidized loans cannot be add-on or discount loans
	if 'ln.subpln.isNull(),ln.iam do Runtime.setErrXBAD("LN",104) quit:ER

	// Invalid due payment amount
	if ln.dpmt>0,ln.tba'>0 do Runtime.setErrXBAD("LN",181,"DPMT",ln.dpmt,0) quit:ER
 
	// Open Account has date closed
	if 'ln.dtc.isNull(),ln.stat'=4 do Runtime.setErrXBAD("LN",122,"DTC",ln.dtc) quit:ER
 
	// Disbursement date ~p1 precedes date of note ~p2. Change one or both values.
	if %ProcessMode'=2,ln.dtnt>ln.odd do Runtime.setErrMSG("LN",1599,$$DAT^%ZM(ln.odd)_"~"_$$DAT^%ZM(ln.dtnt)) quit:ER
 
	// May not link a deposit account to a contra account
	if 'ln.fma.isNull(),ln.trb'=1 do Runtime.setErrSTBLER("LN","TRB1") quit:ER
 
	// Validate G/L Set Code
	do GLCHK^ACNFUNCS(ln.cls,ln.grp,ln.glsc) quit:ER
		
	// Data required in data item ~p1
	if ln.iacm.isNull(),ln.ircb>0 do Runtime.setErrMSG("LN",7531,"LN.IACM") quit:ER
 
	// Add-On Loan has Interest Determined at Payment
	if ln.iam,ln.idp do Runtime.setErrXBAD("LN",155) quit:ER
 
	// Flat rate int calc only valid with add-on/discount loans
	if ln.flat=1,ln.iam'>0 do Runtime.setErrXBAD("LN",517) quit:ER
 
	// An add-on or discount loan must have a maturity date
	if ln.mdt.isNull(),ln.iam>0 do Runtime.setErrXBAD("LN",518) quit:ER
 
	// IAM - Interest Amortization Method
	if ln.iam>0 do {
		// Odd Pmt Period may result in accelerated income recognition
		if $$EXT^UMDT(ln.trm,ln.dtnt,0,ln.busopt,ln.nbdc)'=ln.mdt do Runtime.setErrXBAD("LN",519) quit:ER

		type Date JD
		set JD=$$NJD^UFRE(ln.mdt,"-"_ln.dist1fre) quit:ER

		// Odd Pmt Period may result in accelerated income recognition
		if $$NJD^UFRE(JD,ln.dist1fre)'=ln.mdt do Runtime.setErrXBAD("LN",519) quit:ER
		}
	
	// Odd Pmt Period may result in accelerated income recognition
	if ln.iam>0,$$NJD^UFRE(ln.dtnt,ln.dist1fre)'=ln.dfp do Runtime.setErrXBAD("LN",519) quit:ER

	// Minimum loan payment term verification
	if 'ln.minptrm.isNull() do { quit:ER

		type Date ODT
		type String TRM

		set ODT=%SystemDate
		set TRM=ln.minptrm

		do TOP^UMDT	// Validate term format
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		
		// Loan Payment Term  outside valid range
		if (ln.mdt<$$MDT^PROCLN(ln.dtnt,ln.odd,ln.minptrm,,ln.busopt,ln.nbdc,ln.amodt,PCMVAL,ln.dist1fre)) do Runtime.setErrXBAD("LN","LNPTRM") quit:ER
		}

	// Maximum loan payment term verification
	if 'ln.maxptrm.isNull() do { quit:ER

		type Date ODT
		type String TRM

		set ODT=%SystemDate
		set TRM=ln.maxptrm

		do TOP^UMDT	// Validate term format
		
		// ~p1
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		
		// Loan Payment Term  outside valid range
		if (ln.mdt>$$MDT^PROCLN(ln.dtnt,ln.odd,ln.maxptrm,,ln.busopt,ln.nbdc,ln.amodt,PCMVAL,ln.dist1fre)) do Runtime.setErrXBAD("LN","LNPTRM") quit:ER
		}
   	
	// ICHND,INTOFF - Interest Change Next Date & Interest Review Offset Days
	if ln.ichnd do { quit:ER

		// Check against master frequency
		do ICHNDF^LNPPC3(ln.ichnd,ln.dist1nd,PCMVAL,ln.dist1fre,ln.intfre)
		
		// ~p1
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
 
		// Check date's validity on create
		if %ProcessMode'=2,'ln.intoff.isNull(),'ln.intfre.isNull(),ln.intoffdt<%SystemDate do { quit:ER
			// Next Int Change Offset Date in the Past
			do Runtime.setErrXBAD("LN",16,"INTOFFDT",ln.intoffdt) quit:ER
			}
 
		// No offset processing - next date can be today or greater
		if ln.intoff.isNull() do { quit
			// NEXT INTEREST CHANGE Date in the Past
			if ln.ichnd<%SystemDate do Runtime.setErrXBAD("LN",76,"ICHND",ln.ichnd) quit:ER
			}

		// NEXT INTEREST CHANGE Date in the Past
		if ln.ichnd'>%SystemDate do Runtime.setErrXBAD("LN",76,"ICHND",ln.ichnd) quit:ER

		// Offset periods may overlap.  Verify all offset dates in process.
		type Date XJD
		set XJD=ln.ichnd
		for  quit:(XJD-ln.intoff'<%SystemDate)  do { quit:ER

			type RecordLNVRCHG lnvrchg=Db.getRecord("LNVRCHG","ICHND=:XJD,CID=:ln.cid",1)

			// Int Chg Offset in Past, No New Rate Calculated
			if lnvrchg.rate do Runtime.setErrXBAD("LN",91) quit:ER
		
			set XJD=$$NJD^UFRE(XJD,ln.intfre) quit:ER
			}
		}
 
	// INCDR - Incremental Debit Amount
	if ln.incdr do { quit:ER

		type Number ODSITR,TYPE
		set ODSITR=prodctl.odsitr
		set TYPE=ln.type
		
		/*
		Incremental debit amount must be a factor of the incremental transfer
		amount of $<<$J(ODSITR,0,2)>> for type <<TYPE>>
		*/
		if ODSITR,ODSITR#ln.incdr do Runtime.setErrSTBLER("LN","ODSITR") quit:ER
		}

	// INDEX - Interest Index
	if 'ln.index.isNull() do { quit:ER
	
		// Interest Index reqs value in int change freq
		if ln.intfre.isNull() do Runtime.setErrXBAD("LN","INDEX13") quit:ER
 
		// Interest Index reqs value in Next Change Date
		if ln.ichnd.isNull() do Runtime.setErrXBAD("LN","INDEX12") quit:ER
 
		// Interest Index reqs value in Last Change Date
		if ln.ichld.isNull() do Runtime.setErrXBAD("LN","INDEX11") quit:ER
		}
 
	// Interest Offset Requires an Index
	if 'ln.intoff.isNull(),ln.index.isNull() do Runtime.setErrXBAD("LN","INDEX15") quit:ER

	// INTFRE - Interest Frequency
	if 'ln.intfre.isNull() do { quit:ER
	
		// Interest Change Frequency Requires an Index
		if ln.index.isNull() do Runtime.setErrXBAD("LN",8) quit:ER
 
		// Check against master frequency
		do INTFREF^LNPPC3(ln.intfre,ln.dist1nd,PCMVAL,ln.dist1fre)
		
		// ~p1
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		}
 
	// LNFEETA - Fee Target Account
	if 'ln.lnfeeta.isNull() do { quit:ER
 
		// Charge from account may not be the same account
		if ln.lnfeeta=ln.cid do Runtime.setErrMSG("LN",7752) quit:ER
 
 		type RecordACN acnfeeta=Db.getRecord("ACN","CID=:ln.lnfeeta",1)
 		
 		// Fee target account does not exist
 		if 'acnfeeta.getMode() do Runtime.setErrMSG("LN",429) quit:ER
 
		// Fee target account must be a deposit account
		if acnfeeta.cls'="D" do Runtime.setErrMSG("LN",724) quit:ER

		// Fee target account is closed
		if acnfeeta.stat=4 do Runtime.setErrMSG("LN",726) quit:ER
 
		// Fee target account's currency is not convertible
		if ln.crcd'=acnfeeta.crcd,'$$conv^CRCDUTL(acnfeeta.crcd) do Runtime.setErrMSG("LN",727) quit:ER
		}

	// Interest Paid for Next Year, But Loan is Current
	if (ln.intdef!ln.intdeftytd),($$DAT^%ZM(ln.dist1ld)=$$DAT^%ZM(%SystemDate)) do Runtime.setErrXBAD("LN",135) quit:ER
 
	// Indexed rate checks
	if 'ln.index.isNull() do { quit:ER

		if ln.intmx!ln.intmnic!ln.intmxic!ln.intmxiy quit
		if ln.intmn!ln.intmndc!ln.intmxdc!ln.intmxdy quit
		if ln.intfre.isNull() quit

		type Date TMPDT
		type Number BASEAMT,RATE,RRATE,SRATE,URATE
		type String PAR()
		
		set TMPDT=ln.ichld-ln.intoff
		if TMPDT<ln.dtnt set TMPDT=ln.dtnt		
		if %ProcessMode'=2,TMPDT<%SystemDate set TMPDT=ln.dtnt	// Use DTNT on insert
 
		// No Index Rate Entered for Date
		if 'TMPDT do Runtime.setErrXBAD("LN",114) quit:ER
		
		if 'ln.cntdr,(ln.odt=(%SystemDate-1)) set BASEAMT=+ln.amtreq
		else  set BASEAMT=+ln.balint
		
		set PAR("ROUND")=ln.rndmtd
		set PAR("INDEX")=ln.index
		set PAR("SPREAD")=ln.intspr
		set PAR("MATRIX")=ln.intmat
		do CTL^UINDX(.ln,TMPDT,BASEAMT,.PAR)

		// Interest Rate Inconsistent with Calculated Rate
		if +RATE'=+ln.irn do Runtime.setErrXBAD("LN",133,"IRN",ln.irn,RATE) quit:ER
		}
 
	// Collected Interest Exceeds Original Uncollected
	if ln.iam,ln.ipl>ln.iun do Runtime.setErrXBAD("LN",32,"IPL",ln.ipl,ln.iun) quit:ER
 
	// Interest reserve account number and interest reserve original must both be defined
	if (ln.ircid.isNull()),('ln.iramto.isNull()) do Runtime.setErrMSG("LN","4289") quit:ER
	if ('ln.ircid.isNull()),(ln.iramto.isNull()) do Runtime.setErrMSG("LN","4289") quit:ER
		
	if ('ln.ircid.isNull()) do { quit:ER
		/*
		 This section updates the Interest Reserve to Loan/Commitment 
		 cross-reference table with the new interest reserve account 
		 and loan account numbers as well as the interest reserve 
		 original amount.
		*/

		// Interest reserve account is not a valid PROFILE account
		if 'Db.isDefined("DEP","ln.ircid") do Runtime.setErrMSG("LN","4318") quit:ER

		if Db.isDefined("RELIR","ln.ircid,ln.cid") quit
 
		type RecordRELIR relir=Class.new("RecordRELIR")
				
		/*
		 Deposit posting programs will update the value of relir.iramtr
		 when funds are deposited to the account.
		*/

		set relir.ircid=ln.ircid
		set relir.lncid=ln.cid
		set relir.iramtr="0"
		set relir.lntype=ln.type
		set relir.lndes=prodctl.des
		
		do relir.save()
		}

	// Rounding Method is required with Interest Rounding Flag 
	if 'ln.irf.isNull(),ln.rndmtd.isNull() do Runtime.setErrMSG("LN",5099) quit:ER

	// Nominal Interest Rate Data required in data item ~p1
	if ln.irn.isNull(),ln.ircb>0 do Runtime.setErrMSG("LN",7531,"LN.IRN") quit:ER
 
	// Cannot enable Interest Reserve Processing if Commitment Billing is disabled
	if (ln.irp),('ln.cbf) do Runtime.setErrMSG("LN","4281") quit:ER

	// Minimum rate differential is not met
	if ln.minrate,(ln.irn<($$MINRATE^LNCDI(ln.cid)+ln.minrate)) do Runtime.setErrXBAD("LN","MINR") quit:ER
 
	// Incorrect G/L Set Code for Non-Accrual
	if ln.nai,ln.glsc'=prodctl.nagl do Runtime.setErrXBAD("LN",138,"GLSC",ln.glsc,prodctl.nagl) quit:ER

	// Maximum Aggregate Draw Amount may not be less than the Loan Amount
	if (ln.maxaggr),(ln.maxaggr<ln.crlmt) do Runtime.setErrMSG("LN","4279") quit:ER

	// MINDRR - Minimum Debit Amount
	if ln.mindr do { quit:ER
		
		type Number ODSMTR,TYPE
		set ODSMTR=prodctl.odsmtr
		set TYPE=ln.type
		
		/*
		Minimum debit amount cannot be greater than overdraft
		transfer minimum of $<<$J(ODSMTR,0,2)>> for type <<TYPE>>
		*/
		if ODSMTR,ln.mindr>ODSMTR set TYPE=ln.type do Runtime.setErrSTBLER("LN","ODSMTR") quit:ER
		}
 
	// MT900 Debit Threshold must be defined if Generate MT900="Y"
	if ln.mt900,ln.mt900thr.isNull(),cif.mt900thr.isNull() do Runtime.setErrMSG("LN",4077) quit:ER
 
	// MT910 Credit Threshold must be defined if Generate MT910="Y"
	if ln.mt910,ln.mt910thr.isNull(),cif.mt910thr.isNull() do Runtime.setErrMSG("LN",4078) quit:ER

	// ONP - Original Number of Payments
	if %ProcessMode=2 do { quit:ER

		// Commitment
		if ln.cpf quit
 
		// Non-amortizing
		if 'PCMVAL.extract() quit
		if 'ln.mdt!'ln.trm quit
 
		// Original # Pmts Inconsistent with Term of Loan
		if 'ln.onp do Runtime.setErrXBAD("LN",136,"ONP",0) quit:ER

		if ln.dist1fre.isNull() quit
 
		// Only matters for variable pmts
		if ln.pcfre.isNull()!'ln.pcoff quit
		
		type Number CNT
		if ln.dist1fre="*" set CNT=$$DATECNT^LNFUNCS(ln.cid)
		else  do { quit:ER
			type Date NJD
			type Number AF
			set NJD=$$NJD^UFRE(ln.dfp,"-"_ln.dist1fre,.AF) quit:ER
			set CNT=$$^SCARND(((ln.mdt-NJD)/365)*AF,0,,,0)
			}
		// Original # Pmts Inconsistent with Term of Loan
		if ln.onp'=CNT do Runtime.setErrXBAD("LN",136,"ONP",CNT) quit:ER
 
		// OriginAL # PMTS inconsistent with Amort Base # PMT
		if ln.onp>ln.ambas do Runtime.setErrXBAD("LN",168,"ONP",ln.onp,ln.ambas) quit:ER
		}
 
	// PCFRE - Payment Change Frequency
	if 'ln.pcfre.isNull() do { quit:ER
	
		// Int/Div offset req when pmt change freq contains a value
		if ln.intoff.isNull() do Runtime.setErrXBAD("LN","PCFRE") quit:ER
 
		// Only P&I loans may use payment change frequencies
		if 'PCMVAL.extract() do Runtime.setErrSTBLER("LN","NPINAPF") quit:ER

		// Pmt Calc Meth Indicates No Pmt Change Freq
		if PCMVAL.extract(3)=2 do Runtime.setErrXBAD("LN",126) quit:ER
 
 		type Date JD
 		type Number AF
 
		set JD=$$NJD^UFRE(%SystemDate,ln.pcfre,.AF) quit:ER

		// Payment change frequency cannot be daily
		if AF>364 do Runtime.setErrSTBLER("LN","PCFRED") quit:ER
 
		/*
		PCHM value of 1 should allow interest change and payment change to act
		independent of each other, so no check against the master frequency can
		be performed.
		*/
		if ln.pchm=1 quit
 
		// Check against master frequency
		do PCFREF^LNPPC3(ln.pcfre,ln.dist1nd,ln.dist1fre,ln.pchm,ln.intfre,ln.ichnd)
		
		// ~p1
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		}
 
	// PCHND,PCOFF - Payment Change Next Date & Payment Change Offset
	if ln.pchnd do { quit:ER

		if %ProcessMode'=2 do { quit:ER
			// Next P&I Change Offset Date in the Past
			if 'ln.pcoff.isNull(),'ln.pcfre.isNull(),ln.pcoffdt<%SystemDate do Runtime.setErrXBAD("LN",64) quit:ER
			}
 
		// NEXT PAYMENT CHANGE DATE in the Past
		if ln.pchnd'>%SystemDate do Runtime.setErrXBAD("LN",79) quit:ER
 
		// Only P&I loans may have payment change next dates
		if 'PCMVAL.extract() do Runtime.setErrSTBLER("LN","NPINAPD") quit:ER
 
		// Check against master frequency if schnd is not in the past
		if ln.schnd'<%SystemDate do { quit:ER
			do PCHNDF^LNPPC3(ln.pchnd,ln.dist1nd,ln.intfre,ln.pcfre,ln.ichnd,ln.dist1fre,ln.pchm)
			
			// ~p1
			if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
			}
 
		// Check that LNPTCHG is set up for correct dates
		type Date JD
		set JD=ln.pchnd
		for  quit:JD-ln.pcoff>%SystemDate  do { quit:ER
			// P&I Change Offset in Past, No New P&I Calculated
			if 'Db.isDefined("LNPTCHG","JD,ln.cid") do Runtime.setErrXBAD("LN",63) quit:ER
			set JD=$$NJD^UFRE(JD,ln.pcfre) quit:ER
			}
		}
 
	// PAYMENT CALC METHOD Requires Missing Payment Plan
	if ln.rpp.isNull(),PCMVAL.extract(3)=4!(PCMVAL.extract(3)=5) do Runtime.setErrXBAD("LN",52) quit:ER

	if PCMVAL.extract() do { quit:ER
	
		// Payment calc method requires term or maturity date
		if ln.mdt.isNull(),ln.trm.isNull() do Runtime.setErrSTBLER("LN","PCMTRM") quit:ER

		// Must have a rate or index
		if ln.irn.isNull(),ln.index.isNull() do Runtime.setErrSTBLER("LN","LNRTRQ") quit:ER
 
		if 'ln.onp!'ln.ambas do { quit:ER
			if prodctl.fbp=2,ln.dfp>%SystemDate quit
 
			// Payment Meth Requires "Number of Payments" Fields
		 	do Runtime.setErrXBAD("LN",9) quit:ER
			}
		}
 
	// Int Determ Point Invalid for Pmt Calc Method
	if ln.idp=1,(PCMVAL.extract(2)>0)!(PCMVAL.extract(3)>2) do Runtime.setErrXBAD("LN",127) quit:ER 
	
	// PFLG - Participation Account Flag
	do { quit:ER

		type Number PSEQ

		type ResultSet rs=Db.select("PSEQ","LNLS6","CID=:ln.cid")
		if rs.isEmpty() quit
		if rs.next() set PSEQ=rs.getCol(1)
		
		// Participation Flag Not Supported by Part File
		if ln.pflg,PSEQ.isNull() do Runtime.setErrXBAD("LN",29) quit:ER
		if 'ln.pflg,'PSEQ.isNull() do Runtime.setErrXBAD("LN",29) quit:ER
		}
 
	// PMTMIN - Minimum payment amount
	if ln.pmtmin do { quit:ER
		type Boolean ERR
		type Number I
		type String PMTDIST

		set ERR=1
		set PMTDIST=ln.pmtdist
		
		for I=1:1:PMTDIST.length("-") if PMTDIST.piece("-",I)="P" set ERR=0 quit
 
		// Minimum payment amount requires principal in string
		if ERR do Runtime.setErrSTBLER("LN","PMTMIN") quit:ER
		}
 
	// POPT,LCAD - Late Charge Calculation Method & Action Date
	if 'ln.popt.isNull(),'ln.dist1fre.isNull() do { quit:ER

		// If Late Charges driven by notices, don't worry about LCAD
		if ln.lchgnoto=1 quit

		type Date LCAD,LCEFD
		type Number I

		type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:ln.cid AND CBCD=:ln.bldt","SCHSEQ DESC")
		if rs.isEmpty() quit
		if rs.next() set LCEFD=rs.getCol(1)
 
 		if LCEFD.isNull() quit
		
		set LCAD = LCEFD
		if ln.pmtgrc["D" set LCAD = LCAD + ln.pmtgrc
		else  if ln.pmtgrc["P" do { quit:ER
			for I = 1:1:ln.pmtgrc.piece("P",1) set LCAD = $$NJD^UFRE(LCAD,ln.dist1fre) quit:ER
			set LCAD = LCAD - ln.pmtgrc.piece("-",2)
			}

		if ln.lcbo="N" for LCAD=LCAD:1 quit:$$BD^UNBD(LCAD,CUVAR.LCNBDC)
		if 'ln.bseq!(ln.bldt+1=ln.odd) quit
		
		// Late Charge Action Date Invalid
		if LCAD'=ln.lcad do Runtime.setErrXBAD("LN",124,"LCAD",ln.lcad,LCAD) quit:ER
		
		// Late Charge Effective Date Invalid
		if LCEFD'=ln.lcefd do Runtime.setErrXBAD("LN",129,"LCEFD",ln.lcefd,LCEFD) quit:ER
		}
	
	// Daily Late Charge Flag On, Day-End File Not Set
	if %ProcessMode=2,ln.dlcaf,'Db.isDefined("DAYENDLCHG","%SystemDate,ln.cid") do Runtime.setErrXBAD("LN",132) quit:ER
 
	/*
	This section checks the validity of LN to LNBIL0
	Only check during verify mode since LNBIL0 may not exist yet during insert
	Note:  PPDCAT may look like I-v-ESC3-v-P-v
	       Bill file payment element order would be -
		|I...|ESC1...|ESC2...|ESC3...|P...
	*/
	if %ProcessMode=2 do { quit:ER
	
		type Number I,INTFRE,J,K,NUM,PESEQ,PRINFRE
		type String ELEMENT,PE(),PPDCAT()
	
		// First get payment elements from bill file (LNBIL0) in order
		type ResultSet rs=Db.select("PE01,PE02,PE03,PE04,PE05,PE06,PE07,PE08,PE09,PE10,PE11,PE12,PE13,PE14,PE15,PE16,PE17,PE18,PE19,PE20","LNBIL0","CID=:ln.cid")
		if rs.isEmpty() quit
		
		if rs.next() for I=1:1:20 do {
			set PE(I)=rs.getCol(I).piece("#",1)
			if PE(I)="I" set INTFRE=+rs.getCol(I).piece("#",4)
			if PE(I)="P" set PRINFRE=+rs.getCol(I).piece("#",4)
			}
		
		// Get valid payment due categories
		set PPDCAT(1)=ln.ppdcat1
		set PPDCAT(2)=ln.ppdcat2
		set PPDCAT(3)=ln.ppdcat3
		set PPDCAT(4)=ln.ppdcat4
		set PPDCAT(5)=ln.ppdcat5
		set PPDCAT(6)=ln.ppdcat6
		set PPDCAT(7)=ln.ppdcat7
		set PPDCAT(8)=ln.ppdcat8
		set PPDCAT(9)=ln.ppdcat9
		set PPDCAT(10)=ln.ppdcat10
		
		// Check validity against payment element order
		for I=1:1:ln.npc do { quit:ER
		
			set PPDCAT="-"_PPDCAT(I)_"-"
			set PESEQ=0			// Payment element sequence
			for J=2:2 set ELEMENT=PPDCAT.piece("-",J) quit:ELEMENT.isNull()  do { quit:ER
				set NUM=0
				// If escrow, get number
				if $$FEEPLN^LNU(ELEMENT).isNull() do {
					for K=ELEMENT.length():-1:1 quit:ELEMENT.extract(K)'?1N
					set NUM=+ELEMENT.extract(K+1,99)
					}
				if 'NUM set NUM=1
				set PESEQ=PESEQ+NUM
				
				// Account payment string inconsistent with bills
				if PE(PESEQ)'=ELEMENT do Runtime.setErrXBAD("LN",37) quit:ER
				}
			}
				
		// Check distributions if P&I loan
		if PCMVAL.extract(),INTFRE.exists(),PRINFRE.exists(),INTFRE'=PRINFRE do { quit:ER
			
			type String DISTFRE()
			set DISTFRE(1)=ln.dist1fre
			set DISTFRE(2)=ln.dist2fre
			set DISTFRE(3)=ln.dist3fre
			set DISTFRE(4)=ln.dist4fre
 
			// Fatal Set-Up (1) Diff P&I Dates (2) Precalculated
			if DISTFRE(INTFRE)'=DISTFRE(PRINFRE) do Runtime.setErrXBAD("LN",39) quit:ER
			}
		}

	// Principal Amt Target Acct & Principal Amt at Payoff must both be defined
	if ln.pramt.isNull(),'ln.pramtcid.isNull() do Runtime.setErrMSG("LN","4291") quit:ER
 	if 'ln.pramt.isNull(),ln.pramtcid.isNull() do Runtime.setErrMSG("LN","4291") quit:ER

	// Percent at Payoff Target Acct & Percent at Payoff must both be defined
	if ln.prcntap.isNull(),'ln.prcntcid.isNull() do Runtime.setErrMSG("LN","4292") quit:ER
 	if 'ln.prcntap.isNull(),ln.prcntcid.isNull() do Runtime.setErrMSG("LN","4292") quit:ER		

	// PTRM - Payment Term
	if 'ln.ptrm.isNull() do { quit:ER
	
		type Date ODT
		type String TRM

		set ODT=%SystemDate
		set TRM=ln.ptrm

		do TOP^UMDT		// Validate term format
		
		// ~p1
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		}
 
	// RAND - Re-amortization Next Date
	if ln.rand do { quit:ER
	
		// Only P&I loans may have reamortization next dates
		if 'PCMVAL.extract() do Runtime.setErrSTBLER("LN","NPINARD") quit:ER
 
		// NEXT RE-AMORTIZATION DATE in the Past
		if ln.rand<%SystemDate do Runtime.setErrXBAD("LN",78) quit:ER
 
		// Check against master frequency
		do PCFREF^LNPPC3(ln.rand,ln.dist1nd,ln.intfre,ln.rafre,ln.ichnd,ln.dist1fre,ln.schld)
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		}
 
	// RAFRE - Re-amortization Frequency
	if 'ln.rafre.isNull() do { quit:ER
	
		// Only P&I loans may use reamortization frequencies
		if 'PCMVAL.extract() do Runtime.setErrSTBLER("LN","NPINARD") quit:ER
 
		// Check against master frequency
		do RAFREF^LNPPC3(ln.rafre,ln.dist1nd,ln.dist1fre,ln.pcfre,ln.pchnd)
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		}
 
	// RENCD,TRACN - Renewal Code and Maturity Transfer Account
	if 'ln.tracn.isNull() do { quit:ER
	
		// Transfer account not allowed for this maturity option.
		if ln.rencd=0!(ln.rencd=4) do Runtime.setErrXBAD("LN","MATOPT") quit:ER

		if ln.rencd'="1C",ln.rencd'="2C",ln.rencd'="3C" quit
		
		// Transfer account must be a loan account
		if 'Db.isDefined("LN","ln.tracn") do Runtime.setErrSTBLER("LN","TRACN2") quit:ER
		}
 
	if ln.tracn.isNull() do { quit:ER
	
		// Maturity Option Requires Transfer Account
		if ln.rencd=1!(ln.rencd=2)!(ln.rencd=3) do Runtime.setErrXBAD("LN",110) quit:ER
 
		// Fixed Bullet Product Option Requires Transfer Acct
		if prodctl.fbp=2 do Runtime.setErrXBAD("LN",154) quit:ER
		}
	else  if prodctl.fbp=2 do { quit:ER
 
		// Maturity Option Requires Transfer Account
		if 'ln.ccl do Runtime.setErrXBAD("LN",110) quit:ER
		
		type RecordLN tracn=Db.getRecord("LN","CID=:ln.tracn")

		// Transfer Account Requires Same Payment Frequency
		if ln.dist1fre'=tracn.dist1fre do Runtime.setErrXBAD("LN",33) quit:ER
 
		// Transfer Account Requires Same Pmt Calc Method
		if ln.pcm'=tracn.pcm do Runtime.setErrXBAD("LN",34) quit:ER
 
		// Pmt dates must start on or after variable loan pmts
		if ln.dfp<tracn.dfp do Runtime.setErrXBAD("LN",514) quit:ER
		}
 
	// RND,ROPT - Escrow Element to Round, Payment Rounding Option
	if %ProcessMode=2,ln.ropt'>1 do { quit:ER

		type Number RNDCID,RNDELEM
		type String PE
		
		set RNDCID=""
		set RNDELEM=""
		set PE=""
		for  set PE=PMTELEM(PE).order() quit:PE.isNull()  do {
			if ln.rnd=PMTELEM(PE).piece("#",1) do {
				set RNDELEM=PMTELEM(PE).piece("#",1)	// Element to round
				set RNDCID=PMTELEM(PE).piece("#",2)		// Escrow account number
				}
			}

		// No escrow account
		if RNDCID.isNull() quit
 
		// Escrow to round requires rounding option of 1
		if 'ln.rnd.isNull(),ln.ropt'=1 do Runtime.setErrXBAD("LN",533) quit:ER
		
		// Loan Rounding Option Set, Escrow Unspecified
		if ln.rnd.isNull() do Runtime.setErrXBAD("LN",112) quit:ER
 
		// "Escrow to Round" Account Invalid
		if RNDELEM.isNull() do Runtime.setErrXBAD("LN",113) quit:ER
		
		type RecordDEP deprnd=Db.getRecord("DEP","CID=:RNDCID",1)
		
		// "Escrow to Round" Account Invalid (Account does not exist)
		if 'deprnd.getMode() do Runtime.setErrXBAD("LN",113) quit:ER

		// "Escrow to Round" Account Invalid (Account closed)
		if deprnd.stat=4 do Runtime.setErrXBAD("LN",113) quit:ER
		
		// "Escrow to Round" Account Invalid (Account is self pay)
		if deprnd.espf=1 do Runtime.setErrXBAD("LN",113) quit:ER
		}

	// Interest Rounding Flag is required with Rounding Method
	if 'ln.rndmtd.isNull(),ln.irf.isNull() do Runtime.setErrMSG("LN",5100) quit:ER

	// SCH - Rate Schedule Verification
	if 'ln.sch.isNull() do { quit:ER
		
		type String X
		
		set X=ln.rsintspr
		do SPRPP^UINDX if ER do Runtime.setErrSTBLER("LN",ET) quit:ER

		set X=ln.rsrndmtd
		do RNDPP^UINDX if ER do Runtime.setErrSTBLER("LN",ET) quit:ER
		}
	
	type Date PDD	// PDD is used in the next several sections
	set PDD=""
	
	// Get last date if DIST1FRE="*" for use in this section
	if ln.dist1fre="*" do { quit:ER
		type ResultSet rs=Db.select("PDD","LNPS1","CID=:ln.cid","PDD DESC")
		if rs.isEmpty() quit
		if rs.next() set PDD=rs.getCol(1)
		}
 
	// Next scheduled payment date is invalid
	if 'ln.schnd.isNull(),ln.schnd<%SystemDate do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd) quit:ER

	// Check that SCHND is correct relative to DIST1FRE
	if 'ln.schnd.isNull(),'ln.dist1fre.isNull() do { quit:ER

		if ln.dist1fre="*" quit:'(%ProcessMode=2)!(PDD.isNull())
		
		if %ProcessMode=2 do { quit:ER
			type Date CDPD
		
			// Get date from first bill with due date in future
			type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:ln.cid AND CDPD>:%SystemDate","SCHSEQ")
			if rs.isEmpty() quit
			if rs.next() set CDPD=rs.getCol(1)
 
			// Next scheduled payment date is invalid
			if 'CDPD.isNull(),CDPD'=ln.schnd do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd,CDPD) quit:ER
			}
		
		if 'Db.isDefined("USRFRE","UFRE=:ln.dist1fre"),ln.dist1fre["DP"!(ln.dist1fre["DN")!(ln.dist1fre["WP")!(ln.dist1fre["WN") quit
			
		type Date TMPDT

		// Bump once
		set TMPDT=$$NJD^UFRE(ln.schnd,ln.dist1fre) quit:ER
		
		// Then reverse
		set TMPDT=$$NJD^UFRE(TMPDT,"-"_ln.dist1fre) quit:ER
		
		// Next scheduled payment date is invalid
		if ln.schnd'=TMPDT do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd,TMPDT) quit:ER
		}

	// Scheduled disbursement target account
	if ln.sdta do { quit:ER

		// Target account must be different from source account
		if ln.sdta=ln.cid do Runtime.setErrMSG("LN",2599) quit:ER

		type RecordACN acnsdta=Db.getRecord("ACN","CID=:ln.sdta")
		if acnsdta.crcd.isNull() set acnsdta.crcd=%SystemCurrency

		// Currency code of target account must be consistent with source account
		if ln.crcd'=acnsdta.crcd do Runtime.setErrMSG("LN",655) quit:ER
 
		// Disbursement Target account not active
		if acnsdta.stat=4 do Runtime.setErrXBAD("LN",160) quit:ER
		}	

	// TRM - Account Term
	if 'ln.trm.isNull() do { quit:ER
		type Date ODT
		type String TRM

		set ODT=%SystemDate
		set TRM=ln.trm

		do TOP^UMDT		// Validate term format
		
		// ~p1
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
		}
 
	// Check BNDT and payment record
	do { quit:ER

		if ln.dist1fre.isNull() quit
		if ln.dist1fre="*",ln.bndt.isNull(),PDD-ln.bloff<%SystemDate quit
		
		if ln.dist1fre="*",PDD.isNull(),%ProcessMode=0 quit
		
		type Date BNDT
		
		// Check BNDT based on SCHND
		if ln.bloff="1P" do {
			set BNDT=$S(ln.schld<%SystemDate:ln.schnd,1:ln.schld)
			if BNDT=ln.odd,ln.dist1ld>ln.odd,ln.dfp=ln.schnd set BNDT=ln.dist1ld
			}
		else  do { quit:ER
			type Date NJD
			set NJD=ln.schnd
			for  set BNDT=NJD-ln.bloff quit:BNDT'<%SystemDate  set NJD=$$NJD^UFRE(NJD,ln.dist1fre) quit:ER
			}

		// Check next bill date for possible errors
		if ln.bndt'=BNDT do Runtime.setErrXBAD("LN",46,"BNDT",ln.bndt,BNDT) quit:ER
 
 		type Date TMPDT
 
		// Make sure that payment record exists if within offset period
		if ln.bloff'="1P" set TMPDT=ln.schnd-ln.bloff
		else  set TMPDT=ln.schld

		if TMPDT'<%SystemDate quit

		type Number SCHSEQ
		set SCHSEQ=""

		type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:ln.cid AND CBCD=:TMPDT","SCHSEQ DESC")
		if rs.isEmpty() quit
		if rs.next() set SCHSEQ=rs.getCol(1)
 
 		// Internal bill does not exist for due date
		if SCHSEQ.isNull() do Runtime.setErrXBAD("LN",125,"SCHND",TMPDT) quit:ER
		}

	// Account Status Flag of 1 with Ledger Balance
	if ln.stat=1,ln.bal>0 do Runtime.setErrXBAD("LN",130,"STAT",ln.bal,0) quit:ER

	// Not Closed
	if ln.stat'=4,ln.revf'=1 do { quit:ER
		if ln.bal!'ln.cntdr!ln.maxdrct!(ln.stat=1) quit
		if 'ln.stat,ln.idpf quit
 
		// Zero Balance Account, Account Status Not = 4
		do Runtime.setErrXBAD("LN",1,"STAT",ln.stat,4) quit:ER
		}
 
 	// Zero Balance Account, Account Status Not = 4
	if ln.stat'=4,ln.bal=0,ln.revf'=1,ln.odt'=%SystemDate,ln.maxdrct'>ln.cntdr do Runtime.setErrXBAD("LN",1,"STAT",ln.stat,4) quit:ER
 
	// TEB - Total Escrow Balance
	do { quit:ER

		type Number ESCACR,ESCBAL,ESCCID
		type String PE

		set PE=""
		set ESCACR=0
		set ESCBAL=0
		for  set PE=PMTELEM(PE).order() quit:PE.isNull()  set ESCCID=PMTELEM(PE).piece("#",2) if ESCCID do { quit:ER
			type RecordDEP escdep=Db.getRecord("DEP","CID=:ESCCID")
			set ESCBAL=ESCBAL+escdep.bal
			set ESCACR=ESCACR+escdep.acr
			}

		// TOTAL ESCROW BALANCE Not Supported by Accounts
		if +ln.teb'=ESCBAL do Runtime.setErrXBAD("LN",47,"TEB",ln.teb,ESCBAL) quit:ER
 
		// Account Status Flag of 1 with No Escrow Balance
		if ln.stat=1,'ESCBAL,'ESCACR do Runtime.setErrXBAD("LN",131) quit:ER
		}
 
	// Teaser Expiration Date Exists without Teaser Rate
	if ln.trexd>%SystemDate,ln.trate.isNull() do Runtime.setErrXBAD("LN",15) quit:ER
 
	// Teaser Rate Exists without Expiration Date
	if 'ln.trate.isNull(),ln.trexd.isNull() do Runtime.setErrXBAD("LN",102) quit:ER
 
	// Unadvanced Balance Check
	if %ProcessMode=2 do { quit:ER

		// If commitment, verify available credit against linked sub-loans/commitments
		if ln.cpf do { quit:ER

			type Number AVL
			set AVL=0

			type DbSet ds=Db.selectDbSet("LN","CCL=:ln.cid")
			
			while ds.next() do {
				type Number AVLX
				
				type RecordLN subln=ds.getRecord()
				set AVLX=subln.crlmt

				// Revolving Committment/Non-Revolving Sub-loan
				if ln.revf,'subln.revf do {

					type Number PRNRPD
					set PRNRPD=subln.bal

					if subln.aruf set PRNRPD=PRNRPD-subln.udbal
					if subln.tdr>subln.crlmt set PRNRPD=subln.crlmt-PRNRPD
					else  set PRNRPD=subln.tdr-PRNRPD
					
					if PRNRPD<0 set PRNRPD=0
					set AVLX=AVLX-PRNRPD					
					}
				if 'subln.trb set AVLX=-AVLX
				set AVL=AVL+AVLX
				}
 
			// Available Credit Inconsistent with Linked Loans
			if ln.crlmt-AVL-ln.udbal do Runtime.setErrXBAD("LN",123,"UDBAL",ln.udbal,ln.udbal-AVL) quit:ER
			}
 
		else  do { quit:ER
			/*
			Calculate UDBAL for non-revolving loans and for revolving, non-ARUF
			loans.  Currently no way to calculate UDBAL for revolving, ARUF loans.
			*/

			type Number UDBALCK

			if 'ln.revf set UDBALCK=ln.crlmt-ln.tdr
			else  if 'ln.aruf set UDBALCK=ln.crlmt-ln.bal
			else  set UDBALCK=ln.udbal

			// UNDISBURSED BALANCE Not Supported by Account
			if +ln.udbal'=+UDBALCK do Runtime.setErrXBAD("LN",53,"UDBAL",ln.udbal,UDBALCK) quit:ER
			}
		}
 
	// Relationship code Integrity check
	if %ProcessMode=2 do { quit:ER
	
		type Number ROLE
		type String ROLES()

		type ResultSet rs=Db.select("REQ,MAXROL,ROLE","RELCODE","REL=:ln.acnrelc") quit:ER
		if rs.isEmpty() quit
		while rs.next() set ROLES(rs.getCol("ROLE"))=rs.getCol("REQ")_"|"_rs.getCol("MAXROL")

		type ResultSet relrs=Db.select("ROLE","RELCIF","CID=:ln.cid")
		
		// Invalid CIF/Account Linkage
		if relrs.isEmpty() do Runtime.setErrXBAD("LN","INVLDLNK") quit:ER
		while relrs.next() do {
			set ROLE=relrs.getCol("ROLE")
			set ROLES(ROLE).piece("|",1)=ROLES(ROLE).get().piece("|",1)-1		// Min
			set ROLES(ROLE).piece("|",2)=ROLES(ROLE).get().piece("|",2)-1		// Max
			}
 
		set ROLE=""
		for  set ROLE=ROLES(ROLE).order() quit:ROLE.isNull()  do { quit:ER
			// Below Minimum Number of customers for role code ~p1
			if ROLES(ROLE).piece("|",1)>0 do Runtime.setErrXBAD("LN","RCMIN",ROLE) quit:ER
 
			// Maximum Number of customers for role code ~p1 exceeded
			if ROLES(ROLE).piece("|",2)<0 do Runtime.setErrXBAD("LN","RCMAX",ROLE) quit:ER
			}
		}

	if CUVAR.limpro=1,%ProcessMode'=2 do INIT^PROCLIM quit:ER

	// Maturity Date Required for Recalculation of Final Payment
	if ln.rfp,'ln.mdt do Runtime.setErrMSG("LN",4526) quit:ER

	// Date of Death Check
	if 'cif.dod.isNull() do { quit:ER
		// Remove the CIFDOD XBAD if it already exists and then re-add
		// it.  This is done to prevent the XBAD from showing up twice.
		do Runtime.delErrXBAD("LN","CIFDOD") quit:ER
		
		// An account owner is deceased
		do Runtime.setErrXBAD("LN","CIFDOD") quit:ER
		}
		
	// Date of Disability Check
	if 'cif.dodsabl.isNull() do { quit:ER
		// Remove the CIFDODSABL XBAD if it already exists and then re-add
		// it.  This is done to prevent the XBAD from showing up twice.
		do Runtime.delErrXBAD("LN","CIFDODSABL") quit:ER
		
		// An account owner is disabled
		do Runtime.setErrXBAD("LN","CIFDODSABL") quit:ER
		}

	// Commitment cannot accrue interest
	if ln.cpf=1,ln.irn>0 do Runtime.setErrXBAD("LN",3004) quit:ER

	// Nominal Interest Rate Checks
	do { quit:ER
		type Number CEILING,FLOOR
		set FLOOR=prodctl.intf
		set CEILING=prodctl.intc
		
		if CEILING.isNull() set CEILING=99.999
 
		// INTEREST RATE Outside Valid Range
		if ln.irn>CEILING!(ln.irn<FLOOR) do Runtime.setErrXBAD("LN",117) quit:ER

 		// Invalid Int/Div Rate - Lower than Minimu
		if ('ln.intmn.isNull()),(ln.irn<ln.intmn) do Runtime.setErrXBAD("LN","INVINTRTL") quit:ER
		
		// Invalid Int/Div Rate - Higher than Maximum
		if (ln.intmx),(ln.irn>ln.intmx) do Runtime.setErrXBAD("LN","INVINTRTH") quit:ER
		}
		
	// Debit/Credit Bal Thresholds cannot be defined for rev accts
	if ln.revf,(ln.dbt!ln.cbt) do Runtime.setErrXBAD("LN",528) quit:ER

	// Interest Resolution option required
	if (ln.icap),'(ln.iropt) do Runtime.setErrXBAD("LN","IROPTREQ") quit:ER
 
	// Interest Resolution option cannot be 1 if ICAP is "yes"
	if (ln.icap),(ln.iropt=1) do Runtime.setErrXBAD("LN","RESOPT") quit:ER
 
	// Defer Excess Accrual must be set when Bill Cap Int as Prin
   	if (ln.bcapint),'(ln.dxsi) do Runtime.setErrXBAD("LN","BCAPINT") quit:ER

	// Interest Determination Point Check
	if ln.idp=1 do { quit:ER
		type Number PRIO
		type RecordUTBLICPA utblicpa=Db.getRecord("UTBLICPA","KEY=:ln.icpa")
		set PRIO=utblicpa.prio
		
		// Interest balance option requires interest calc at billing
		if PRIO.extract(1)!PRIO.extract(2)!PRIO.extract(7)!PRIO.extract(8)!PRIO.extract(11) do Runtime.setErrXBAD("LN",521) quit:ER
		}

	// Pmt/Mat Recalculation Opt can only be used with P&I loans
	if 'PCMVAL.extract(),ln.pmro>0 do Runtime.setErrXBAD("LN",236) quit:ER
	
	// Number Days to Project for Activity Report.
	if ln.genprjrep=1,ln.numdtp.isNull() do Runtime.setErrXBAD("LN",238) quit:ER

	// If SGNCRD>0 AND PSGNCRDR'=1 track this account in XSGNCRD
	if '%ProcessMode,ln.sgncrd>0,ln.psgncrdr'=1 do {
		type RecordXSGNCRD xsgncrd=Class.new("RecordXSGNCRD")
		set xsgncrd.sjd=%SystemDate
		set xsgncrd.sgncrd=ln.sgncrd
		set xsgncrd.osgncrdc=+ln.osgncrdc
		set xsgncrd.psgncrdr=+ln.psgncrdr
		set xsgncrd.cid=ln.cid
		do xsgncrd.bypassSave()
		}

	/********************************************************************
	The following section should NOT BE EXECUTED if the trigger is being
	executed for integrity checking ONLY
	********************************************************************/
 
	if %ProcessMode=2 quit
 
	// Create LNBIL0 based on PMTDIST and PMTDISTF
	// Escrow CID will get added when escrow account is created
	if 'ln.pmtdist.isNull() do {

		type Number DISTNO,I
		type String ELEM

		type RecordLNBIL0 lnbil0=Class.new("RecordLNBIL0")
		set lnbil0.cid=ln.cid
		for I=1:1 set ELEM=ln.pmtdist.piece("-",I) quit:ELEM.isNull()  do {
 
			set DISTNO=ln.pmtdistf.piece("-",I) if DISTNO=1 set DISTNO=""

			if I=1 set lnbil0.PE01=ELEM_"###"_DISTNO
			if I=2 set lnbil0.PE02=ELEM_"###"_DISTNO
			if I=3 set lnbil0.PE03=ELEM_"###"_DISTNO
			if I=4 set lnbil0.PE04=ELEM_"###"_DISTNO
			if I=5 set lnbil0.PE05=ELEM_"###"_DISTNO
			if I=6 set lnbil0.PE06=ELEM_"###"_DISTNO
			if I=7 set lnbil0.PE07=ELEM_"###"_DISTNO
			if I=8 set lnbil0.PE08=ELEM_"###"_DISTNO
			if I=9 set lnbil0.PE09=ELEM_"###"_DISTNO
			if I=10 set lnbil0.PE10=ELEM_"###"_DISTNO
			if I=11 set lnbil0.PE11=ELEM_"###"_DISTNO
			if I=12 set lnbil0.PE12=ELEM_"###"_DISTNO
			if I=13 set lnbil0.PE13=ELEM_"###"_DISTNO
			if I=14 set lnbil0.PE14=ELEM_"###"_DISTNO
			if I=15 set lnbil0.PE15=ELEM_"###"_DISTNO
			if I=16 set lnbil0.PE16=ELEM_"###"_DISTNO
			if I=17 set lnbil0.PE17=ELEM_"###"_DISTNO
			if I=18 set lnbil0.PE18=ELEM_"###"_DISTNO
			if I=19 set lnbil0.PE19=ELEM_"###"_DISTNO
			if I=20 set lnbil0.PE20=ELEM_"###"_DISTNO
			}

		do lnbil0.save()
		}
 
	// If using undisbursed processing, post transactions to update UDBAL
	if ln.aruf>0 do { quit:ER

		type Date %EffectiveDate
		type Number BRCD,TAMT
		type String %EXT,TCMT

		set TAMT=ln.crlmt
		set EFD=ln.dtnt
		set BRCD=ln.boo
		set TCMT=$$^MSG(3956)	// New Account
		set %EXT=1

		/*
		 Need to reset record mode to 1 here because
		 posting of transactions will update the ln 
		 record and the record mode at that point
		 needs to be 1 (Modify) since the record has
		 already been added to the database.
		*/
		do ln.setMode(1)

		do TTX^LNCL1(.ln) quit:ER
		}
 
	// Set up Master Commitment listing
	if ln.ccl.isNull(),ln.cpf do { quit:ER
		
		type ResultSet rs=Db.select("ACN","RELCIF","CID=:ln.cid") quit:ER
		if rs.isEmpty() quit
		
		while rs.next() do {
			type RecordLNMCOM1 lnmcom1=Class.new("RecordLNMCOM1")
			set lnmcom1.acn=rs.getCol(1)
			set lnmcom1.cid=ln.cid
			do lnmcom1.save()
			}
		}
 
	// COLCD - Primary Collateral Code Check lending limits
	if 'ln.colcd.isNull() do { quit:ER

		if ln.off.isNull() quit
		
		type Boolean SEC
		type Number AMT,LIM
		
		type RecordUTBLCOLCD colcd=Db.getRecord("UTBLCOLCD","GRP=:ln.grp,KEY=:ln.colcd",1)
		type RecordUTBLOFILIM ofilim=Db.getRecord("UTBLOFILIM","OFFC=:ln.off,KEY=:ln.grp",1)
		
		if colcd.sec set LIM=ofilim.unslim
		else  set LIM=ofilim.seclim
		
		if LIM'>0 quit
				
		set AMT=ln.amtreq
		if ln.crcd'=%SystemCurrency do CAMT^CRCDUTL(%SystemCurrency,ln.crcd,.AMT)
 
		// Amount requested exceeds officer's lending limit ($<<LIM>>)
		if AMT>LIM do Runtime.setErrSTBLER("LN","LNLIM") quit:ER
		}
 
	// CNVDT - Conversion Date
	if 'ln.cnvdt.isNull() do { quit:ER
	
		type Date CD,CNDT
		type Number COFF
		type String CAL,CFREQ
	
		set CD=ln.cnvdt
		set COFF=ln.cnoff
		set CFREQ=ln.cfreq
		set CNDT=CD-COFF
		set CAL=ln.nbdc
		if CAL.isNull() set CAL="IBS"
		
		// Conversion date must be a business date
		if '$$BD^UNBD(CD,CAL) do Runtime.setErrXBAD("LN","CDTBUS") quit
		
		// Conversion Notification Date must be a business date
		if CFREQ'["A",'$$BD^UNBD(CNDT,CAL) do Runtime.setErrXBAD("LN","CNOTBD") quit
		
		// Conversion date requires conversion notification offset
		if COFF.isNull() do Runtime.setErrXBAD("LN","CDROFF") quit
		
		// Conversion date must be after the system date
		if CD'>%SystemDate do Runtime.setErrXBAD("LN","CDTASD") quit
		
		// Conversion Notification Date must be after system date
		if CNDT'>%SystemDate do Runtime.setErrXBAD("LN","CNTASD") quit
		}
 
	// RDT - Return Date
	if 'ln.rdt.isNull() do { quit:ER

		// Return date must be a business date
		if '$$BD^UNBD(ln.rdt,ln.nbdc) do Runtime.setErrXBAD("LN","RDTBUS") quit
		
		// Return date must be after the system date
		if ln.rdt'>%SystemDate do Runtime.setErrXBAD("LN","RDTASD") quit
		
		// Return date requires return notification offset
		if ln.rnoff.isNull() do Runtime.setErrXBAD("LN","RDROFF") quit:ER
		}
 
	// If fee group, file fees
	if 'ln.feegrpo.isNull() do { quit:ER

		type String FEETYP

		type ResultSet rs=Db.select("FEETYP","LNFEEGRP1","FEEGRP=:ln.feegrpo") quit:ER
		if rs.isEmpty() quit
		while rs.next() do {
			set FEETYP=rs.getCol(1)
			
			type RecordLNFEE lnfee=Db.getRecord("LNFEE","CID=:ln.cid,FEETYP=:FEETYP",1)
			
			if lnfee.getMode() quit	// Already set up

			set lnfee.cid=ln.cid
			set lnfee.feetyp=FEETYP
			set lnfee.feerem=0
			do lnfee.save()
			}
		}
 
	// Set up fees found in payment string and linked to P&I elements
	do { quit:ER

		type Boolean ILFF
		type Number I
		type String ELEM,FEETYP

		// Retrieve the payment application string record for this
		// loan so that the "Add Linked Fees" option can be verified.
		
		type RecordLNPAS2 lnpas2 = Db.getRecord("LNPAS2","TABLE=:ln.pas")
		set ILFF = lnpas2.ilff
		
		// Collate through the payment distribution string
		for I=1:1 set ELEM=ln.pmtdist.piece("-",I) quit:((ELEM.isNull())!ER)  do {

			// Escrow
			if $$ESC^LNU(ELEM) quit
 
 			type RecordLNFEE lnfee = Db.getRecord("LNFEE","CID=:ln.cid,FEETYP=:ELEM",1)

			// Already set up
 			if lnfee.getMode() quit
		
			// Set up fee found in payment string
			if Db.isDefined("LNFEEP","ELEM") do { quit:ER
				type RecordLNFEE lnfee=Class.new("RecordLNFEE")
				set lnfee.cid=ln.cid
				set lnfee.feetyp=ELEM
				set lnfee.feerem=0
				do lnfee.save()
				}
				
			/*
			 Set up all fees linked to the P&I payment elements if the
			 payment string specifies that linked fees should be included.
			 The LNFEE filer (after insert) will take care of creating 
			 fees linked to other fees in the payment distribution string.
			*/
			
			if ILFF,((ELEM="I")!(ELEM="P")) do {  quit
				type ResultSet rs=Db.select("FEETYP","LNFEEP","LFEE=1 AND BASIS=:ELEM")
				while rs.next() do {
					set FEETYP = rs.getCol("FEETYP")
					type RecordLNFEE lnkfee = Class.new("RecordLNFEE","CID=:ln.cid,FEETYP=:FEETYP")
					set lnkfee.feerem = 0
					do lnkfee.save()
					}
				}
			}
		}

	/*
	Set up late charge DAYEND file.
	NOTE:  Cannot do as index since data is stored in file
	*/
	if ln.dlcaf do {
		type RecordDAYENDLCHG dlchg=Class.new("RecordDAYENDLCHG")
		set dlchg.tjd=%SystemDate
		set dlchg.cid=ln.cid
		do dlchg.save()
		}
 
	// NFAMTORG, NFPLNORG - Original net deferred fee amount/plan Insert new fee
	if ln.nfamtorg,'ln.nfplnorg.isNull() do { quit:ER

		type String PLN

		do ^LNNFNEW1(.ln,ln.nfamtorg,ln.nfplnorg) quit:ER

		type RecordLNCYCPTS lncycpts=Class.new("RecordLNCYCPTS")
		set lncycpts.cid=ln.cid
		set lncycpts.typ="PTS"
		set lncycpts.caltd=PLN.piece("|",1)
		set lncycpts.nxadt=PLN.piece("|",2)
		set lncycpts.lsadt=PLN.piece("|",3)
		set lncycpts.cntr=PLN.piece("|",4)
		set lncycpts.term=PLN.piece("|",5)
		set lncycpts.freq=PLN.piece("|",6)
		set lncycpts.amt=PLN.piece("|",7)
		set lncycpts.rate=PLN.piece("|",8)
		set lncycpts.payee=PLN.piece("|",9)
		set lncycpts.pdby=PLN.piece("|",10)
		set lncycpts.apr=PLN.piece("|",11)
		set lncycpts.plan=PLN.piece("|",20)
		set lncycpts.rynd=PLN.piece("|",31)
		set lncycpts.ryfre=PLN.piece("|",32)
		set lncycpts.ryld=PLN.piece("|",33)
		set lncycpts.npda=PLN.piece("|",36)
		set lncycpts.nsip=PLN.piece("|",39)
		set lncycpts.nyld=PLN.piece("|",40)

		do lncycpts.save()
		}

	// Student loan
	if ln.idpf=1,prodctl.defal=1,cif.semfin do {

		type RecordUTBLSEMFIN semfin=Db.getRecord("UTBLSEMFIN","TYPE=:ln.type",1)

		// Date must equal "end of study date plus specified period"
		if ln.mdt'=$$EXT^UMDT(semfin.term,cif.semfin) do Runtime.setErrXBAD("LN",182) quit:ER

		type Date TMPDT

		if ln.igrc set TMPDT=$$EOMJD^SCADAT($$EXT^UMDT(ln.igrc,cif.semfin,"","N"))
		else  set TMPDT=$$EOMJD^SCADAT(cif.semfin)

		type RecordEFD efd=Class.new("RecordEFD")
		
		set efd.efdate=TMPDT
		// See SQLEFD.proc for buffer number logic
		set efd.buff=$$GETSEQ^SQLDD
		set efd.seq=1
		set efd.akey=ln.cid
		set efd.table="LN"
		set efd.sql="UPDATE LN SET PTF=0 WHERE CID="_ln.cid
		
		do efd.save()
		}
 
	// SRCDT - Strike Rate Compare Date
	if 'ln.srcdt.isNull() do { quit:ER

		// Strike rate compare date cannot precede system date
		if ln.srcdt<%SystemDate do Runtime.setErrXBAD("LN","SRCDPSD") quit

		if ln.strcal.isNull() quit

		// Strike rate compare date must be a business date
		if '$$BD^UNBD(ln.srcdt,ln.strcal) do Runtime.setErrXBAD("LN","SRCDBUS") quit
		}
 
	// Pre-authorized transfers
	if ln.ptf>0 do { quit:ER

		if prodctl.patsrc.isNull() quit
 
		// Invalid preauthorized transfer payment batch
		if 'Db.isDefined("UTBLSRC","'PAT',prodctl.patsrc") do Runtime.setErrSTBLER("LN","LNPATB") quit:ER
 
		type String CRCD
		#if CUVAR.%MCP set CRCD=ln.crcd
		#if 'CUVAR.%MCP set CRCD=""

		type RecordPAT1 pat1=Class.new("RecordPAT1")
		set pat1.src=prodctl.patsrc
		set pat1.acn=ln.acn
		set pat1.batch=Db.nextVal("PAT1","prodctl.patsrc")
		set pat1.cmt=$$^MSG(7121)	// Loan payment
 		set pat1.crcd=CRCD
 
		// If not Student loan, save the PAT and quit
		if ln.idpf'=1!(prodctl.defal'=1) do pat1.save() quit

		// If no end of study date, save the PAT and quit
		if 'cif.semfin do pat1.save() quit
		
		// Add stop date for student loans
		type Date TMPDT
		
		if ln.igrc set TMPDT=$$EXT^UMDT(ln.igrc,cif.semfin,"","N")+10
		else  set TMPDT=cif.semfin+10
		
		set pat1.stop=TMPDT
		do pat1.save()

		if prodctl.patglo.isNull() quit
 
		// Get offset information
		type RecordTRN trn=Db.getRecord("TRN","ETC=:prodctl.patglo")

		// Invalid preauthorized transfer payment offset code
		if trn.acn.isNull() do Runtime.setErrSTBLER("LN","LNPATOF") quit
 
		// PAT payment offset code must be a miscellaneous transaction code
		if trn.cls'="M" do Runtime.setErrSTBLER("LN","LNPATOF2") quit
 
		// PAT payment offset code must be a debit transaction code
		if trn.itc.extract() do Runtime.setErrSTBLER("LN","LNPATOF3") quit

		// Create primary PAT transaction
		type RecordPAT patpri=Class.new("RecordPAT")
		set patpri.src=pat1.src
		set patpri.acn=pat1.acn
		set patpri.batch=pat1.batch
		set patpri.seq=1
		set patpri.trncd=prodctl.crtrgp
		set patpri.cid=ln.cid
		set patpri.amount="TBA"
		do patpri.save()

		// Create primary PAT transaction offset
		type RecordPAT patoff=Class.new("RecordPAT")
		set patoff.src=pat1.src
		set patoff.acn=pat1.acn
		set patoff.batch=pat1.batch
		set patoff.seq=2
		set patoff.trncd=trn.etc
		set patoff.cid=trn.acn
		set patoff.amount="*"
		do patoff.save()
		}
 
	/*
	Process transaction for commitment
	Comm loan link & credit limit
	*/
	if 'ln.ccl.isNull(),ln.crlmt>0 do { quit:ER
	
		type Date %EffectiveDate
		type Number BRCD,CCL,CCLTRB,CID,COMMCID,LNTRB,TAMT
		type String TCMT
	
		set TAMT=-ln.crlmt
		set LNTRB=ln.trb
		set CCL=ln.ccl
		set COMMCID=ln.cid
		set BRCD=ln.boo
		set CID=CCL
		
		type RecordLN lnccl=Db.getRecord("LN","CID=:CCL")
		set CCLTRB=lnccl.trb
		if LNTRB-CCLTRB set TAMT=-TAMT
 
		// New Account
		set TCMT=$$^MSG(4149,COMMCID)
		
		do TTX^LNCL1(.lnccl) quit:ER
		}
	
	// Re-amortization - Next Date
	if ln.rand do {
		type RecordDAYENDRAND rand=Class.new("RecordDAYENDRAND","RAND=:ln.rand,CID=:ln.cid")
		do rand.bypassSave()
		}

	if ln.dirnd,(ln.iropt=1!(ln.iropt=2)) do {
		type RecordDAYENDNEGAM negam=Class.new("RecordDAYENDNEGAM","TJD=:ln.dirnd,CID=:ln.cid")
		do negam.bypassSave()
		}
	
	if ln.cbmet do {

		type Date CBPNDNEW
		type Number NUMCPNS
		
		if ln.cbmet=1 set NUMCPNS=$$CBMET1^LNFUNCS(ln.onp,ln.cntcr) set CBPNDNEW=%SystemDate
		if ln.cbmet=2 set NUMCPNS=$$CBMET2^LNFUNCS(.CBPNDNEW,ln.cboff,ln.apcnd,ln.anfre,ln.pchnd,ln.pcfre,ln.icm,ln.dist1nd,ln.dist1fre)
		if ln.cbmet=3 set NUMCPNS=$$CBMET3^LNFUNCS(.CBPNDNEW,ln.cboff,ln.cbfre,ln.dist1nd,ln.dist1fre)
 
		// Insert dayend entry for today, PMET=3
		type RecordLNCPN lncpn=Class.new("RecordLNCPN")

		set lncpn.pnd=%SystemDate
		set lncpn.pmet=3
		set lncpn.cid=ln.cid
		set lncpn.ncp=NUMCPNS
		set lncpn.ncn=1
		set lncpn.ndd=ln.dist1nd
		set lncpn.tpt=ln.pmt
		
		do lncpn.save()
		}
 
	// If SFRE defined in product, create new statement group
	if %ProcessMode=0,proddftl.sfre do { quit:ER
	
		type RecordCMBGRP cmbgrp=Class.new("RecordCMBGRP")
	
		set cmbgrp.acn=ln.acn
		set cmbgrp.stmgrp=Db.nextVal("CMBGRP","ln.acn")
		set cmbgrp.addr=ln.cid
		set cmbgrp.sfre=ln.sfre
	
		do cmbgrp.save()
	
		type RecordCMBSTM cmbstm=Class.new("RecordCMBSTM")
		
		set cmbstm.acn=ln.acn
		set cmbstm.stmgrp=cmbgrp.stmgrp
		set cmbstm.cid=ln.cid
		
		do cmbstm.save()
		}

	// Check for Institution Type Restriction.
	if 'cif.intype.isNull() do { quit:ER
	
		type RecordPRODCTL cifprod=Db.getRecord("PRODCTL","TYPE=:cif.type")
 
		// If INTYPRST is set to Yes, check the user table UTBLTTBL for a valid combination.
		if %ProcessMode'=2,cifprod.intyprst do { quit:ER
			if Db.isDefined("UTBLINTTBL","cif.type,cif.intype,ln.type") quit

			// Product not valid for Institution Type
			do Runtime.setErrXBAD("LN","INTYPRST") quit:ER
			}
		}
 
	// Balloon Amount
	if 'ln.ballamt.isNull() do {
	
		// Balloon amount cannot be greater than loan amount
		if ln.ballamt>ln.amtreq do Runtime.setErrMSG("LN",3747) quit:ER
	
		// Amount must be greater than zero
		if ln.ballamt=0 do Runtime.setErrMSG("LN",279) quit:ER
		}
	
	// VAT on interest calculation option must be 2 if billing inflation index defined
	if ('ln.bilinflcalin.isNull())&(ln.vatintopt'=2) do Runtime.setErrMSG("LN",6186) quit:ER 

	/*
	 Loop through all of the agent's commission plans and check to
	 see if they are assessed at the account level.  If they are, then
	 insert them into the file COMPLNCID
	*/
	type ResultSet rs=Db.select("CPLAN","AGENTCOM","AGENT=:ln.boo") quit:ER
	if 'rs.isEmpty() while rs.next() do {
		
		type Date NCNGDT
		type String CPLAN,query
		
		set CPLAN=rs.getCol(1)
 
		// Get the commission plan data
 		type RecordUTBLCOMPLN ucompln=Db.getRecord("UTBLCOMPLN","CPLAN=:CPLAN")
 
		// Check to see if the plan is valid within the query 
		set query=ucompln.intquery
		if '$$CHECKCID^COMCALC() quit
 
		// If account level calculations, insert into the COMPLNCID file, o/w quit
		if 'ucompln.alc quit
		
		set NCNGDT=""
		if 'ucompln.rrfre.isNull() set NCNGDT=$$NJD^UFRE(%SystemDate,ucompln.rrfre)

		type RecordCOMPLNCID compln=Class.new("RecordCOMPLNCID")

		set compln.cid=ln.cid
		set compln.cplan=CPLAN
		set compln.rate=ucompln.rate
		set compln.ncngdt=NCNGDT
		
		do compln.save()
		}	
	
	/*
	 If a seasonal address is defined within the customer record of the
	 primary account owner, then the values within the seasonal address
	 window will default to the account record."
	*/
	if Db.isDefined("SADDRCIF","ln.acn") do { quit:ER
 
		type RecordSADDRCIF saddrcif=Db.getRecord("SADDRCIF","ln.acn")
		type RecordSADDRACN saddracn=Class.new("RecordSADDRACN")
 
		set saddracn.cid=ln.cid
		set saddracn.sadsd=saddrcif.sadsd
		set saddracn.saded=saddrcif.saded
		set saddracn.sad1=saddrcif.sad1
		set saddracn.sad2=saddrcif.sad2
		set saddracn.sad3=saddrcif.sad3
		set saddracn.sad4=saddrcif.sad4
		set saddracn.scity=saddrcif.scity
		set saddracn.scntry=saddrcif.scntry
		set saddracn.sstate=saddrcif.sstate
		set saddracn.szip=saddrcif.szip
		set saddracn.scounty=saddrcif.scounty	//BASEL II

		set saddracn.nsad1=saddrcif.nsad1
		set saddracn.nsad2=saddrcif.nsad2
		set saddracn.nsad3=saddrcif.nsad3
		set saddracn.nsad4=saddrcif.nsad4
		set saddracn.nscity=saddrcif.nscity
		set saddracn.nscntry=saddrcif.nscntry
		set saddracn.nsstate=saddrcif.nsstate
		set saddracn.nszip=saddrcif.nszip
		set saddracn.nscounty=saddrcif.nscounty	//BASEL II

		do saddracn.save("NOTRIGBRF/NOTRIGAFT/NOJOURNAL")
 		}
 		
 	// Region Code must be three numbers
	if prodctl.iftanpro = "IFTAN" do { quit:ER
		
		type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD","BRCD=:ln.boo",1)
		type Number I
		type String CH, REGION
		
		if utblbrcd.region.length()'=3 do Runtime.setErrMSG("UTBLBRCD",6198) quit
		
		set REGION=""
		
		for I=1:1:utblbrcd.region.length() do { quit:ER
			set CH = utblbrcd.region.extract(I)
			if CH'="0" set REGION=REGION_CH
		}
		
		if 'REGION.isNumber() do Runtime.setErrMSG("UTBLBRCD",6198) quit
	}
	
	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60822^63983^Sudanthiran S. Kumar^78683"	// Signature - LTD^TIME^USER^SIZE
