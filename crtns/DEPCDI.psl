DEPCDI	/*
	   All the assignment expressions for computed data items in DEP
	   This procedure definition replaces [.MRTNS]DEPCDI.M
	
	   LIBRARY:
	   $$ AB90D	90-Day Average Balance from Date of First Deposit
	   $$ AED	Analysis End Date using Off Cycle Analysis date 
	   $$ AEDAPC	Analysis End Date using Escrow Analysis PMT Change Next date
	   $$ APCBAL	Actual Starting Balance using Escrow Analysis PMT Change Next date
	   $$ APENDBAL	Escrow End Balance using APCBAL
	   $$ AVB	Average Monthly Balance
	   $$ BALAGE	Age Milestone Balance
	   $$ BALAVL	Available Balance
	   $$ BALCCL	Combined Collected Balance
	   $$ BALCLG	Combined Ledger Balance
	   $$ BALRES	Reserve Balance
	   $$ BALSTM	Ending Balance Last Statement Date
	   $$ BEGBAL	Actual Starting Balance using Off Cycle Analysis date
	   $$ BGTARR	Budget Contribution Arrears
	   $$ BGTCON	Scheduled Contributions To Date   
	   $$ BRREG	Account Region
	   $$ BYINT	Budget Year Interest
	   $$ CD	Current Dormant
	   $$ CDTUF	Certificate Transfer Use Flag
	   $$ CHKAMT	Check Amount
	   $$ CHKUF	Outstanding Checks Use Flag
	   $$ CIFEQV	Equivalent Value in CIF Base Currency
	   $$ COMBAL	Combined Balance Indicator
	   $$ DCL	Deposit Coverage Line
 	   $$ ENDBAL	Escrow End Balance using BEGBAL
	   $$ ESCFRE	Payment Frequency
	   $$ EUREQV	Euro Equivalent Amount
	   $$ EXDT	Expiration Date
	   $$ GCRAVL	GCR Available
	   $$ GCRLBAL	GCR Liability Package Balance
	   $$ GCRLDBAL	GCR Liability Daily Balance
	   $$ GRCDYS	Grace Days
	   $$ HLDAMT	Amount on Hold
	   $$ IDF	Interest - Daily Factor
	   $$ INIDEP	Target Starting Balance
	   $$ INPUF	Interest Transfer Use Flag
	   $$ INTYLD	Effective Annual Interest Yield
	   $$ INTYLDRD	Effective Annual Int/Div Yield Rounded
	   $$ IRATYP	Retirement Account Type (Short)
	   $$ LBAGE	Period Low Balance
	   $$ LBDOD	Date of Death Low Balance
	   $$ LGHB	Last Good Health Balance
	   $$ LNINAR	Total of all related interest amts in arrears
	   $$ LNMBAL1	Minimum Balance - Loan Percentage 1
	   $$ LNMBAL2	Minimum Balance - Loan Percentage 2
	   $$ MATGRC	Maturity Date + Grace Days
	   $$ MATTRM	Maturity Date + Term
	   $$ MAXAWA	Maximum Annual Withdrawal Amount
	   $$ MEBAL	Month End Balance
	   $$ NEGBAL	Negative Balance
 	   $$ NEWPMT	Total Loan Payment
	   $$ NOTES	Account Notes on File
	   $$ NSDDEP	Non-Same Day Future Deposit Coverage
	   $$ ODFACN	Overdraft Account
	   $$ ODUNAMT	Unauthorized Overdraft Amount
	   $$ OVG	Overage Amount
	   $$ PATUF	Preauthorized Transfer Use Flag
       	   $$ PEDCNTR	Periodic Contributions
	   $$ PINV	Periods in violation (Reg D)
	   $$ PLDGAVL	Available Balance less %PAVL holds
	   $$ PLGDEP	Collaterialized Loan Balance
	   $$ PML	Send Promotional Mail
	   $$ RATS	Retirement Account Type (Short)
	   $$ RCJ1	RC-J Categories For Savings Banks
	   $$ RCJ2	RC-J Categories For Commercial Banks
	   $$ RELDBAL	Total of all related deposit account balance
	   $$ RELLBAL	Total of all related loan account balances
	   $$ RELLNARR	Total of all related principle amts in arrears
	   $$ SCHCONTR	Scheduled Budget Contributions
	   $$ SDDEP	Same Day Future Deposit Coverage
	   $$ SECAVL	Securities Available Balance
	   $$ SHRBAL	Total of all related share account balances
	   $$ SRVUF	Service Fee Target Use Flag
	   $$ SWPINVB	Sweep Investment Balance
	   $$ SWPINVB	Sweep Investment Balance Available
	   $$ SWPUF	Sweep Recipient Use Flag
	   $$ SWPVAL	Computed Sweep Account Values
	   $$ SYSEQV	Equivalent Value in Bank's Base Currency
	   $$ TNMPMTS	Returns total number of budget contributions
	   $$ TODCNT	Total Overdraft Count GCR
	   $$ TOPAAMT	Total of all payments made from budget account
	   $$ TOTAAMT	Total Annual budgeted amount for all budgets
	   $$ TOTCONTR	Total Contributions
	   $$ TOTINTAV	Total Interest Available
	   $$ TOTMSC	Total Miscellaneous Cash Contributions
	   $$ TRANCHG	Total transaction charges assessed during a budget yr
	   $$ TRMD	Account Term in Days
	   $$ TLSEQ	Last History Tran Sequence
	   $$ TSEQ	Next History Trans Sequence
	   $$ TYPEDES	Return product type description
	   $$ UIDCID	Account Owned By User
	   $$ XCF01	System Use - Statement Info From CIF
	   $$ XDEP01	System Use - Current Month Data
	   $$ XDEP02	System Use - Prior Month Data
	   $$ XDEP03	System Use - Current Statement Data
	   $$ XDEP04	System Use - Prior Statement Data
	   $$ XDEP05	System Use - Amt/Date of Last Dr/Cr
	   $$ XDEP07	System Use - Earnings Analysis Info
	   $$ XDEP08	System Use - Secondary CIFs
	   $$ XDEP10	System Use - Service Charge Info
	   $$ YLD30D	Returns the 30 day yield
	   $$ YLD7D	Returns the 7 day yield


	---- Revision History ------------------------------------------------
	
	07/03/07 - RussellDS - CR28737
		Added .get() to %EffectiveDate in calls to EXC^CRCDUTL
	
	02/12/07 - RussellDS - CR25044
		Modified BALAVL section to conform to correct requirements for
		CR22464/CR15124.
		
		Removed the PLDGAVL section.  Computed call has been changed to
		call BALAVL with different SKIPPAVL parameter.
	
	12/08/06 - SWARNALP - CR 22716
	        Modifed GCRLDBAL section to add ResultsetObject.Next() method 
	        to point to the next record in general (first record in this 
	        case) so that the record value is available for use while 
	        fetching a specific set of records from GCRPKG table using 
	        Db.Select() method. Also modified GCRLBAL section to fetch 
	        only the last 6 months records from GCRPKG table and to set 
	        both FD and TD with the same date (GCRPKG.SDATE) if the CNT=0 
	        whithin the loop indicating that there is only one record in 
	        GCRPKG table.
	        
	11/29/06 - MbuiM - CR 21675
		   Changed reference of INTAVLNC to INTAVLNCR to comply with 
		   GTM version 5.0.
	
	10/18/06 - KinI - CR 23667
		Modified BALAVL section to check loan record existence to avoid
		"Record not on file" for BALAVLCALCFO.extract(3) in case when 
		deposit serves as a source of protection for overdrawn deposit.
		Also added .get() to %EffectiveDate when performing currency 
		exchange.
		
	08/28/06 - KUMARB - CR 22464
		Added new section BALAVLFO to return the Available Balance
		Calculation formula.
		Modified the line tag BALAVL and PLDGAVL to support new 
		Available Balance Calculation formula to compute Balance 
		Available.
	
	05/24/06 - GIRIDHAL - CR2127
		   Removed references to SPDHLD (Split day processing)which
		   is being obsoleted.
	
	05/15/06 - RussellDS - CR21296
		   Removed unnecessary references to %CACHE.  Changed AVB
		   section to use cache array instead of %CACHE, which is
		   reserved for PSL record objects.
		   
		   Cleaned up PSL warning issues.
	
	04/19/06 - RussellDS - CR20209
		   Remove obsolete UNSTLFDS.
	
	02/13/06 - SWARNALP - CR 18338
	        Modified APENDBAL and ENDBAL sections to update the computed 
	        escrow payment in LNEAM table for its use in the reports.

	02/02/06 - Srinivar / SmithCD - CR 16890
		Modified the sections ENDBAL,APENDBAL,APCBAL,BEGBAL
		to pass additional parameter RecordLNAPCHGE
		as a second parameter while calling EXEC^LNEA.
		Modified PATUF section to reference the PATUF table instead of 
		XREFPATF, which no longer exists and was causing a compiler 
		error. Performed some minor cleanup.
	
	11/18/05 - SkariahV - CR18158
		Removed the sections BALAGE,LBAGE,LBDOD and LGHB since BALAGE.TBL
		is Obsoleted. Modified the section GCRLDBAL to correct the 
		deprecated (Db.prevVal)feature.
		
	08/17/05 - RussellDS - CR16911
		   Modified SRVUF to remove use of obsolete table XREFSRVTA.
		   
		   Modified ODFACN to remove use of deprecated nextKey.
		   
		   Remove "ORDER BY" references from Db.selects.
	
	05/17/05 - KinI - 15524
		   Modified INIT^UAVB calls in BALAGE, LBAGE, LBDOD and LGHB
		   sections to pass CID as the 2nd parameter instead of 3rd.
	
	02/19/05 - KELLYP - CR 13662
		   Modified the BALAVL, PLDGAVL, SWPINVB, and BALCLG sections 
		   to use a join-type query instead of a sub-query for the where
		   clause in certain Db.select calls.  The sub-query logic does 
		   not work for Oracle environments.  Also modified the GCRLBAL
		   and UNSTLFDS sections to correct duplicate variables name
		   compilation warnings.  Also removed pre-2003 history.
	
	06/04/04 - HillanbrandLE - CR 8006
		   Modified XDEP05 and removed call to AMTLD^DEPCD and added 
		   the logic in the XDEP05 subsection of this routine. 
	
	01/15/04 - RussellDS - CR 7514
	  	   Modified NOTES section to eliminate use of table
	  	   NOTESACN (obsoleted) and replace with table NOTES.

	*/

	quit
	

public BALRES(Number BALCOL, String TYPE)

	/*
	The function is used to compute DEP.BALRES field

	Note:  Original had CRCD parameter, not referenced
	
	ARGUMENTS:
	. BALCOL	Collected Balance		/REQ/NONULL/MECH=VAL
	. TYPE		Product Type			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Reserve Balance			/TYP=Number
	*/
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")

	quit BALCOL*prodctl.resreq/100
	
	
public BALAVL( Number  CID,		// Account Number
	       String  AVLCODE,		// Balance Calculation Code [*]
	       Boolean SKIPPAVL,	// Skip % Pledged Avail Bal [*]
	       Number  BAL,		// Ledger Balance
	       Number  BALCOL,		// Collected Balance
	       Number  CHKHLD,		// Check Hold Amount
	       String  CRCD,		// Account Currency Code
	       Number  DONRSK,		// Donor Risk Hold Amount
	       Date    ODEXP,		// Overdraft Limit Expiration Date
	       Number  ODLIM,		// Overdraft Limit on account
	       Boolean PHLD,		// Permanent Hold Indicator
	       Number  STFNET,		// Net Store & Forward
	       String  TYPE)		// Account Product Type
	      
	/*
	Computed function for DEP.BALAVL and for DEP.PLDGAVL
	
	Calculation is based on the AVLCODE indicators, as shown below, and
	always includes a fixed calculation of:
	
		BALAVL = BALAVL + STFNET - DONRSK - permanent holds
		
	DEP.BALAVL calls with SKIPPAVL = 0, whereas DEP.PLDGAVL calls with
	SKIPPAVL = 1
		
	NOTES:	The accuracy of the inclusion of Investment Sweep Balances
		requires that the instutition link a sweep account only to
		one account and that withdrawals not be made directly from the
		sweep account without review of the linked account balance.
		Otherwise, it is possible to use the balance in the sweep
		account by multiple accounts for balance available and overdraft
		processing.  (Enhancements to the sweep process to deal with this
		issue are being reviewed.  This comment should be removed at the
		point this is resolved.)
		
		DEP.SDPHLD (Split Day Processing Hold Amount) should be subtracted
		from the above fixed calculation if this code is retrofitted to a
		version with split day processing, or if split day processing is
		implemented in this version.
	
	ARGUMENT NOTES:
		. AVLCODE	Calculation code - each bit position, considering
				the right-most position as position 1, indicates
				how to continue to calculate BALAVL, after
				starting with value based on position 1.  Each
				subsequent position (2-4), if set to 1, indicates
				the action shown below:
				
		  Pos	Value	Description
		   1	  0	BALAVL = BAL
		   1	  1	BALAVL = BALCOL
		   2	  1	BALAVL = BALAVL + ODLIM
		   3	  1	BALAVL = BALAVL + Source of Overdraft Protection Account(s) Available Balances
		   4	  1	BALAVL = BALAVL - CHKHLD
		   5	  1	BALAVL = BALAVL + Linked Investment Sweep Account(s) Available Balances
		   
		   Example:
		   
		     AVLCODE = 13
		     Binary value of 13 = 00001101
		     Positions 1, 3, and 4 are set, so the formula would be:
		     
		     	BAL + Source of OD Protection Account(s) Available Balances - CHKHLD
		     	
		   An AVLCODE of 99999 indicates a custom program.
		   
		. SKIPPAVL	When calculating permanent holds, ignore any holds
				based on table STBLHOLD %PAVL.  This flag
				is passed to ^UHLD.
	*/
	
	type Number BALAVL
	
	// If custom program compile code to call it
	#IF 'CUVAR.BALAVLPGM.isNull()
	#ACCEPT Date=01/25/07; Pgm=RussellDS; CR=25042; Group=XECUTE
	if (AVLCODE = 99999) xecute "set BALAVL=$$^"_CUVAR.BALAVLPGM_"(CID,AVLCODE,SKIPPAVL,BAL,BALCOL,CHKHLD,CRCD,DONRSK,ODEXP,ODLIM,PHLD,STFNET,TYPE)" quit BALAVL
	#ENDIF
	
	set BALAVL = +BALCOL
	
	if AVLCODE do {
	
		// Bit 1
		if (AVLCODE # 2) set BALAVL = +BAL
	
		// Bit 2
		if ((AVLCODE \ 2) # 2), (ODLIM <> 0), (ODEXP.isNull() ! (ODEXP > %SystemDate)) set BALAVL = BALAVL + ODLIM
	
		// Bit 3
		if ((AVLCODE \ 4) # 2) set BALAVL = BALAVL + $$ODXFR(CID, CRCD, "", "")
	
		// Bit 4
		if ((AVLCODE \ 8) # 2) set BALAVL = BALAVL - CHKHLD
	
		// Bit 5
		if ((AVLCODE \ 16) # 2) set BALAVL = BALAVL + $$SWPINVBA(CID, CRCD)
	}

	// Deal with fixed calculation = + STFNET - DONRSK - permanent holds
	set BALAVL = BALAVL + STFNET - DONRSK
	if PHLD set BALAVL = BALAVL - $$^UHLD(CID, BAL, CRCD, SKIPPAVL)

	quit BALAVL


public ODXFR( Number CID,			// Account Number                     
	      String CRCD,			// Account Currency code
	      List   CLASSES,			// List of classes to accumulate
	      List   GROUPS)			// List of Groups to accumulate
       
	/*
	Accumulate available balances for source of overdraft protection accounts.
	
	Function provides ability to pass list of CLASSES or GROUPS to limit
	selection.  This provides support for future computeds to obtain this
	type of information.
	
	RETURNS:
		. $$	Accumulated overdraft available		/TYP=N
	*/
	
	type Number AVAIL, TOTAVAIL
	
	set TOTAVAIL = 0

	type ResultSet rs = Db.select("ODACN", "DEPODP", "CID = :CID")

	while rs.next() do {
			
		type RecordACN acn = Db.getRecord("ACN", "CID = :rs.getCol(""ODACN"")")

		if 'CLASSES.isNull(), 'CLASSES.contains(acn.cls) quit
		if 'GROUPS.isNull(), 'GROUPS.contains(acn.grp) quit
		
		if (acn.cls = "L") set AVAIL = {RecordLN}acn.avlbal
		else  set AVAIL = {RecordDEP}acn.balavl

		// If multi-currency environment, convert currency if necessary
		#IF CUVAR.%MCP
		if (CRCD '= acn.crcd) do {          // Need to convert currency
		
			type Number EXCAMT
			
			do EXC^CRCDUTL(CRCD, acn.crcd, AVAIL, 0, 2, "00", acn.ccode, %EffectiveDate.get(), 1, %CompanyName, %SystemCurrency)
			set AVAIL = EXCAMT.roundCur(CRCD)
		}
		#ENDIF

		set TOTAVAIL = TOTAVAIL + AVAIL
	}

	quit TOTAVAIL
	
	
public SWPINVBA( Number CID,			// Account Number                     
		 String CRCD)			// Account Currency code
       
	/*
	Accumulate available balances for investment accounts accounts.
	
	RETURNS:
		. $$	Accumulated investment account(s) available	/TYP=N
	*/
	
	type Number AVAIL, TOTAVAIL
	
	set TOTAVAIL = 0

	type ResultSet rs = Db.select("ICID", "DEP101", "CID = :CID")

	while rs.next() do {
			
		type RecordDEP dep = Db.getRecord("DEP", "CID = :rs.getCol(""ICID"")")

		set AVAIL = dep.balavl
		
		/* NOTE that the code to perform a currency conversion is in
		   anticipation of future changes to Profile to allow investment
		   accounts in other than the base account's currency.  At the
		   present time, both accounts must be in the same currency.
		*/

		// If multi-currency environment, convert currency if necessary
		#IF CUVAR.%MCP
		if (CRCD '= dep.crcd) do {          // Need to convert currency
		
			type Number EXCAMT
			
			do EXC^CRCDUTL(CRCD, dep.crcd, AVAIL, 0, 2, "00", dep.ccode, %EffectiveDate.get(), 1, %CompanyName, %SystemCurrency)
			set AVAIL = EXCAMT.roundCur(CRCD)
		}
		#ENDIF

		set TOTAVAIL = TOTAVAIL + AVAIL
	}

	quit TOTAVAIL


public BALSTM(Number CID)

	/*
	The function is used to compute DEP.BALSTM field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Ending Balance Last Statement Date	/TYP=Number
	*/
	
	type Number ACN,BALSTM
	type Date JD
	type String STMGRP

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	set ACN=dep.acn

	type RecordCMBCID cmbcid=Db.getRecord("CMBCID","CID=:CID,ACN=:ACN",1)
	set STMGRP=cmbcid.stmgrp
	if STMGRP="" quit ""

	type RecordCMBSTM cmbstm=Db.getRecord("CMBSTM","ACN=:ACN,STMGRP=:STMGRP,CID=:CID",1)
	set JD=cmbstm.sltd
	if 'JD quit ""

	type ResultSet rs=Db.select("ENDBAL","HIST","CID = :CID and TJD not > :JD","TJD DESC")

	if rs.next() set BALSTM=rs.getCol("ENDBAL")
	else  set BALSTM=""

	quit BALSTM
	
	
public BRREG(String BOO)

	/*
	The function is used to compute DEP.BRREG field
	
	ARGUMENTS:
	. BOO		Branch of Ownership 		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Account Region			/TYP=String
	*/
	
	type RecordUTBLBRCD utblbrcd=Db.getRecord("UTBLBRCD","BRCD=:BOO")

	quit utblbrcd.region
		

public CIFEQV(Number CID,Number ACN,String BSE,Number AMT)

	/*
	Value of account in customer's (CIF) base currency
	The function is used to compute ,DEP.CIFEQV,LN.CIFEQV field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	. ACN		Customer Number			/REQ/NONULL/MECH=VAL
	. BSE		Currency Code			/REQ/NONULL/MECH=VAL
	. AMT		Ledger Balance			/REQ/NONULL/MECH=VAL

	RETURNS:
	. $$ 		Equivalent Value in CIF Base Currency /TYP=Number
	*/
	
	type String SEC
	type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN",1)

	set SEC=cif.crcd
	
	set:BSE="" BSE=%SystemCurrency
	set:SEC="" SEC=%SystemCurrency
	if SEC=BSE quit AMT
	 
	do CAMT^CRCDUTL(BSE,SEC,.AMT)

	quit AMT
	
		
public CDTUF(Number CID)

	/*
	The function is used to compute DEP.CDTUF field
	
	ARGUMENTS:
	. CID		Account Number 			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Certificate Transfer Use Flag  /TYP=Boolean
	*/
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)

	quit (dep.racn'="")
	
		
public CHKUF(Number CID)

	/*
	The function is used to compute DEP.CHKUF field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Outstanding Checks Use Flag	/TYP=L
	*/

	type Number CHK,CHKARR(),CHKCNT,CHKS,CHKUF,HIGH,LOW

	type ResultSet rs1=Db.select("CID","XCHECK","CID=:CID")
	type ResultSet rs2=Db.select("CID","XCHKPRD","CID=:CID")
	if rs1.isEmpty(),rs2.isEmpty() quit 0

	// A pending check book print request exists
	if 'rs2.isEmpty() quit 1
	 
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	set CHKS=dep.chks

	set CHKUF=0
		 
	type ResultSet rs3=Db.select("HIGH,LOW","XCHECK","CID=:CID AND CHKS=:CHKS","HIGH DESC") 

	while rs3.next() do { quit:CHKUF=1

		type Number ER=0
		type Number X=""
		type String RM

		set HIGH=rs3.getCol("HIGH") set LOW=rs3.getCol("LOW")
		set CHKCNT=$$CHKCNT^CHKNUTL(LOW,HIGH)-1
		do CHKRNG^CHKNUTL(LOW,CHKCNT)
		set CHKARR(0)=LOW
		set X=""
		for  set X=$O(CHKARR(X),-1) quit:X=""  do { quit:CHKUF
			do CHKACT^CHKPROC("CLOSE",CHKARR(X),CID)
			if ER set CHKUF=1
			}
		}
	
	quit CHKUF

		
public EUREQV(Number AMT,String CRCD)

	/*
	The assignment expression for the computed data items EBAL and EBALAVL
	
	ARGUMENTS:
	. AMT			Amount to Convert			/REQ/NONULL/MECH=VAL
	. CRCD		Currency Code			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$			Euro Equivalent Amount		/TYP=Number
	*/

	type public String %EMUCRCD
	type Number EUREQV

	if %EMUCRCD.get()="" quit ""
	set EUREQV=$$EURRND^CRCDUTL(AMT,CRCD,%EMUCRCD)
	
	quit EUREQV

	
public HLDAMT(	Number CID,
		Number BAL,
		String CRCD,
		Boolean PHLD)
	/*
	The function is used to compute DEP.HLDAMT field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	. BAL		Account Balance			/REQ/NULL/MECH=VAL
	. CRCD		Account Currency Code		/REQ/NULL/MECH=VAL
	. PHLD		Permanent Hold Indicator	/REQ/NULL/MECH=VAL
	
	RETURNS:
	. $$ 			Amount on Hold			/TYP=Number
	*/
	
	if PHLD quit $$^UHLD(CID,BAL,CRCD)

	quit 0
	
	
public INPUF(Number CID)

	/*
	The function is used to compute DEP.INPUF field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Interest Transfer Use Flag	/TYP=Boolean
	*/

	type Number ITRF
 
	type ResultSet rs=Db.select("ITRF","XREFITRF","ITRF=:CID")
	if rs.isEmpty() set ITRF=""
	else  set ITRF=rs.next() set ITRF=rs.getCol("ITRF")
 
	if ITRF'="" quit 1

	quit 0
	
		
public MAXAWA(Number CID)

	/*
	Maximum annual withdrawal amount

	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$  		Maturity Value	  	/TYP=Number
	*/
  
	type Number MAXEMPRC,PRATIO
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)

	set MAXEMPRC=dep.maxemprc
	set PRATIO=dep.pratio
	if 'PRATIO quit ""

	quit (MAXEMPRC/(PRATIO/100))


public RCJ1(Number CID,Date AMDT)

	/*
	Reg J Category for CD's
	Designed for use by the System Reg-J report SCA209.
	The function is used to compute DEP.RCJ1   field

	Note:  CID parameter is not referenced and not needed
	
	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	. AMDT		Account Maturity Date	/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		RC-J Categories For Savings Banks	/TYP=String
	*/
	
	if AMDT-%SystemDate<182 quit "A"
	if AMDT-%SystemDate<365 quit "B"
	if AMDT-%SystemDate<730 quit "C"
	if AMDT-%SystemDate<1095 quit "D"
	if AMDT-%SystemDate<1826 quit "E"
	if AMDT-%SystemDate<3652 quit "F"

	quit "G"

		
public RCJ2(Number CID,Date AMDT)

	/*
	Reg J Category for CD's
	Designed for use by the System Reg-J report SCA054.
	The function is used to compute DEP.RCJ2 field

	Note:  CID parameter is not referenced and not needed

	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	. AMDT		Account Maturity Date	/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		RC-J Categories For Commercial Banks /TYP=T
	*/
	
	if AMDT-%SystemDate<2 quit "A" 
	if AMDT-%SystemDate<90 quit "B" 
	if AMDT-%SystemDate<180 quit "C" 
	if AMDT-%SystemDate<365 quit "D" 
	if AMDT-%SystemDate<1825 quit "E" 
	
	quit "F"
	
		
public SRVUF(Number CID)

	/*
	Service Charge Target Use Flag
	The function is used to compute DEP.SRVUF field
	
	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Service Fee Target Use Flag /TYP=Boolean
	*/

	type ResultSet rs = Db.select("CID", "DEP", "SVCFEECID=:CID")

	if rs.isEmpty() quit 0

	quit 1
		

public SWPUF(Number CID)

	/*
	Sweep Recipient Use Flag
	The function is used to compute DEP.SWPUF field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Sweep Recipient Use Flag	/TYP=Boolean
	*/

	type ResultSet rs=Db.select("ICID","DEP101","ICID=:CID") 
	if rs.isEmpty() quit 0

	quit 1
	

public SYSEQV(Number CID,String BSE,Number AMT)

	/*
	Value of account in bank's base currency (CUVAR.%CRCD)
	The function is used to compute DEP.SYSEQV,LN.SYSEQV field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	. BSE		Currency Code			/REQ/NONULL/MECH=VAL
	. AMT		Ledger Balance			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Equivalent Value in Bank's Base Currency /TYP=Number
	*/
	
	type String SEC=%SystemCurrency

	if BSE="" set BSE=%SystemCurrency
	if SEC=BSE quit AMT 

	do CAMT^CRCDUTL(BSE,SEC,.AMT)

	quit AMT
	

public XCF01(Number CID)

	/*
	Calculate Account Statement Information
	The function is used to compute DEP.XCF01 field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		System Use - Statement Info From CIF  /TYP=String
	*/
	
	type Number ACN,STMGRP
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	type String XCIF01=""

	set ACN=dep.acn

	type RecordCMBCID cmbcid=Db.getRecord("CMBCID","CID=:CID,ACN=:ACN",1)
	set STMGRP=cmbcid.stmgrp
	if STMGRP="" quit XCIF01

	type RecordCMBGRP cmbgrp=Db.getRecord("CMBGRP","ACN=:ACN,STMGRP=:STMGRP",1)
	type RecordCMBSTM cmbstm=Db.getRecord("CMBSTM","ACN=:ACN,STMGRP=:STMGRP,CID=:CID",1)
	
	set XCIF01.piece("|",1)=cmbgrp.sndt
	set XCIF01.piece("|",2)=cmbstm.sltd
	set XCIF01.piece("|",3)=cmbstm.stpr
	set XCIF01.piece("|",4)=cmbgrp.sfre

	quit XCIF01


public XDEP01(Number CID)

	/*
	Computed value for computed data item XDEP01
	The function is used to compute DEP.XDEP01 field
	
	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		System Use - Current Month Data	/TYP=String
	*/
	
	type Number ER=0
	type String ET,RM,TRN,XDEP01,XTSO
	
	do ADBM1^UAVB1
	if ER quit ""

	quit XDEP01


public XDEP02(Number CID)

	/*
	The function is used to compute DEP.XDEP02 field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		System Use - Prior Month Data	/TYP=String
	*/
	
	type Number ER=0
	type String CC,ET,RM,TRN,XDEP02
	
	do ADBM2^UAVB1
	if ER quit ""

	quit XDEP02

	
public XDEP03(Number CID)

	/*
	The function is used to compute DEP.XDEP03 field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Current Statement Data  	/TYP=String
	*/
	
	type Number ER=0
	type String ET,RM,WIRN,XDEP03
	
	do ADBS1^UAVB1
	if ER quit ""

	quit XDEP03

		
public XDEP04(Number CID)

	/*
	The function is used to compute DEP.XDEP04 field
	
	ARGUMENTS:
	. CID		Account Number 			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Prior Statement Data		/TYP=String
	*/
	
	type Number ER=0
	type String CC,ET,RM,TRN,XDEP04
	
	do ADBS2^UAVB1
	if ER quit ""

	quit XDEP04

		
public XDEP05(Number CID)

	/*
	The function is used to compute DEP.XDEP05 field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Amt/Date of Last Dr/Cr  	/TYP=String
	*/
	
	type Date DATE
	type Number CR,DR
	type String ITC1,PRN,XDEP05
	
	set CR=""
	set DR=""
	set XDEP05=""

	/* Select history records excluding file maintenance and error correct
	or reversal */
	type ResultSet rs=Db.select("TAMT,ITC1,TJD","HIST","CID=:CID AND ITC IS NOT NULL AND ITC6<>1 AND ITC12<>1","TJD DESC")
	if rs.isEmpty() quit XDEP05
	while rs.next() do { if DR,CR quit
		set PRN=rs.getCol("tamt")
		set ITC1=rs.getCol("itc1")
		set DATE=rs.getCol("tjd")

		if PRN["#" set PRN=$P(PRN,"#",2)

		if 'DR,ITC1=0,PRN>0 do {
			set DR=1
			set $P(XDEP05,"|",1)=DATE
			set $P(XDEP05,"|",2)=PRN
		}
		else  if 'CR,ITC1=1,PRN>0 do {
			set CR=1
			set $P(XDEP05,"|",3)=DATE
			set $P(XDEP05,"|",4)=PRN
		}
	}
		
	quit XDEP05

	
public XDEP07(Number CID)

	/*
	The function is used to compute DEP.XDEP07 field
	
	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Earnings Analysis Info	/TYP=String
	*/
	
	type String XDEP07
	
	do CMP^PABOD

	quit XDEP07

		
public XDEP08(Number CID)

	/*
	The function is used to compute DEP.XDEP08 field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Secondary CIFs
	
	This computed is referenced by SC1,SC2 and SC3 to return first three
	related CIFs.
	*/
	
	type Number CNT
	type String XDEP08=""
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)

	set CNT=1
	 
	type DbSet ds=Db.selectDbSet("RELCIF","CID=:CID") 

	while ds.next() do { if CNT>3 quit
	 
		type RecordRELCIF relcif=ds.getRecord("RELCIF")
		if '(relcif.acn=dep.acn) do {
			set XDEP08.piece("|",CNT)=relcif.acn
			set CNT=CNT+1
			}
		}

	quit XDEP08

		
public XDEP10(Date FD,Date ODT,Number CID)

	/*
	Computed value for computed data item XDEP10
	The function is used to compute DEP.XDEP10 field
	
	ARGUMENTS:
	. FD		Service Charge - Last Date	/REQ/NONULL/MECH=VAL
	. ODT		Date Account Opened		/REQ/NONULL/MECH=VAL
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Service Charge Info		/TYP=String
	*/
	
	type Number ER=0
	type String ET,RM,XDEP10
	
	do ACBSC^UAVB1(FD,ODT)
	if ER quit ""

	quit XDEP10


public SWPINVB(Number CID)

	/*
	The function is used to compute DEP.SWPINVB field.
	
	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Total invested balances	/TYP=T
	*/

	type String SWPINVB=0
	
	type ResultSet deprs=Db.select("DEP.BAL","DEP,DEP101","DEP.CID=DEP101.ICID AND DEP101.CID=:CID")
	while deprs.next() set SWPINVB=SWPINVB+deprs.getCol(1)

	quit SWPINVB

	
public SWPVAL(Number SCID)

	/*
	Define attributes of sweep accounts associated with investment account
	SCID is the account number of the identified sweep account
	The function is used to compute DEP102.SWPVAL field
	
	ARGUMENTS:
	. SCID		Sweep Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Computed Sweep Account Values	/TYP=T
	*/

	type String return=""
	type RecordDEP dep=Db.getRecord("DEP","CID=:SCID",1)

	set return.piece("|",1)=dep.swpt
	set return.piece("|",2)=dep.title1
	set return.piece("|",3)=dep.type
	set return.piece("|",4)=dep.bal
	
	quit return

	
public CD(Date CCLD)

	/*
 	Current Dormant
	
	ARGUMENTS:
	. CCLD		Customer Contact - Last Date	/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ Current Dormant				/TYP=Boolean
	*/
	
	quit $S((CCLD+CUVAR.drmt)'>%SystemDate:1,1:0)
		

public EXDT(Number CID)

	/*
	Expiration Date The function is used to compute DEP.EXDT field
	
	ARGUMENTS:
	. CID		   Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ Expiration Date				/TYP=Date
	*/
	
	type String EXPDT
	
	type ResultSet rs=Db.select("EXPDT","HLD7","CID=:CID","EXPDT DESC") 
	if rs.isEmpty() set EXPDT=""
	else  set EXPDT=rs.next() set EXPDT=rs.getCol("EXPDT")
	
	quit EXPDT

		
public IDF(Number IRN,String IACM)

	/*
	Interest - Daily Factor, the function is used to compute DEP.IDF field
	
	ARGUMENTS:
	. IRN		Nominal Interest Rate		/REQ/NONULL/MECH=VAL
	. IACM		Interest Accrual Calc Method	/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Interest - Daily Factor		/TYP=Number
	*/
	
	quit IRN/$S(IACM.extract(2):36500,1:36000)

	
public NOTES(Number CID)

	/*    
	Account Notes on File Flag.
	The function is used to compute DEP.NOTES field.
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Account Notes on File		/TYP=Boolean
	*/
	
	type ResultSet rs=Db.select("CID","NOTES","FILE='ACN' AND CID=:CID")

	quit 'rs.isEmpty()


public ODFACN(Number CID)

	/*
	Overdraft Account, the function is used to compute DEP.ODFACN field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Overdraft Account 		/TYP=String
	*/
	
	type Number ODACN = ""
	
	type ResultSet rs = Db.select("ODACN", "DEPODP", "CID=:CID", "ODACN ASC")
	
	if rs.next() set ODACN = rs.getCol("ODACN")
	
	quit ODACN

		
public PATUF(Number CID)

	/*
 	Preauthorized Transfer Use Flag
	The function is used to compute DEP.PATUF field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Preauthorized Transfer Use Flag  /TYP=Boolean
	*/
	
	type ResultSet rs=Db.select("CID","PAT","CID=:CID")

	quit 'rs.isEmpty()
	
	
public RATS(Number IRATYP)

	/*
	Retirement Account Type (Short)
	The function is used to compute DEP.RATS field
	
	ARGUMENTS:
	. IRATYP	RPA Type			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Retirement Account Type (Short)	/TYP=T
	*/
	
	type RecordSTBLIRA stblira=Db.getRecord("STBLIRA","IRA=:+IRATYP",1)

	quit stblira.mnemonic
		

public UIDCID(Number ACN)	/*
	
	Account Owned By User
	The function is used to compute DEP.UIDCID field
	
	ARGUMENTS:
	. ACN		Customer Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Account Owned By User		/TYP=Boolean
	*/
	
	type RecordSCAU scau=Db.getRecord("SCAU","UID=:%UserID")

	quit ACN=scau.acn

		
public TOTINTAV(Number CID)	/*

	Total Interest Available
	The function is used to compute DEP.TOTINTAV field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Total Interest Available	/TYP=Number
	*/
	
	type Number IAF,INTAVL,INTAVLNCR,INTAVLR,INTPRIOR
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)

	set IAF=dep.iaf
	if +IAF=0 quit 0
	
	set INTPRIOR=dep.intprior
	set INTAVLR=dep.intavlr
	set INTAVL=dep.intavl		
	set INTAVLNCR=dep.intavlncr
	
	if IAF=2 quit +INTAVLNCR
	if IAF=1,INTAVLR'=2 quit +INTAVL
	if IAF=1,INTAVLR=2 quit (INTAVL+INTPRIOR)
	
	quit 0

	
public ODUNAMT(Number CID)	// Public; Unauthorized overdraft amount
	/*
	   The function is used to compute DEP.ODUNAMT field
	
	   ARGUMENTS:
	   . CID		   Account Number /REQ/NONULL/MECH=VAL
	
	   RETURNS:
	   . $$ Unauthorized Overdraft Amount /TYP=$
	
	   EXAMPLE:
	   W $$ODUNAMT^DECDI(100)
	*/

	type Date ODEXP
	type Number BAL,ODLIM
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	// Use Collected Balance if IRCB=3		; ABS 08/17/01

	if dep.ircb=3 set BAL=dep.balcol
	else  set BAL=dep.bal

	set ODEXP=dep.odexp
	set ODLIM=-dep.odlim

	if BAL>0!(ODEXP="") quit 0
	if ODEXP<%SystemDate quit -BAL
	if BAL<ODLIM quit ODLIM-BAL
	
	quit 0

	
public PML(Number CID)	// Public; Send Promotional Mail
	/*
	   The function is used to compute DEP.PML field
	
	   ARGUMENTS:
	   . CID	 Account Number 	/REQ/NONULL/MECH=VAL
	
	   RETURNS:
	   . $$ Send Promotional Mail  		/TYP=L
	
	*/
	
	type Number PML
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	if dep.mf="" quit 0

	type RecordUTBLMF utblmf=Db.getRecord("UTBLMF","MF=:dep.mf")
	set PML=utblmf.promo

	quit PML=(+PML)

		
public IRATYP(Number IRATYP)	// Return IRA Type description from STBLIRA
	
	type RecordSTBLIRA stblira=Db.getRecord("STBLIRA","IRA=:IRATYP")

	quit stblira.desc
	
	
public COMBAL(Number DCID)	//Combined Balance Indicator
	/*
	   The function is used to compute DEP.COMBAL field
	
	   ARGUMENTS:
	   . DCID		   Account Number	/REQ/NONULL/MECH=VAL
	
	   RETURNS:
	   . $$  Combined Balance Indicator       /TYP=$
	
	   EXAMPLE:
	   W $$COMBAL^DECDI(100)
	*/

	type Number CBCID
	
	type ResultSet rs=Db.select("CBCID","DEPCBAL","CID=:DCID") 
	if rs.isEmpty() set CBCID=""
	else  set CBCID=rs.next() set CBCID=rs.getCol("CBCID")
	
	if CBCID="" quit 0

	quit 1
	

public INTYLD(Number CID)	/* Calculate Effective Annual Yield for DEP Accounts
	
	ARGUMENTS:
	
	   . CID		Account Number		/REQ/NONULL/MECH=VAL
	
	   RETURNS:
	   . $$ 		Effective Annual Interest Yield /TYP=Number
	*/
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	type Number ER=0
	type Date MDT,NJD
	type String AF,E,FIN(),I6,IACM,ICF,IPF,IRN,RM,SVFRE,TRM,X,XFRE

	set ICF=dep.icf
	set IACM=dep.iacm
	set IRN=dep.irn
	set AF=dep.intaf
	set IPF=dep.ipf
	set TRM=dep.trm
	set MDT=dep.mdt

 	set FIN(5)=IRN
	set FIN(10)=%SystemDate
	set FIN(20)=IACM
	
	if ICF="" set ICF=IPF
	if ICF="" do {
		if TRM=""!(MDT="") set ICF="1YA" quit
		set ICF=TRM_"A"_(+MDT.day())
		set X=ICF do EDT^UFRE if ER set ICF="1YA"
		}

	set NJD=$$NJD^UFRE(TJD,ICF,.AF) quit:ER 0
	if AF'>1 set ICF="1YA"

	if Db.isDefined("USRFRE","ICF") do {
		type RecordUSRFRE usrfre=Db.getRecord("USRFRE","UFRE=:ICF")
		set XFRE=usrfre.fre
		if XFRE'="" set ICF=XFRE
		else  do {
			if AF>52 set ICF=$$^SCARND((365/AF),,,,0)_"DA"
			else  if AF>12 set ICF=$$^SCARND((52/AF),,,,0)_"WA"
			else  set ICF=$$^SCARND((12/AF),,,,0)_"MA1"
			}
		}

	if +ICF=0 set ICF=1_ICF
	set FIN(111)=ICF
	do IRNI^DEPMOD(ICF)

	quit $$^SCARND($$EAY^DEPMOD,,,,5)	

	
public AVB(Number CID,Number OFFSET)	/* Returns the Average Monthly Balance

	ARGUMENTS:	
	. CID			Account Number
	
	. OFFSET		The number of months prior to the effective dated
				month that the average balance is being calculated for.
	
	RETURNS:
	
	. $$			The average monthly balance for the given month.

	NOTE:  Use cache to improve performance when calculation called from
	       batch processing for commissions, etc.
	*/
	
	type public String cache(,)

	type Date DAT
	type Number DDBAL,DIM,MON

	// Re-initialize cache if not today's
	if (cache("AVB^DEPCDI").get() <> %SystemDate) do {
		kill cache("AVB^DEPCDI")
		set cache("AVB^DEPCDI") = %SystemDate
	}

	// Use cache if available
	if 'cache("AVB^DEPCDI", OFFSET).get().isNull() do {
		set DAT = cache("AVB^DEPCDI", OFFSET).piece("|", 1)
		set MON = cache("AVB^DEPCDI", OFFSET).piece("|", 2)
		set DIM = cache("AVB^DEPCDI", OFFSET).piece("|", 3)
	}

	// Otherwise, calculate values and save to cache
	else  do {
		// Set the month and the days in that month
		set DAT = $$ADDMJD^SCADAT(%SystemDate, -OFFSET)
		set MON = DAT.month()
		set DIM = $$NODM^SCADAT(DAT,1)
		set cache("AVB^DEPCDI", OFFSET) = DAT_"|"_MON_"|"_DIM
	}

	// Get the actual dollar days balance and calculate the average balance
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	
	if OFFSET=0 set DDBAL=dep.ddbalcur
	else  if MON=1 set DDBAL=dep.ddbal1
	else  if MON=2 set DDBAL=dep.ddbal2
	else  if MON=3 set DDBAL=dep.ddbal3
	else  if MON=4 set DDBAL=dep.ddbal4
	else  if MON=5 set DDBAL=dep.ddbal5
	else  if MON=6 set DDBAL=dep.ddbal6
	else  if MON=7 set DDBAL=dep.ddbal7
	else  if MON=8 set DDBAL=dep.ddbal8
	else  if MON=9 set DDBAL=dep.ddbal9
	else  if MON=10 set DDBAL=dep.ddbal10
	else  if MON=11 set DDBAL=dep.ddbal11
	else  if MON=12 set DDBAL=dep.ddbal12
	else  set DDBAL=0
 
	quit $J(DDBAL/DIM,0,2)		      // Dollar Days Balance / Days in Month

		
public MEBAL(Number CID,Number OFFSET)	// Returns the Month End Balance
	/*
	   Arguments:
	
	   . CID	 Account Number
	
	   . OFFSET      The number of months prior to the effective dated
			 month that the month end balance is being calculated
			 for.
	
	   Returns
	
	   . MEBAL	 The average month balance for the given month.
	*/	

	type Date DAT
	type Number MEBAL,MON
	
	// Get the julian date for the desired month
	set DAT=$$ADDMJD^SCADAT(%SystemDate,-OFFSET)
	
	// Set the month and the days in that month
	set MON=+DAT.month()
	
	// Get the actual month end balance
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if MON=1 set MEBAL=dep.mebal1
	else  if MON=2 set MEBAL=dep.mebal2
	else  if MON=3 set MEBAL=dep.mebal3
	else  if MON=4 set MEBAL=dep.mebal4
	else  if MON=5 set MEBAL=dep.mebal5
	else  if MON=6 set MEBAL=dep.mebal6
	else  if MON=7 set MEBAL=dep.mebal7
	else  if MON=8 set MEBAL=dep.mebal8
	else  if MON=9 set MEBAL=dep.mebal9
	else  if MON=10 set MEBAL=dep.mebal10
	else  if MON=11 set MEBAL=dep.mebal11
	else  if MON=12 set MEBAL=dep.mebal12
	else  set MEBAL=""

	quit MEBAL

	
public TODCNT(Number CID)	// GCR Total Overdraft Counter
	/*
	   The total number of times an account was in an overdraft position
	   during the previous 24 monthly scoring cycles.  These counters are
	   updated if an account meets the definition of overdraft as defined
	   by GCR requirements.
	*/

	type Number CNT
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set CNT=dep.odcnt1
	set CNT=CNT+dep.odcnt2
	set CNT=CNT+dep.odcnt3
	set CNT=CNT+dep.odcnt4
	set CNT=CNT+dep.odcnt5
	set CNT=CNT+dep.odcnt6
	set CNT=CNT+dep.odcnt7
	set CNT=CNT+dep.odcnt8
	set CNT=CNT+dep.odcnt9
	set CNT=CNT+dep.odcnt10
	set CNT=CNT+dep.odcnt11
	set CNT=CNT+dep.odcnt12
	set CNT=CNT+dep.odcnt13
	set CNT=CNT+dep.odcnt14
	set CNT=CNT+dep.odcnt15
	set CNT=CNT+dep.odcnt16
	set CNT=CNT+dep.odcnt17
	set CNT=CNT+dep.odcnt18
	set CNT=CNT+dep.odcnt19
	set CNT=CNT+dep.odcnt20
	set CNT=CNT+dep.odcnt21
	set CNT=CNT+dep.odcnt22
	set CNT=CNT+dep.odcnt23
	set CNT=CNT+dep.odcnt24

	quit CNT

		
public GCRLBAL(Number CID)	/* GCR Liability Package Balance

	   The six-month average GCR Liability Package balance on an account
	   used in GCR calculations for monthly scoring.  Accounts included in
	   the banking packages are provided through an interface from the
	   statement driver and are current as of the last cycle date.  The
	   monthly GCR scoring process uses the imported monthly average ledger
	   balances to determine a six-month average GCR Liability Package
	   Balance.
	*/

	type Date FD,LSDATE,TD
	type Number BCNT,CNT,GCRLBAL,XCID

	set XCID=CID
	set (BCNT,CNT,GCRLBAL,LSDATE)=0

	set (TD,FD)=%SystemDate

	type ResultSet rs=Db.select("SDATE","GCRPKG","CID=:XCID AND SDATE <=:TJD","SDATE DESC") 
	while (rs.next()&(CNT<>6)) do { 
		if CNT=0 set TD=rs.getCol("SDATE"),FD=rs.getCol("SDATE")
		else  set FD=rs.getCol("SDATE")
		if LSDATE'=rs.getCol("SDATE") do {
			set LSDATE=rs.getCol("SDATE")
			set CNT=CNT+1
			}
		}
	
	type ResultSet rs2=Db.select("GCRAVGBAL","GCRPKG","CID=:XCID AND SDATE BETWEEN :FD AND :TD") 

	while rs2.next() do { 
		set BCNT=BCNT+1
		set GCRLBAL=GCRLBAL+rs2.getCol("GCRAVGBAL")
		}

	if BCNT set GCRLBAL=GCRLBAL/BCNT

	quit $J(GCRLBAL,0,2)
	
	
public GCRLDBAL(Number CID)	/* GCR Liability Package Daily Balance

	   The daily GCR Liability Package balance on an account used in GCR
	   calculations for daily scoring.  Accounts included in the banking
	   packages are provided through an interface from the statement
	   driver and are current as of the last cycle date. The daily GCR
	   scoring process uses the account balances of the accounts found
	   in the GCR Liability package to determine the daily GCR Liability
	   Package Balance.
	*/

	type Date XSDATE,YDATE
	type Number GCRLBAL=0

	set YDATE=%SystemDate+1
	type ResultSet xsdate1=Db.select("SDATE","GCRPKG","CID=:CID AND SDATE<:YDATE","SDATE DESC") 
	
	if xsdate1.isEmpty() set XSDATE=""
	else  set XSDATE=xsdate1.next() set XSDATE=xsdate1.getCol("SDATE")
	if XSDATE.isNull() quit 0
	
	type ResultSet rs=Db.select("LCID","GCRPKG","CID=:CID AND SDATE=:XSDATE") 

	while rs.next() do {
		type RecordDEP dep=Db.getRecord("DEP","CID=:rs.getCol(""LCID"")")
		set GCRLBAL=GCRLBAL+dep.bal
		}

	quit GCRLBAL
	
	
public DCL(Number CID)	// Deposit Coverage Line
	/*
	   Will order through the donor cross reference file to calculate the
	   available balances on deposit product accounts.  Also will convert
	   the donor and recipient currency if they differ.
	*/
	
	type Number ER=0
	type Number BALAVL,TOTBAL
	type String CLS,DCRCD,RCRCD
	
	set TOTBAL=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	set RCRCD=dep.crcd
	
	type ResultSet rs=Db.select("DONACT","DEPDONOR","CID=:CID") 

	while rs.next() do { 

		type RecordACN acn=Db.getRecord("ACN","CID=:rs.getCol(""DONACT"")")

		set CLS=acn.cls
		set DCRCD=acn.crcd

		if CLS="L" do {
			
			type RecordLN ln = {RecordLN}acn
			set BALAVL=ln.avlbal
			}

		if CLS="D" do {
			
			type RecordDEP dep = {RecordDEP}acn
	   		set BALAVL=dep.balavl
			}

		if RCRCD'=DCRCD do CAMT^CRCDUTL(DCRCD,RCRCD,.BALAVL)
		set TOTBAL=TOTBAL+BALAVL
		}

	quit TOTBAL

	
public GCRAVL(Number CID)	/* GCR Available Balance
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	*/

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	quit dep.gcrcv-dep.gcrrsk

	
public SECAVL(Number CID)	/* Securities Available Balance
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	*/

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	quit dep.seccov-dep.secrsk
	
	
public NEGBAL(Number CID)	/* Negative Balance

	The function is used to compute DEP.NEGBAL field
	
	ARGUMENTS:	
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Negative Balance       		/TYP=Number
	*/

	type Date ODEXP
	type Number BAL,NEGBAL,ODLIM	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set BAL=dep.bal
	set ODLIM=-dep.odlim
	set ODEXP=dep.odexp
	set NEGBAL=0
	
	if BAL<0 set NEGBAL=BAL			// JMH - 02/09/01
	if (BAL<ODLIM),((ODEXP="")!(ODEXP>%SystemDate)) set NEGBAL=ODLIM	// JMH - 02/09/01

	quit -NEGBAL
	
	
public SDDEP(Number CID)	// Same Day Future Deposit Coverage
	
	type Number ER=0
	type Number ALCAMT,CHKHLD,COVONE,COVTHREE,COVTWO,DCL,GCR,NET,SDAVL,SDFUDEP,SEC,UNALHLD
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set CHKHLD=dep.chkhld			// Total Check hold amount
	set ALCAMT=dep.alcamt			// Total Allocated amount
	set GCR=dep.gcravl			// GCR available
	set SDAVL=dep.sdavl			// Same Day Available
	set NET=dep.netdep			// Net Same Day Deposit
	set DCL=dep.dcl				// DCL available
	set SEC=dep.secavl			// Securities available
	set UNALHLD=CHKHLD-ALCAMT	      	// Uncollected funds not withdrawn
	set COVONE=GCR-UNALHLD		 	// Difference of GCR Avail. and Uncollected funds not withdrawn
	set COVTWO=SDAVL-NET		   	// Difference of Same Day Avail. and Net Same Day Deposit
	
	if COVONE<COVTWO set COVTHREE=COVONE+DCL+SEC
	else  set COVTHREE=COVTWO+DCL+SEC
	
	if COVTHREE>0 set SDFUDEP=COVTHREE
	else  set SDFUDEP=0

	quit SDFUDEP

	 	
public NSDDEP(Number CID)	// Non-Same Day Future Deposit Coverage
	
	type Number ER=0
	type Number ALCAMT,CHKHLD,DCL,GCRAVL,NONSD,NSD1,SECAVL,UNALHLD
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set CHKHLD=dep.chkhld			// Total Check hold amount
	set ALCAMT=dep.alcamt			// Total Allocated amount
	set GCRAVL=dep.gcravl			// GCR available
	set DCL=dep.dcl				// DCL available
	set SECAVL=dep.secavl			// Securities available
	
	set UNALHLD=CHKHLD-ALCAMT		// Uncollected funds not withdrawn
	set NSD1=(GCRAVL-UNALHLD)+DCL+SECAVL 	// Difference of GCR avail. and Uncollected funds plus DCL and SEC avail.
	if NSD1>0 set NONSD=NSD1
	else  set NONSD=0

	quit NONSD
	
public TRMD(Number CID)	// Calculate the Term in Days

	type Date DLR,ODT,MDT,TRMD
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set DLR=dep.dlr
	set MDT=dep.mdt
	set ODT=dep.odt

	if MDT="" quit ""
	if DLR="" set TRMD=MDT-ODT
	else  set TRMD=MDT-DLR

	quit TRMD


public TLSEQ(Number CID)	// Last History Tran Sequence

        /*
        The function is used to compute [DEP]TLSEQ field
 
        Arguments:
                . CID  Account Number                   /TYP=N/REQ/MECH=VAL
        */

	quit Db.currVal("HIST","CID")

	
public TSEQ(Number CID)	// Next History Trans Sequence

        /*
        The function is used to compute [DEP]TSEQ field
 
        Arguments:
                . CID  Account Number                   /TYP=N/REQ/MECH=VAL
        */

	quit Db.nextVal("HIST","CID")

	
public TYPEDES(TYPE)	// Product Type Description

	type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:TYPE")

	quit proddftd.des


public LNMBAL1(Number CID)	// Calculate Minimum Balance - Loan Persentage 1
	/*
	   The function is used to compute DEP.LNMBAL1 field
	
	   ARGUMENTS:
	   . CID		   Account Number	/REQ/NONULL
	
	   RETURNS:
	   . $$ Minimum Balance - Loan Persentage 1      /TYP=$
	
	   EXAMPLE:
	   W LNMBAL1^DEPCDI(1515) 
	*/

	type String LNBALPC1,LNMBAL1,LNPFBAL

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:dep.type")

	set LNBALPC1=prodctl.lnbalpc1
	set LNPFBAL=$$PLGDEP^DEPCDI(CID)
	set LNMBAL1=(LNPFBAL*LNBALPC1)/100
	set LNMBAL1=$$^SCARND(LNMBAL1,,2)

	quit LNMBAL1	


public LNMBAL2(Number CID)    // Calculate Minimum Balance - Loan Persentage 2
	/*
	   The function is used to compute DEP.LNMBAL2 field
 
	   ARGUMENTS:
	   . CID		   Account Number	/REQ/NONULL
 
	   RETURNS:
	   . $$ Minimum Balance - Loan Persentage 2      /TYP=$
 
	   EXAMPLE:
	   W LNMBAL2^DEPCDI(1515)
	*/

	type Number LNBALPC2,LNMBAL2,LNPFBAL

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:dep.type")

	set LNBALPC2=prodctl.lnbalpc2
	set LNPFBAL=$$PLGDEP^DEPCDI(CID)
	set LNMBAL2=(LNPFBAL*LNBALPC2)/100
	set LNMBAL2=$$^SCARND(LNMBAL2,,2)

	quit LNMBAL2


public PLGDEP(Number CID)	// Calculate Collaterialized Loan Balance
	/*
	   The function is used to compute DEP.PLGDEP field
	
	   ARGUMENTS:
	   . CID	   Account Number		/REQ/NONULL
	  
	   RETURNS:
	   . $$  	Collaterialized Loan Balance	/TYP=$
	
	*/

	type Number LNBAL,TOTBAL
	type String CID2,COLL,CRCD

	set TOTBAL=0

	type ResultSet rs1=Db.select("COLL,CRCD","COL","COLACN=:CID")

	while rs1.next() do {

		set COLL=rs1.getCol("COLL")
		set CRCD=rs1.getCol("CRCD")

		type ResultSet rs2=Db.select("CID","LNCOL","CID=:COLL")

		while rs2.next() do {

			set CID2=rs2.getCol("CID")
			type RecordLN ln=Db.getRecord("LN","CID=:CID2")

			set LNBAL=ln.bal

			// If LN currency code not equal DDA currency code,
			// transfer to DDA currency
			if ln.crcd'=CRCD do CAMT^CRCDUTL(ln.crcd,CRCD,.LNBAL)
			set TOTBAL=TOTBAL+LNBAL
			}
		}

		quit TOTBAL


public PINV(Number CID,Number MAXCHK,Number MAXTRN)

	/*
	Periods in violation of Regulation D
	
	The function is used to compute DEP.PINV field
	
	 ARGUMENTS:
		. CID		Account Number	/REQ/NONULL/MECH=VAL

		. MAXCHK	Max checks	/NOREQ/MECH=VAL

		. MAXTRN	Max transaction	/NOREQ/MECH=VAL	
	
	 Note that MAXCHK and MAXTRN default values are standard Reg D values,
	 but can be overridden if passed in as paramters.
	*/

	type String PINV=0

	if 'MAXCHK.get() set MAXCHK=3
	if 'MAXTRN.get() set MAXTRN=6

	//     Get the Check violation totals for twelve periods

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if dep.mmdac1>MAXCHK!(dep.mmdat1>MAXTRN) set PINV=PINV+1
	if dep.mmdac2>MAXCHK!(dep.mmdat2>MAXTRN) set PINV=PINV+1
	if dep.mmdac3>MAXCHK!(dep.mmdat3>MAXTRN) set PINV=PINV+1
	if dep.mmdac4>MAXCHK!(dep.mmdat4>MAXTRN) set PINV=PINV+1
	if dep.mmdac5>MAXCHK!(dep.mmdat5>MAXTRN) set PINV=PINV+1
	if dep.mmdac6>MAXCHK!(dep.mmdat6>MAXTRN) set PINV=PINV+1
	if dep.mmdac7>MAXCHK!(dep.mmdat7>MAXTRN) set PINV=PINV+1
	if dep.mmdac8>MAXCHK!(dep.mmdat8>MAXTRN) set PINV=PINV+1
	if dep.mmdac9>MAXCHK!(dep.mmdat9>MAXTRN) set PINV=PINV+1
	if dep.mmdac10>MAXCHK!(dep.mmdat10>MAXTRN) set PINV=PINV+1
	if dep.mmdac11>MAXCHK!(dep.mmdat11>MAXTRN) set PINV=PINV+1
	if dep.mmdac12>MAXCHK!(dep.mmdat12>MAXTRN) set PINV=PINV+1

	quit PINV


public TNMPMTS(Number CID) 

	/*
	Total number of payments to all budgets under one account
	
	The function is used to compute DEP.TNMBPMT field
	
	 ARGUMENTS:
	 . CID		   Account Number	/REQ/NONULL/MECH=VAL
	
	RETURNS: 
	. $$ TNMPMTS	      /TYP=N
	
	 EXAMPLE
	 W $$TNMPMTS^DEPCDI(100)
	*/

	// find out if budget processing is on, get budget year start date

	type Number TNMPMTS=0
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if 'dep.bgtpro quit 0
		
	//select budget payments from all budget codes for current
	//budget year and total them

	type ResultSet rs=Db.select("BGTPMTS","BUDGET","CID=:CID AND BGTYRSD=:dep.bgtyrsd")

	while rs.next() set TNMPMTS=TNMPMTS+rs.getCol("BGTPMTS")

	quit TNMPMTS


public TOTAAMT(Number CID) /* Total Annual Budget Amount for all budget codes

	The function is used to compute DEP.TOTAAMT field
	
	ARGUMENTS:
	. CID		Account Number		/REQ/NONULL/MECH=VAL
	
	RETURNS: 
	. $$		TOTAAMT			/TYP=Number
	*/

	type Number TOTAAMT=0

	// find out if budget processing is on, get budget year start date

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

 	if 'dep.bgtpro quit 0

	type ResultSet rs=Db.select("BGTAMTCY","BUDGET","CID=:CID AND BGTYRSD=:dep.bgtyrsd")

	while rs.next() set TOTAAMT=TOTAAMT+rs.getCol("BGTAMTCY")

	quit TOTAAMT


public TOTCONTR(Number CID) /* Total contributions (deposits) for the budget yr.
	
	The function is used to compute DEP.TOTCONTR field

	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		TOTCONTR	       		/TYP=NUmber

	*/

	type Date BGTYRSD,EFD
	type Number TOTCONTR=0
	type String ETC,PCFD34(),TAMT

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

 	if 'dep.bgtpro quit 0

	set BGTYRSD=dep.bgtyrsd

	type DbSet ds=Db.selectDbSet("HIST","CID = :CID and TAMT is not NULL and TJD >= :BGTYRSD and ITC1 = 1 and +ITC4 = 0")

	while ds.next() do {

		type RecordHIST hist=ds.getRecord("HIST")

		set EFD=hist.efd if EFD="" set EFD=hist.tjd
		if EFD<BGTYRSD quit

		set TAMT=hist.tamt
 		if TAMT.piece("#",3) quit	// Accrued Interest Adjustment
		if TAMT.piece("#",6) quit	// Negative Accrued Authorized	
		if TAMT.piece("#",11) quit 	// Negative Accrued Unauthorized

		set ETC=hist.etc

		if 'PCFD34(ETC).data() do {
			type RecordTRN trn=Db.getRecord("TRN","ETC=:hist.etc")
			set PCFD34(ETC)=trn.pcfd34
			}

		if 'PCFD34(ETC) set TOTCONTR=TOTCONTR+TAMT
		}

	quit TOTCONTR


public TOTMSC(Number CID)     /* Total Miscellaneous Cash Contributions

	The function is used to compute DEP.TOTMSC field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	*/	

	type Number TOTMSC=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

 	if 'dep.bgtpro quit 0

	type ResultSet rs=Db.select("MISCCSH","BUDGET","CID=:CID AND BGTYRSD=:dep.bgtyrsd")
	while rs.next() set TOTMSC=TOTMSC+rs.getCol("MISCCSH")
 
	quit TOTMSC


public TOPAAMT(Number CID)	/* Total of all payments made from budget account
	
	The function is used to compute DEP.TOPAAMT field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	*/

	type Number TOPAAMT=0
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

 	if 'dep.bgtpro quit 0
 
	type ResultSet rs=Db.select("AMTPD","BUDGET","CID=:CID AND BGTYRSD=:dep.bgtyrsd")

	while rs.next() set TOPAAMT=TOPAAMT+rs.getCol("AMTPD")
 
	quit TOPAAMT


public LNINAR(Number CID)	/* Related Interest arrears Balance for budget accounts

	The function is used to compute DEP.RELINAR field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	*/

	type Number LNINAR=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	type DbSet ds=Db.selectDbSet("RELCIF","ACN=:dep.acn")

	while ds.next() do {

		type RecordRELCIF relcif=ds.getRecord("RELCIF")
		type RecordACN acn=Db.getRecord("ACN","CID=:relcif.cid")

		if acn.cls="L" do {
			
			type RecordLN ln = {RecordLN}acn
			set LNINAR=LNINAR+ln.unin
			}
		}

	quit LNINAR


public RELDBAL(Number CID)    /* Related Deposit Balance for budget accounts

	The function is used to compute DEP.RELDBAL field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Related Deposit Balance   	/TYP=Number
	*/
	
	type Number RELDBAL=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
 
	type DbSet ds=Db.selectDbSet("RELCIF","ACN=:dep.acn")

	while ds.next() do {

		type RecordRELCIF relcif=ds.getRecord("RELCIF")
		type RecordACN acn=Db.getRecord("ACN","CID=:relcif.cid")

		if acn.cls="D" set RELDBAL=RELDBAL+acn.bal
		}
 
	quit RELDBAL


public RELLNARR(Number CID)	/* Related Loan arrears Balance for budget accounts

	The function is used to compute DEP.RELLNARR field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		RELLNARR				/TYP=Number

	*/

	type Number RELLNARR=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	type DbSet ds=Db.selectDbSet("RELCIF","ACN=:dep.acn")

	while ds.next() do {

		type RecordRELCIF relcif=ds.getRecord("RELCIF")
		type RecordACN acn=Db.getRecord("ACN","CID=:relcif.cid")

		if acn.cls="L" do {
			
			type RecordLN ln = {RecordLN}acn
			set RELLNARR=RELLNARR+ln.unpr
			}
		}

	quit RELLNARR


public SHRBAL(Number CID)	//Related Share Balance for budget accounts
	/* The function is used to compute DEP.SHRBAL field
	
	ARGUMENTS:
	. CID		   Account Number	/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. SHRBAL	       Related Share Balance   /TYP=N
	
	EXAMPLE
	W $$SHRBAL^DEPCDI(100)

	*/
	
	type Number SHRBAL=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	if dep.shareacct set SHRBAL=SHRBAL+dep.bal

	type DbSet ds=Db.selectDbSet("RELCIF","ACN=:dep.acn and CID <> :CID")

	while ds.next() do {

		type RecordACN acn=Db.getRecord("ACN",":ds.getRecord().cid")

		if acn.cls="D" do {
			
			type RecordDEP dep = {RecordDEP}acn
			if dep.shareacct set SHRBAL=SHRBAL+dep.bal
			}
		}

	quit SHRBAL


public RELLBAL(Number CID)    /* Related Loan Balance for budget accounts
	
	ARGUMENTS:
	CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	RELLBAL		Related Loan Balance		/TYP=Number
	*/	

	type Number RELLBAL=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	type DbSet ds=Db.selectDbSet("RELCIF","ACN=:dep.acn")

	while ds.next() do {

		type RecordRELCIF relcif=ds.getRecord("RELCIF")
		type RecordACN acn=Db.getRecord("ACN","CID=:relcif.cid")

		if acn.cls="L" set RELLBAL=RELLBAL+acn.bal
		}

	quit RELLBAL
 

public TRANCHG(Number CID)    /* Total transaction charges assessed during a budget year

	The function is used to compute DEP.TRANCHG field
 
	ARGUMENTS:
	CID		Account Number			/REQ/NONULL/MECH=VAL
 
	RETURNS:
	. $$		Transaction Charges   		/TYP=Number
	*/

	type Number TRANCHG=0

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

 	if 'dep.bgtpro quit 0

	type ResultSet rs=Db.select("FEEANL,FEECHG","SRV","CID=:CID AND SCND>:dep.bgtyrsd")

	while rs.next() do {
		set TRANCHG=rs.getCol("FEEANL")+rs.getCol("FEECHG")+TRANCHG	
		}
	
	quit TRANCHG

	
public PEDCNTR(Number CID)     /* Estimated periodic contribution needed

	The function is used to compute DEP.PEDCNTR field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		PEDCNTR				/TYP=Number
	*/	

	type Date BGTYRND,BGTYRSD
	type Number ER=0
	type Number BGTCONTR,PEDCNTR,TOTAAMT
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if 'dep.bgtpro quit 0

	set BGTYRSD=dep.bgtyrsd
	set BGTYRND=dep.bgtyrnd
	set BGTCONTR=dep.bgtcontr
	set TOTAAMT=dep.totaamt
  
	set PEDCNTR=0

	if TOTAAMT do {

		type Number COUNT=0
		type Date ENDDT,NJD

		set ENDDT=BGTYRND
		set NJD=BGTYRSD

		for  set NJD=$$NJD^UFRE(NJD,BGTCONTR) quit:ER!(NJD>ENDDT)  set COUNT=COUNT+1
		if COUNT set PEDCNTR=TOTAAMT/COUNT
		}

	quit PEDCNTR
	

public BGTARR(Number CID)     /* Budget Contributions Arrears
	
	The function is used to compute DEP.BGTARR field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$  Budget Contributions Arrears		/TYP=Number
	*/

	type Number ER=0

	type Date BGTYRSD,NJD
	type Number BGTARR,BGTCONTR,PEDCNTR,SCHCONTR,TOTCONTR
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if 'dep.bgtpro quit 0
  
	set BGTYRSD=dep.bgtyrsd
	set BGTCONTR=dep.bgtcontr
	set SCHCONTR=dep.schcontr
	set TOTCONTR=dep.totcontr
	set PEDCNTR=dep.pedcntr
	  
	set NJD=BGTYRSD

	for  set NJD=$$NJD^UFRE(NJD,BGTCONTR) 	quit:ER!'(NJD<%SystemDate)
	if NJD=TJD set BGTARR=SCHCONTR-TOTCONTR-PEDCNTR
	else  set BGTARR=SCHCONTR-TOTCONTR
	
	if BGTARR<0 set BGTARR=0
       	
	quit BGTARR


public BGTCON(Number CID)     /*  Scheduled Contributions To Date

	The function is used to compute DEP.BGTCON field
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$ 		Scheduled Contributions To Date	 /TYP=Number
	*/
  
	type Number ER=0

 	type Date BGTYRSD,NJD
	type Number BGTCONTR,COUNT
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if 'dep.bgtpro quit 0

	set BGTYRSD=dep.bgtyrsd
	set BGTCONTR=dep.bgtcontr
      
	set NJD=BGTYRSD

	set COUNT=0
	for  set NJD=$$NJD^UFRE(NJD,BGTCONTR) quit:ER!(NJD>%SystemDate)  set COUNT=COUNT+1	
	quit COUNT

public SCHCONTR(Number CID)     /* Scheduled Budget Contributions

	The function is used to compute DEP.BGTARR field
	 
	Arguments:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	Returns:
	. $$		Scheduled Budget Contributions	/TYP=Number
	 */

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if 'dep.bgtpro quit 0

	quit dep.pedcntr*dep.bgtcon


public BYINT(Number CID)	/* Budget Year Interest

	The function is used to compute DEP.BYINT field

	Arguments: 
	. CID		Account Number			/REQ/NONULL/MECH=VAL
 
	Returns:
	. $$ 		Budget Year Interest		/TYP=Number
 	*/

	type Date BGTYRSD,EFD
	type Number BYINT=0
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if 'dep.bgtpro quit 0

	set BGTYRSD=dep.bgtyrsd

	// Only get Interest Post or Interest/Dividend Adjustment
  
	type DbSet ds=Db.selectDbSet("HIST","CID = :CID and TAMT is not NULL and TJD>= :BGTYRSD and (+ITC4 > 0 or TSO LIKE '%INTADJ%')")

	while ds.next() do {

		type RecordHIST hist=ds.getRecord("HIST")

		set EFD=hist.efd if EFD="" set EFD=hist.tjd
		if EFD<BGTYRSD quit

		if hist.itc1 set BYINT=BYINT-hist.tamt		// Debit
		else  set BYINT=BYINT+hist.tamt			// Credit
		}

	quit BYINT


public ESCFRE(Number ECID)  /* Computed value for ESCFRE column

	This function is used to compute DEP.ESCFRE column

	Arguments:
	. ECID	   Escrow Account Number		/REQ/NONULL

	Returns:
	. $$		Payment Frequency		/TYP=String
	*/
  
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	quit $P($$ELEFRE^LNU(dep.aref,"ESC1"),"|",1)


public OVG(Number ECID)    /* Calculating Overage Amount
 
	This function is used to compute DEP.OVG column
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	. $$		Overage Amount			/TYP=Number 
	*/
 	
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit 0

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")
	if ln.apcld="" quit 0
	
	type RecordLNAPCHGE lnapchge=Db.getRecord("LNAPCHGE","APCND=:ln.apcld,CID=:dep.aref,ECID=:ECID",1)

	quit lnapchge.ovg


public AEDAPC(Number ECID)  /* Computing Analysis End Date based on Escrow Analysis PMT Change Next date.
 	
	This function is used to compute DEP.AEDAPC column
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	. $$		Analysis End Date		/TYP=Number
	*/
 
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")

	quit $$NJD^UFRE(ln.apcnd,"1YA")-1 


public AED(Number ECID)    /* Computing Analysis End Date using Off Cycle Analysis date
  
	This function is used to compute DEP.AED column
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	. $$		Analysis End Date		/TYP=Number 
	*/

	type Date AED,APCND

	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")

	set APCND=ln.apcnd

	if ln.ocaf set APCND=ln.ocadt
	if APCND=ln.apcnd set AED=$$NJD^UFRE(APCND,ln.anfre) 
	else  set AED=ln.apcnd
	if $$NJD^UFRE(APCND,"1YA")>AED set AED=$$NJD^UFRE(APCND,"1YA")
	set AED=AED-1

	quit AED


public CHKAMT(Number ECID) 

	/*
	Computed value for CHKAMT data item 

	This function is used to compute DEP.CHKAMT field
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	. $$ 		Check Amount			/TYP=Number 
	*/ 
 
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit 0

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")	 
	if ln.apcld=""  quit 0

	type RecordLNAPCHGE lnapchge=Db.getRecord("LNAPCHGE","APCND=:ln.apcld,CID=:dep.aref,ECID=:ECID",1)

	quit lnapchge.amtc


public APCBAL(Number ECID)

	/* Computing Actual Starting Balance using APCND

	This function is used to compute DEP.APCBAL field
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	. $$		Actual Starting Balance using APCND Escrow Analysis
			PMT Change Next Date 		/TYP=Number
	*/

	type Date JD
	type Number CID,CUSH,ESCPMT
	type String CUSHF,CUSHO,data,EABE,ESC,ESCFRE,LNEAM()
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit 0

	// Note:  CUSH* variables are referenced in LNEA
	set CUSH=dep.cusha
	set CUSHF=dep.cushf
	set CUSHO=dep.cusho
	set CID=ECID
	set ESCFRE=$P($$ELEFRE^LNU(dep.aref,"ESC1"),"|",1)

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")
	if ln.apcnd="" quit 0

	type RecordLNAPCHGE eabe=Db.getRecord("LNAPCHGE","APCND=:ln.apcnd,CID=:dep.aref,ECID=:ECID",1)
	set EABE("CID").piece("|",10)=eabe.ereq
	do EXEC^LNEA(ln,.eabe,dep.aref,.LNEAM,"ESC1",ln.apcnd,dep.aedapc,"02",.data)

	quit data.piece("|",3)


public BEGBAL(Number ECID)

	/*
	Computing Actual Starting Balance using OCADT
 
	This function is used to compute DEP.BEGBAL field
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	. $$ 		Actual Starting Balance using Off Cycle Analysis Date
 							/TYP=Number
	*/

	type Date APCND,JD
	type Number BEGBAL,CID,CUSH,ESCPMT
	type String AED,CUSHF,CUSHO,data,EABE,ESC,ESCFRE,LNEAM()
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	// Note:  CUSH* variables are referenced in LNEA
	set CUSH=dep.cusha
	set CUSHF=dep.cushf
	set CUSHO=dep.cusho
	set CID=ECID
	set ESCFRE=$P($$ELEFRE^LNU(dep.aref,"ESC1"),"|",1)

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")

	if ln.ocaf set APCND=ln.ocadt
	else  set APCND=""

	if APCND="" quit ""

	type RecordLNAPCHGE eabe=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:dep.aref,ECID=:ECID",1)

	set EABE("CID").piece("|",10)=eabe.ereq
	do EXEC^LNEA(ln,.eabe,dep.aref,.LNEAM,"ESC1",APCND,dep.aed,"02",.data)

	quit data.piece("|",3)


public INIDEP(Number ECID)

	/*
	Target Starting Balance
 
	This function computes DEP.INIDEP field
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	Returns:
	.$$		Target Starting Balance		 /TYP=Number
 
	*/
 
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")
	if ln.apcnd="" quit 0
	
	type RecordLNAPCHGE lnapchge=Db.getRecord("LNAPCHGE","APCND=:ln.apcnd,CID=:dep.aref,ECID=:ECID",1)

	quit lnapchge.cush-(lnapchge.lowbala-lnapchge.abal)


public NEWPMT(Number ECID)

	/*
	Total Loan Payment field
 
	This function computes DEP.NEWPMT field
 
	Arguments:
	. ECID		Escrow Account Number		/REQ/NONULL
 
	  Returns:
	. $$		Total Loan Payment		/TYP=$
 	*/

	type Date APCND
	type Number ER=0
	type Number PINC=0
	type String PMTPI
 
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")
 
	if ln.pchnd do {

		type RecordLNPTCHG lnptchg=Db.getRecord("LNPTCHG","PCHND=:dep.aref,CID=:ln.pchnd",1)
		set PINC=lnptchg.npmt
		}

	set PMTPI=ln.pmtpi
 
	/* If interest is in advance then use PINC if the dates agree.
	Otherwise, look ahead one frequency. */

	if PINC,ln.icm,ln.apcnd'<ln.pchnd set PMTPI=PINC
	else  if PINC,'ln.icm,ln.apcnd'<ln.pchnd do { if ER quit
	
		type Date NJD=$$NJD^UFRE(ln.pchnd,ln.dist1fre) if ER quit
		if ln.apcnd'<NJD set PMTPI=PINC
		}

	if ln.ocaf set APCND=ln.ocadt
	else  set APCND=ln.apcld
	if APCND="" quit 0

	type RecordLNAPCHGE lnapchge=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:dep.aref,ECID=:ECID",1)

	quit lnapchge.epmt+PMTPI	   // new loan payment

 
public BALCLG(Number CID)

	/*
	Computed value for computed data item BALCLG

	The function is used to compute DEP.BALCLG  field
 
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	   
	RETURNS:
	. $$		Combined Ledger Balance		/TYP=Number
	*/

	type Number BALCLG

	#IF CUVAR.BALCLGC=""
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	set BALCLG=dep.bal
 
	type ResultSet deprs=Db.select("DEP.BAL","DEP,DEP101","DEP.CID=DEP101.ICID AND DEP101.CID=:CID")
	while deprs.next() set BALCLG=BALCLG+deprs.getCol(1)
 
	quit BALCLG
	#ENDIF

	#IF CUVAR.BALCLGC'=""
	xecute "S BALCLG=$$^"_CUVAR.balclgc_"(CID)"
	quit BALCLG
	#ENDIF
 

public BALCCL(Number CID)

	/*
	Computed value for computed data item BALCCL

	The function is used to compute DEP.BALCCL field
 
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
 
	RETURNS:
	. $$		Combined Collected Balance	/TYP=$
	*/
 
	type Number BALCCL

	#IF CUVAR.BALCCLC=""
	quit $$^DEPBCC(CID)
	#ENDIF

	#IF CUVAR.BALCCLC'=""
	xecute "S BALCCL=$$^"_CUVAR.balcclc_"(CID)"
	quit BALCCL
	#ENDIF


public YLD30D(Number CID)

	/*
	The function is used to compute DEP.YLD30D field
 
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
 
	RETURNS:
	. $$ 		30 day yield			/TYP=Number
	*/

	type Number YLD30D

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if dep.index'="" do {

		type RecordINDEX1 index1=Db.getRecord("INDEX1","EFD=:%SystemDate,INDEX=:dep.index,RMIN=:+dep.balavl",1)
		set YLD30D=index1.yld30d
		}
	
	else  set YLD30D=""

	quit YLD30D


public YLD7D(Number CID)

	/*
	The function is used to compute DEP.YLD7D field
 
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
 
	RETURNS:
	. $$		7 day yield				/TYP=Number
	*/

	type Number YLD7D

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	if dep.index'="" do {

		type RecordINDEX1 index1=Db.getRecord("INDEX1","EFD=:%SystemDate,INDEX=:dep.index,RMIN=:+dep.balavl",1)
		set YLD7D=index1.yld7d
		}

	else  set YLD7D=""
	
	quit YLD7D


public APENDBAL(Number ECID)

	/*
	The function is used to compute DEP.APENDBAL
 
	ARGUMENTS:
	. ECID		Escrow Account Number			/REQ/NONULL
 
	RETURNS:
	. $$		Escrow End Balance using APCBAL		/TYP=Number
	*/
	
	type public RecordLNEAM lneam()
	
	type Date JD
	type Number ER=0
	type Number BAL,CID,CUSH,ESCPMT
 	type String CUSHF,CUSHO,data,EABE,ELE,ESC,ESCFRE,LNEAM()
 
	set ELE="ESC1"

	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")

	// Compute LNEAM
	if dep.aref="" quit 0

	// Note:  CUSH* variables are referenced in LNEA
	set CUSH=dep.cusha
	set CUSHF=dep.cushf
	set CUSHO=dep.cusho
	set CID=ECID
	set ESCFRE=$P($$ELEFRE^LNU(dep.aref,"ESC1"),"|",1)

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")
	if ln.apcnd="" quit 0

	type RecordLNAPCHGE eabe=Db.getRecord("LNAPCHGE","APCND=:ln.apcnd,CID=:dep.aref,ECID=:ECID",1)
	set EABE("CID").piece("|",10)=eabe.ereq

	do EXEC^LNEA(ln,.eabe,dep.aref,.LNEAM,"ESC1",ln.apcnd,dep.aedapc,"02",.data)
	if 'LNEAM.data() quit 0
	
	set ESCPMT=EABE("CID").piece("|",2)

	set JD=""
	for  set JD=$O(LNEAM(JD)) quit:JD=""  do {
		if LNEAM(JD) set LNEAM(JD).piece("|",1)=ESCPMT
		if lneam(JD).exists() do {
			set lneam(JD).pmt=ESCPMT
			do lneam(JD).save()
			}
		}

	set BAL=dep.apcbal
	for  set JD=$O(LNEAM(JD)) quit:JD=""  set BAL=BAL+LNEAM(JD)-LNEAM(JD).piece("|",2)

	quit BAL

 
public ENDBAL(ECID)

	/*
	The function is used to compute DEP.ENDBAL
 
	ARGUMENTS:
	. ECID		Escrow Account Number			/REQ/NONULL
 
	RETURNS:
	. $$		 Escrow End Balance using BEGBAL     	/TYP=$
 	*/

	/* Just don't understand this (Frank) !! */
 
 	type public RecordLNEAM lneam()
 	
	type Date APCND,JD
	type Number ER=0
	type String AED,CUSHF,CUSHO,data,EABE,ELE,ESC,ESCFRE,LNEAM()
	type Number BAL,BEGBAL,CID,CUSH,ENDBAL,ESCPMT
 
	set ENDBAL=0

	set ELE="ESC1"

	// Compute LNEAM
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	if dep.aref="" quit ""

	// Note:  CUSH* variables are referenced in LNEA
	set CUSH=dep.cusha
	set CUSHF=dep.cushf
	set CUSHO=dep.cusho
	set CID=ECID
	set ESCFRE=$P($$ELEFRE^LNU(dep.aref,"ESC1"),"|",1)

	type RecordLN ln=Db.getRecord("LN","CID=:dep.aref")

	if ln.ocaf set APCND=ln.ocadt
	else  set APCND=""

	if APCND="" quit ""

	type RecordLNAPCHGE eabe=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:dep.aref,ECID=:ECID",1)
	set EABE("CID").piece("|",10)=eabe.ereq
	do EXEC^LNEA(ln,.eabe,dep.aref,.LNEAM,"ESC1",APCND,dep.aed,"02",.data)
	if 'LNEAM.data() quit 0

	set ESCPMT=EABE("CID").piece("|",2)
	set JD=""
	for  set JD=$O(LNEAM(JD)) quit:JD=""  do {
		if LNEAM(JD) set LNEAM(JD).piece("|",1)=ESCPMT
		if lneam(JD).exists() do {
			set lneam(JD).pmt=ESCPMT
			do lneam(JD).save()
			}
		}

	set BAL=dep.begbal
	for  set JD=$O(LNEAM(JD)) quit:JD=""  set BAL=BAL+LNEAM(JD)-LNEAM(JD).piece("|",2)

	quit BAL


public GRCDYS(Number CID)

	/*
	The function is used to compute DEP.GRCDYS field.
	
	ARGUMENTS:
	. CID		Account Number			/REQ/NONULL/MECH=VAL
	
	RETURNS:
	. $$		Grace Days			/TYP=Number
	*/
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:dep.type")

	quit prodctl.grcdys

	
public MATGRC(Number CID)

	/*
	Maturity Date + Grace Days

	The function is used to compute DEP.MATGRAC field.
	
	ARGUMENTS:
	 . CID		Account Number  		/REQ/NONULL/MECH=VAL
	
	 RETURNS: Maturity Date + Grace Days
	*/	

	type Date MDT
	type Number GRCDAYS
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set MDT=dep.mdt
	set GRCDAYS=$$GRCDYS(CID)
	if ('GRCDAYS)!('MDT) quit ""
	quit MDT+GRCDAYS


public MATTRM(Number CID)

	/*
	Maturity Date + Term

	The function is used to compute DEP.MATTRM field.
	
	ARGUMENTS:
	 . CID		Account Number  		/REQ/NONULL/MECH=VAL
	
	 RETURNS: Maturity Date + Term
	*/

	type Date MDT
	type String TRM
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	set MDT=dep.mdt
	set TRM=dep.trm
	if (TRM="")!(MDT="") quit ""

	quit $$EXT^UMDT(TRM,MDT)

	
public INTYLDRD(Number CID)

	/*
	Effective Annual Int/Div Yield Rounded

	The function is used to compute DEP.INTYLDRD field.

	ARGUMENTS:
	 . XCID		Account Number			/REQ/NONULL/MECH=VAL

	RETURNS: INTYLD(Effective Annual Int/Div Yield) Rounded to two
		 decimal places.
	*/

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

	quit $$^SCARND(dep.intyld,,,,2)


public AB90D(Number CID)

	/*
	The average balance over the first 90 days from the date

	ARGUMENTS:
 	. CID		Account Number		    	/REQ/NONULL

	RETURNS:
	. $$ 90-Day Average Balance from Date of First Deposit
	*/

	type Number ER=0
	type String AB90D,RM
 
	do AB90D1^UAVB1
	if ER quit ""
	quit AB90D.piece("|",1)
 #OPTION ResultClass ON
Public String vSIG()	quit "60856^60751^Dan Russell^67870"	// Signature - LTD^TIME^USER^SIZE
