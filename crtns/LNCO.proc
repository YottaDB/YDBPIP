LNCO	// Computed Data Items Processor
	/*
	   ORIG:  Chuck Hardy (6721) - 02/25/86
	

	---- Revision History ------------------------------------------------

	07/31/06 - KELLYP - CR 22048
		   Modified EBBAL section to eliminate PRECEDENCE warning.

	05/18/06 - GIRIDHAL - CR 21297
		   Removed references to Split Day Processing
		   
	04/06/06 - SWARNALP - CR 20388
		   Modified PNTSPY section to remove TJD from the signature of the 
		   function PNTSPY and modified PNTSPY2 section to replace TJD 
		   with %SystemDate to be passed as parameter to the extrinsic 
		   function BOTY^SCADAT.
		   
	03/02/06 - TITOVE - CR 19733
		   Modified TSOPE section to instantiate an LNFEEP object with
		   a "create-if-needed" qualifier.

	02-28-06 - Teliv - CR 19797
		   Modified section LNAVLBAL to recalculate ln.avlbal on the basis of 
		   ln.wdlmt

	09/28/05 - Vince Arpa - CR 17327
		   In LNAVLBAL section, replacing variable TJD and set from
		   cuvar.tjd with variable %SystemDate.  Also cleaned up section to 
		   conform to PSL standards.
		   
	01/13/04 - Erik Scheetz - CR7798
		   Modified TSOAOI section and removed LNCYC reference 
		   (obsoleted) and replace with LNCYCDLD, LNCYCINS,
		   LNCYCMSC and LNCYCPTS.	
	
	12/09/04 - CARROLLJ - CR7239
		   Corrected undefined error in EBBAL section.

	08/25/03 - CARROLLJ - 51630
		   Correct null subscript error in TSOPE section when looking
		   for payment elements from bill.

	08/18/03 - CARROLLJ - 51630
		   Modified TSOPE section to remove two parameters being passed
		   to LNKFEE^LNBLDE.

	07/25/03 - CARROLLJ - 51349
		   Added CID to the call to XLN29^LNCO3 and removed old
		   revision history. 

	10/06/02 - Dan Russell - 49794
		   Modified call to ^UHLD to new syntax.

	*/

	quit

public LS(CID)	// 

	/* The function is used to compute the data item LN.XLN10,
	loan sale amount.

	Arguments:
 
	. CID	Customer Account Number			/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. XLN10	Loan Sale Amount			/TYP=$
 
	Example:
 
	W $$LS^LNCO(123)
 
	*/


	new BALCMP,D,FRE,ND,PP,%ICM
	set XLN10=""
	type RecordLN ln=Db.getRecord("LN","CID")
	
	set BALCMP=ln.bal 
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	set $P(XLN10,"|",3)=100 
	set $P(XLN10,"|",4)=BALCMP
	if 'ln.pflg quit 
	set IRN=ln.irn/100
	set D=""
	
	type ResultSet rs=Db.select("INCD,PL,OPTR,CCID","LNLS6","CID=:CID AND PSEQ>0")
	while rs.next() do { quit:ER
		set INCD=rs.getCol(1)
		set PL=rs.getCol(2)
		set OPTR=rs.getCol(3)
		set CCID=rs.getCol(4)
		do LS1(.ln,INCD,PL,OPTR,CCID)
		}
	set $P(XLN10,"|",2)=$$^SCARND($P(XLN10,"|",2),0,$G(CID))
	set $P(XLN10,"|",3)=100-$P(XLN10,"|",1)
	set $P(XLN10,"|",4)=BALCMP-$P(XLN10,"|",2)
	set $P(XLN10,"|",7)=$$^SCARND($P(XLN10,"|",7),0,$G(CID))
	set $P(XLN10,"|",9)=$P(XLN10,"|",7)+$P(XLN10,"|",8)
	quit 
	
LS1(RecordLN ln,INCD,PL,OPTR,CCID)	//

	new FRE,JD,LN1BAL,ND,PP,YLD,%ICM,%PCM
	
	/*
		INCD = INVESTOR
		PL = POOL_ID
		OPTR = OVERRIDE PASS-THRU RATE
	*/
	
	set OPTR=OPTR/100
	set LN1BAL=0
	if Db.isDefined("LNLS2","INCD,PL") do {
		type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD,PL")

		set $P(XLN10,"|",10)=$P(XLN10,"|",10)+1
		set $P(XLN10,"|",1)=$P(XLN10,"|",1)+lnls2.pp
		if 'D do {
			set $P(XLN10,"|",5)=INCD 
			set $P(XLN10,"|",6)=PL
			set D=1
			}
		
		set FRE=lnls2.feep
		set PP=lnls2.pp
		set YLD=lnls2.yield/100
		set %ICM=lnls2.picm 
		if '%ICM quit
		type RecordSTBLLSRCM srcm=Db.getRecord("STBLLSRCM","%ICM")
		set DESC=srcm.desc
		set %PCM=$E(DESC,1,2) 
		set %ICM=$E(DESC,3,4)
		set PSEQ=INCD
		if (%PCM="06") do {
			type RecordLN ln1=Db.getRecord("LN","CCID")
			set LN1BAL=ln1.bal
			}
		
		set $P(XLN10,"|",7)=(ln.acr*PP)+$P(XLN10,"|",7)
		set $P(XLN10,"|",2)=$P(XLN10,"|",2)+$S(%PCM="06":LN1BAL,1:BALCMP*PP/100)
		}
	quit
	
U(CID)	// 
	/* The function is used to compute the data item LN.XLN06,
	Current and uncollected amounts.

	Arguments:
 
	. CID	Customer Account Number			/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. XLN06	Current and uncollected amounts		/TYP=$
 
	Example:
 
	W $$U^LNCO(123)
 
	*/
	set XLN06="" 
	new CUIN2,UNIN2,CUPR2,UNPR2,XLN29
	
	type RecordLN ln=Db.getRecord("LN","CID")
	if ln.stat=4 quit 
	
	set (CUIN2,UNIN2,CUPR2,UNPR2)=0 
	set SCHSEQ=ln.schseq

	if ln.idp do {
		// CURDUE - current due  ESCDUE - tot esc due
		set ESCDUE=ln.cues+ln.unes
		if Db.isDefined("LNBIL1","CID,SCHSEQ") do {
			type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID,SCHSEQ")
			set CURDUE=lnbil1.casd
			}
		else  set CURDUE=0
		if ln.iam do {
			set CUPR2=CURDUE-ln.cues
			set UNPR2=ln.tdue-CUPR2-ESCDUE 
			}
		if ln.tdue<0 set CUPR2=ln.tdue-ESCDUE quit
		set CUIN2=CURDUE-ln.cues 
		if CUIN2>ln.acr do {
			set CUIN2=+ln.acr
			set CUPR2=CURDUE-ln.cues-CUIN2
			}
		if +ln.acr>CUIN2 set UNIN2=+ln.acr-CUIN2

		set UNPR2=ln.tdue-ESCDUE-UNIN2-CUIN2-CUPR2 
		if UNPR2>0 quit

		set UNIN2=UNIN2+UNPR2 
		set UNPR2=0 
		if UNIN2>0 quit
		set CUPR2=CUPR2+UNIN2 
		if CUPR2>0 quit
		set CUIN2=CUIN2+CUPR2
		}
	
	// Interest determined at billing
	if 'ln.idp do {
		set CUIN2=ln.cuin 
		set UNIN2=ln.unin
		set CUPR2=ln.cupr 
		set UNPR2=ln.unpr
		}	

	do XLN29^LNCO3(.ln,CID)
	set XLN06=CUIN2_"|"_UNIN2_"|"_CUPR2_"|"_UNPR2_"|"
	set XLN06=XLN06_(CUIN2+CUPR2+ln.cues+$P(XLN29,"|",5))_"|"
	set XLN06=XLN06_(ln.unes+ln.cues)_"|"_(CUIN2+UNIN2)_"|"_(CUPR2+UNPR2)_"|"
	set XLN06=XLN06_(UNIN2+UNPR2+ln.unes+$P(XLN29,"|",4))_"|"_ln.cues_"|"_ln.unes
	quit 
	

DLBTPC(CID) //
	/*
	Delinquency Loan Balances by Time Period Calculation
		Arguments:
 
	. CID	Customer Account Number			/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. XLN07	Delinquent Loan Balances		/TYP=$
 
	Example:
 
	W $$DLBTPC^LNCO(123)
	*/

	new DCC,DDATE,DPTO,dtlarr,N,PER,pmtarr,TYPE,X
	
	set ER=$$VIEW^PROCLNBL(CID,,.pmtarr,.dtlarr,,2) quit:ER 
	
	type RecordLN ln=Db.getRecord("LN","CID")
	set TYPE=ln.type

	for I=1:1:7 set DCC(I)=""
	//Load Delinquency counter
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	set CLS=prodctl.cls
	set GRP=prodctl.grp
	if prodctl.dcc1'="" set DCC(1)=prodctl.dcc1
	if prodctl.dcc2'="" set DCC(2)=prodctl.dcc2
	if prodctl.dcc3'="" set DCC(3)=prodctl.dcc3
	if prodctl.dcc4'="" set DCC(4)=prodctl.dcc4
	if prodctl.dcc5'="" set DCC(5)=prodctl.dcc5
	if prodctl.dcc6'="" set DCC(6)=prodctl.dcc6
	if prodctl.dcc7'="" set DCC(7)=prodctl.dcc7

	//Initialize all elements in every delinquent period to zero
	for I=1:1:7 do {
		set XLN07(I)="0|0|0|0"
		set DPTO(I)=0
		}
	
	//Read payment array
	set DDATE=""
	for  set DDATE=$O(pmtarr(DDATE)) quit:DDATE=""  do {
		//Set total amount of unpaid bill
		set DPTO=$P(pmtarr(DDATE),"|",1)
		//Is this loan delinquent
		if %SystemDate-DDATE<DCC(1) quit 
		//Determine delinquent period
		for I=7:-1:1 if DCC(I),(%SystemDate-DDATE'<DCC(I)) set PER=I quit 
		//Set total amount of unpaid bills for a delinquent period
		set DPTO(PER)=DPTO(PER)+DPTO
		//Read payment detail array
		set N=""
		for  set N=$O(dtlarr(DDATE,N)) quit:N=""  do {
			//set new X
			set X=dtlarr(DDATE,N)
			//set principal amount
			if ($P(X,"|",1)="P")!($P(X,"|",1)="P+I") set $P(XLN07(PER),"|",1)=$P(XLN07(PER),"|",1)+$P(X,"|",3) quit 
			//set interest amount
			if $P(X,"|",1)="I" set $P(XLN07(PER),"|",2)=$P(XLN07(PER),"|",2)+$P(X,"|",3) quit 
			//set escrow amount
			if $P(X,"|",1)["ESC" set $P(XLN07(PER),"|",3)=$P(XLN07(PER),"|",3)+$P(X,"|",3) quit 
			//else set fees amount
			set $P(XLN07(PER),"|",4)=$P(XLN07(PER),"|",4)+$P(X,"|",3) quit 
			}
		/*
		Sum amounts and compare with the total bill
		Calculated delinquency total due for a period does not match bill record
		*/
		if $P(XLN07(PER),"|",1)+$P(XLN07(PER),"|",2)+$P(XLN07(PER),"|",3)+$P(XLN07(PER),"|",4)'=DPTO(PER) set ER=1 set RM=$$^MSG(2972)
		}
	//Build XLN07
	set PER=""
	for  set PER=$O(XLN07(PER)) quit:PER=""  do {
		set I=4*(PER-1)+1
		set $P(XLN07,"|",I)=XLN07(PER)
		}
	
	quit 
	

AVLBAL(RecordLN ln,CID)	// Available balance (called by ^TTXODC)

	/*
	The function is used to calculate the Available balance
	
	ARGUMENTS: Either the Loan object must be passed in or the CID must be
		passed in.  It is an either/or requirement.  If the loan object
		has not been instantiated in the calling procedure, the CID
		will be used to create it.

	 . 	ln	Loan Account		/TYP=RecordLN/REQ=Y/N
	 .	CID	Customer Account 	/TYP=N/REQ=Y/N

	 RETURNS: 
	 .	AVLBAL  Available Balance	/TYP=$
	
	 EXAMPLE:  do AVLBAL^LNCO(.ln,)
		   do AVLBAL^LNCO(,CID)

	*/
	

	if 'ln.getPointer() do LNAVL1(CID) quit
	do LNAVLBAL(.ln)
	quit
	
LNAVL1(CID)

	type RecordLN ln=Db.getRecord("LN","CID")
	do LNAVLBAL(.ln)

	quit

LNAVLBAL(RecordLN ln)
	
	type Date XDAT
	type Number ACCUM,CID,HLDAMT
	type Public Boolean %STFPLAY
	type Public Number AVLBAL
	
	set XDAT=999999
	
	// 0 if overdue
	if 'ln.dist1nd.isNull(),(ln.ddra+ln.dist1nd<%SystemDate) set AVLBAL=0 quit
	if 'ln.mdt.isNull() set XDAT=ln.mdt
	if 'ln.clmd.isNull(),(ln.clmd<XDAT) set XDAT=ln.clmd
	
	// 0 if loan or credit limit have matured
	if XDAT'>%SystemDate set AVLBAL=0 quit
	
	if ln.stat=4 set AVLBAL=0 quit 
	// Consider interest billed/unpaid
	set ACCUM=0
	if ln.sibf do {
		if ln.cuin>0 set ACCUM=ACCUM+ln.cuin
		if ln.unin>0 set ACCUM=ACCUM+ln.unin
		}
	
	// Consider late charges
	if ln.raclc set ACCUM=ACCUM+ln.lchg
	
	// Consider loan fees
	if ln.raclf set ACCUM=ACCUM+$$XLN09EX^LNCDI(ln.cid,21)
	
	// Check for permanent holds
	set HLDAMT=0	      
	if ln.phld set HLDAMT=$$^UHLD(ln.cid,ln.balcmp,ln.crcd)

	set AVLBAL=ln.udbal-ln.chkhld-ACCUM-ln.coa+ln.rec+ln.donrsk-$G(HLDAMT)
	
	// If withdrawal limt, consider (ln.wdlmt-tdr) instead of udbal 
	if ln.wdlmt>0 set AVLBAL=ln.wdlmt-ln.tdr-ln.chkhld-ACCUM-ln.coa+ln.rec+ln.donrsk-$G(HLDAMT)
	
	if '(%STFPLAY.get()) set AVLBAL=AVLBAL-ln.stfnet
	if (ln.refinttytd!ln.collimpr),('ln.wdlmt.isNull()) set AVLBAL=(AVLBAL-ln.crlmt-ln.wdlmt)
	
	if ln.oltp set AVLBAL=AVLBAL+((ln.crlmt*ln.oltp)/100)
	
	if ln.pcidstat>0 set AVLBAL=0
	if AVLBAL<0 set AVLBAL=0
	
	quit 

	
public TSOESC(ETC) // Called by LNPTS2 to see if
	// escrow type should be prompted for.

	new N
	set TSOESC=0
	// Posting Action Control
	type RecordTRN trn=Db.getRecord("TRN","ETC")
	if trn.pac["LNPTS16"!(trn.pac["LNPTS25")!(trn.pac["LNPTS28") do {
		new ESCA
		do ESCA^LNES2(.ESCA)
		set N=""
		for  set N=$O(ESCA(N)) quit:N=""  set TSOESC=TSOESC+1
		}
	
	if TSOESC=1 do {
		set N=""
		for  set N=$O(ESCTBL(N)) quit:N=""  set UTSO("ESC")=N
		}
	quit 


public TSOESCT(ETC) // This is called by CRTQRY
	
	// Affect Escrow Remittance
	type RecordTRN trn=Db.getRecord("TRN","ETC")
		        
	set TSOESCT=trn.pcfd11
	quit 
	
public TSOREC(ETC,CID) // Called by pre-processor on miscellaneous fields TSO("RECOV") and

	/*
	   TSO("RECS") to see if recovery amount and recovery source should
	   be prompted for.

	ARGUMENTS:
		. ETC	Transaction Code	TYPE=T/REQ

		. CID	Account Number		TYPE=N/REQ

	EXAMPLE:
		do TSOREC^LNCO(trn.etc,ttx.cid)

	
	*/
	set TSOREC=0
	
	new BAL,BAL1
	set (BAL,BAL1)=0
	type RecordLN ln=Db.getRecord("LN","CID=:CID") 
	if ln.aruf set BAL=ln.bal-ln.udbal
	set BAL1=BAL-ln.coa+ln.rec
	type RecordTRN trn=Db.getRecord("TRN","ETC")
	// Posting Action Control
	if $E(trn.itc),BAL>BAL1,trn.pac'["LNPTS31" set TSOREC=1
	quit 
	

public TSOAOI(CID)

	/* 
	Called by pre-processor on tran code misc. field TSO("AOI")
	Returns array of add-on item values for this account.

	ARGUMENTS:

	. CID	Account Number		TYP=N/REQ

	RETURNS:

	. TSOAOI(TYP)			TYP=ARRAY	 

	EXAMPLE:
		do TSOAOI^LNCO(ttx.cid)

	*/

	type Public String TSOAOI()
	kill TSOAOI
	
	/*
	 Collate through each LNCYC* table to load each of the different 
	 add-on item types.
	*/
	
	type ResultSet rsdld=Db.select("TYP","LNCYCDLD","CID=:CID")
	while rsdld.next() do LOADTSO(rsdld.getCol("TYP"),.TSOAOI())

	type ResultSet rsins=Db.select("TYP","LNCYCINS","CID=:CID")
	while rsins.next() do LOADTSO(rsins.getCol("TYP"),.TSOAOI())

	type ResultSet rsmsc=Db.select("TYP","LNCYCMSC","CID=:CID")
	while rsmsc.next() do LOADTSO(rsmsc.getCol("TYP"),.TSOAOI())

	type ResultSet rspts=Db.select("TYP","LNCYCPTS","CID=:CID")
	while rspts.next() do LOADTSO(rspts.getCol("TYP"),.TSOAOI())

	quit

LOADTSO(String TYP,String TSOAOI())

	type RecordLNAOT lnaot=Db.getRecord("LNAOT","TYP=:TYP")
	set TSOAOI(TYP)=lnaot.desc_"|"_lnaot.bdt_"|"_lnaot.edt
	quit 
	

public TSOPE(CID) 
	
	/*
	Called by pre-processor on tran code misc. field TSO("PE").
	Returns array of payment elements from bill file.
	ARGUMENTS:

	. CID	Account Number		TYPE=N/REQ

	EXAMPLE:
		do TSOPE^LNCO(ttx.cid)

	*/
 
	new B,FEETYP,I,LFEE,P,TRTYPE,X,lnkfee
	kill PE
	
	type ResultSet rs=Db.select("SCHSEQ","LN","CID=:CID")
	if rs.isEmpty() quit
	while rs.next() set SCHSEQ=rs.getCol(1)
	do LNKFEE^LNBLDE(CID)

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
	set ROW=$$ELEMENT^BILFUNCS(.lnbil0)
	for I=1:1 do { quit:FEETYP=""
		set TRTYPE=0
		set FEETYP=$P(ROW,$C(9),I)
		if FEETYP="" quit
		if Db.isDefined("LNFEEP","FEETYP=:FEETYP") do {
			type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP")
			set PE(FEETYP)=lnfeep.desc
			}	
		else  if FEETYP="I"!(FEETYP="P") do {
			set TRTYPE=FEETYP
			type RecordLNTRS lntrs=Db.getRecord("LNTRS","TRTYPE")
			set PE(FEETYP)=lntrs.trdes
			}
		else  do {
			set TRTYPE=$TR(FEETYP,"123456789")
			type RecordLNTRS lntrs=Db.getRecord("LNTRS","TRTYPE")
			set PE(FEETYP)=lntrs.trdes
			}
	
		for  set LFEE=$O(lnkfee(FEETYP,LFEE)) quit:LFEE=""  do {
			type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP = :LFEE", 1)
			set PE(LFEE)=lnfeep.desc
			}
		}
	
	quit


public EBBAL(CID)	// Calculate estimated balloon balance

	/*
	The extrinsic function is used to calculate the estimated balloon balance
	
	 .	CID	Customer Account 		/TYP=N/REQ=Y
	

	 RETURNS: 
	 
	 .	EBBAL	Estimated Balloon Balance	/TYP=N
	
	 EXAMPLE: do $$EBBAL^LNCO(CID)

	*/
	
	new BAL,I,P,PAYREM,Z

	type RecordLN ln=Db.getRecord("LN","CID")
	if '$L(ln.pcm) quit ""
	set P=ln.pcm
	set BAL=ln.bal
	if ln.aruf set BAL=ln.udbal-ln.bal
	if '$D(PCM(ln.pcm)),Db.isDefined("STBLPCM","KEY=:P") do {
		type RecordSTBLPCM stblpcm=Db.getRecord("STBLPCM","KEY=:P")
		set PCM(P)=stblpcm.pcmp_"|"_stblpcm.desc
		}
	
	// Original # of payments
	set Z=ln.onp
	// Amoritization Base
	if Z'<ln.ambas quit 0
	if 'ln.dist1af quit BAL
	set I=ln.irn/(ln.dist1af*100)
	set PAYREM=1+I
	// find number of payments left (ONP-CNTCR)
	set Z=Z-ln.phld
	if PAYREM=1 quit BAL-(ln.pmtpi*Z)
	set PAYREM=$$EXP^%ZFUNC($$LNX^%ZFUNC(X)*Z)
	set PAYREM=((1-PAYREM)/I)*ln.pmtpi+(BAL*PAYREM) 
	if PAYREM<0 quit 0
	quit $$^SCARND(PAYREM,0,$G(CID))+ln.pmtpi
	

public DLCO(RecordLN ln,CID)	// Date of Last Charge-off

	/*
	The function is used to calculate the Last Charge-off
	
	ARGUMENTS: Either the Loan object must be passed in or the CID must be
		passed in.  It is an either/or requirement.  If the loan object
		has not been instantiated in the calling procedure, the CID
		will be used to create it.

	 . 	ln	Loan Object		/TYP=object
	 .	CID	Customer Account 	/TYP=N

	 RETURNS: DLCO
	
	 EXAMPLE:  do DLCO^LNCO(.ln,)
		   do DLCO^LNCO(,CID)

	*/

	set DLCO=""
	new N,H,ITC,TAMT

	// if loan obj not passed create it
	if 'ln.getPointer() do DLCO1(CID) quit
	do DLCO2(.ln)
	quit	

DLCO1(CID) // Create a loan object that will be killed upon exit from this proc

	Type RecordLN ln=Db.getRecord("LN","CID")
	do DLCO2(.ln)
	quit

DLCO2(RecordLN ln)

	if 'ln.coa quit 
	set N=""

	type ResultSet rs=Db.select("TJD,ITC,TAMT","HIST","CID=:CID")
	if rs.isEmpty() quit
	while rs.next() do { quit:DLCO'=""
		set ITC=rs.getCol(2)
		if $E(ITC)'=1 quit
		set TAMT=rs.getCol(3)
		if '$L($P(TAMT,"#",10)) quit
		set DLCO=rs.getCol(1)
		}
	quit 
	

public OPUID(CID)	// user who opened loan

	type RecordHIST hist=Db.getRecord("HIST","CID,1")

	//NEW ACCOUNT
	if hist.tcmt[$$^MSG(3941) quit hist.uid
	quit ""
	

public PNTSPY(RecordLN ln,CID,ODD,PNTSPD)
	
	/*
	The function is used to calculate Points paid - prior tax year
	
	ARGUMENTS: Either the Loan object must be passed in or the CID must be
		passed in.  It is an either/or requirement.  If the loan object
		has not been instantiated in the calling procedure, the CID
		will be used to create it.

	 . 	ln	Loan Object		   /TYP=object
	 .	CID	Customer Account 	   /TYP=N
	 . 	ODD	Original disbursement dt   /TYP=DATE
	 .	PNTSPD  Points Paid by borrower	   /TYP=N

	 RETURNS: DLCO
	
	 EXAMPLE:  do $$PNTSPY^LNCO(.ln)
		   do $$PNTSPY^LNCO(CID)

	*/

	set DLCO=""
	new H,ITC,N,TAMT
	if 'ln.getPointer() quit $$PNTSPY1(CID)
	quit $$PNTSPY2(.ln)

PNTSPY1(CID)
	
	type RecordLN ln=Db.getRecord("LN","CID")
	quit $$PNTSPY2(.ln)


PNTSPY2(RecordLN ln)

	new BPTY,EPTY,ODDY,TEPPY,TAXEPREV,X
	// beginning of tax year

	set TAXB=$$BOTY^SCADAT($$BOTY^SCADAT(%SystemDate,1)-1,1)
	// end of tax year
	set TAXE=$$EOTY^SCADAT(TAXB,1)
	// Check if the disbursement date is valid.
	// If called from DATA-QWIK
	if $G(ODD),$D(PNTSPD) quit $S((ODD'<TAXB)&(ODD'>TAXE):PNTSPD,1:0)
	
	set ODDY=ln.odd
	if ((ODDY<TAXB)!(ODDY>TAXE)) quit 0
	
	quit ln.pntspd
	

vSIG()	quit "60477^65450^Pat Kelly^16101"	// Signature - LTD^TIME^USER^SIZE
